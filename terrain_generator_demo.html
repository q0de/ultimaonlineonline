<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UO Terrain Generator Demo</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
        }
        .main-layout {
            display: flex;
            height: 100vh;
            width: 100vw;
        }
        .sidebar {
            width: 320px;
            background: #2a2a2a;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 15px;
            border-right: 2px solid #444;
            flex-shrink: 0;
        }
        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #444;
        }
        .sidebar-toggle {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
        }
        .sidebar.collapsed {
            width: 0;
            padding: 0;
            border: none;
            overflow: hidden;
        }
        .map-area {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #000;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 {
            color: #4CAF50;
            text-align: center;
            font-size: 20px;
            margin: 0;
        }
        .controls {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: inline-block;
            width: 150px;
            color: #b0b0b0;
        }
        input, select, button {
            padding: 8px 12px;
            margin: 5px;
            border: 1px solid #444;
            border-radius: 4px;
            background: #333;
            color: #e0e0e0;
        }
        button {
            background: #4CAF50;
            color: white;
            cursor: pointer;
            font-weight: bold;
        }
        button:hover {
            background: #45a049;
        }
        #canvasContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            overflow: hidden;
            cursor: grab;
            background: #000;
        }
        #canvasContainer:active {
            cursor: grabbing;
        }
        #canvas {
            position: absolute;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            transform-origin: 0 0;
        }
        .viewport-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }
        .viewport-controls button {
            padding: 5px 15px;
            font-size: 18px;
        }
        .viewport-controls span {
            min-width: 80px;
            text-align: center;
        }
        .info {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }
        .biome-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        .biome-item {
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
        }
        .grass { background: #228b22; }
        .sand { background: #daa520; color: #000; }
        .dirt { background: #8b4513; }
        .water { background: #1e90ff; }
        .forest { background: #2d5016; }
        .jungle { background: #1b4d1b; }
        .furrows { background: #654321; }
        
        /* ========== COLLAPSIBLE SECTIONS ========== */
        .section {
            background: #252525;
            border-radius: 6px;
            margin-bottom: 8px;
            border: 1px solid #3a3a3a;
            overflow: hidden;
        }
        .section-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            background: linear-gradient(to bottom, #353535, #2a2a2a);
            cursor: pointer;
            user-select: none;
            border-bottom: 1px solid transparent;
            transition: all 0.2s ease;
        }
        .section-header:hover {
            background: linear-gradient(to bottom, #404040, #353535);
        }
        .section.open .section-header {
            border-bottom-color: #3a3a3a;
        }
        .section-icon {
            font-size: 14px;
            width: 20px;
            text-align: center;
        }
        .section-title {
            font-size: 12px;
            font-weight: 600;
            color: #e0e0e0;
            flex: 1;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .section-chevron {
            font-size: 10px;
            color: #888;
            transition: transform 0.2s ease;
        }
        .section.open .section-chevron {
            transform: rotate(180deg);
        }
        .section-content {
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }
        .section.open .section-content {
            padding: 10px;
            max-height: 500px;
        }
        .section-content button {
            display: flex;
            align-items: center;
            gap: 6px;
            width: 100%;
            margin: 4px 0;
            padding: 8px 12px;
            font-size: 12px;
            text-align: left;
            border-radius: 4px;
            justify-content: flex-start;
        }
        .section-content button .btn-icon {
            font-size: 14px;
            width: 18px;
            flex-shrink: 0;
        }
        .section-content button .btn-text {
            flex: 1;
        }
        .btn-row {
            display: flex;
            gap: 6px;
        }
        .btn-row button {
            flex: 1;
        }
        .input-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 6px 0;
            padding: 6px 8px;
            background: #1a1a1a;
            border-radius: 4px;
        }
        .input-row label {
            font-size: 11px;
            color: #aaa;
            width: auto;
            min-width: 20px;
        }
        .input-row input[type="number"] {
            width: 55px;
            padding: 4px 6px;
            font-size: 11px;
            margin: 0;
        }
        .input-row button {
            flex: 0;
            width: auto;
            padding: 4px 10px;
            margin: 0;
        }
        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            background: #1a1a1a;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s ease;
        }
        .checkbox-item:hover {
            background: #252525;
        }
        .checkbox-item input[type="checkbox"] {
            margin: 0;
            width: 16px;
            height: 16px;
            accent-color: #4CAF50;
        }
        .checkbox-item .cb-icon {
            font-size: 14px;
        }
        .checkbox-item .cb-label {
            font-size: 12px;
            color: #ccc;
        }
        
        /* Button color themes */
        .btn-generate { background: linear-gradient(135deg, #4CAF50, #388E3C) !important; }
        .btn-generate:hover { background: linear-gradient(135deg, #66BB6A, #43A047) !important; }
        .btn-blue { background: linear-gradient(135deg, #2196F3, #1976D2) !important; }
        .btn-blue:hover { background: linear-gradient(135deg, #42A5F5, #1E88E5) !important; }
        .btn-orange { background: linear-gradient(135deg, #FF5722, #E64A19) !important; }
        .btn-orange:hover { background: linear-gradient(135deg, #FF7043, #F4511E) !important; }
        .btn-deep-orange { background: linear-gradient(135deg, #E65100, #BF360C) !important; }
        .btn-teal { background: linear-gradient(135deg, #00897B, #00695C) !important; }
        .btn-purple { background: linear-gradient(135deg, #9C27B0, #7B1FA2) !important; }
        .btn-purple:hover { background: linear-gradient(135deg, #AB47BC, #8E24AA) !important; }
        .btn-gray { background: linear-gradient(135deg, #607D8B, #455A64) !important; }
        .btn-gray:hover { background: linear-gradient(135deg, #78909C, #546E7A) !important; }
        .btn-brown { background: linear-gradient(135deg, #795548, #5D4037) !important; }
        .btn-cyan { background: linear-gradient(135deg, #00BCD4, #0097A7) !important; }
        .btn-pink { background: linear-gradient(135deg, #E91E63, #C2185B) !important; }
        .btn-gradient-fire { background: linear-gradient(135deg, #FF6B35, #F7931E) !important; }
        .btn-gradient-magic { background: linear-gradient(135deg, #E040FB, #7C4DFF) !important; }
        
        /* Tile Palette Styles */
        #tilePalette {
            position: fixed;
            right: 20px;
            top: 20px;
            width: 500px;
            max-height: 90vh;
            background: #2a2a2a;
            border: 2px solid #4CAF50;
            border-radius: 8px;
            padding: 15px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        #tilePalette.visible {
            display: block;
        }
        #tilePalette h3 {
            margin: 0 0 10px 0;
            color: #4CAF50;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 18px;
        }
        #tilePalette .close-btn {
            background: #f44336;
            border: none;
            color: white;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .palette-category {
            margin-bottom: 10px;
        }
        .palette-category-header {
            background: #333;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 4px;
            margin-bottom: 5px;
        }
        .palette-category-header:hover {
            background: #444;
        }
        .palette-tiles {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 6px;
            max-height: 400px;
            overflow-y: auto;
            padding: 5px;
            background: #1a1a1a;
            border-radius: 4px;
        }
        .palette-tile {
            width: 70px;
            height: 70px;
            border: 2px solid #444;
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            background: #000;
        }
        .palette-tile:hover {
            border-color: #4CAF50;
            transform: scale(1.05);
        }
        .palette-tile.selected {
            border-color: #ff9800;
            box-shadow: 0 0 10px #ff9800;
        }
        .palette-tile img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
        }
        .palette-tile .tile-id {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.85);
            font-size: 9px;
            text-align: center;
            color: #aaa;
            padding: 1px 0;
        }
        #selectedTileInfo {
            background: #333;
            padding: 10px;
            margin-top: 10px;
            border-radius: 4px;
            text-align: center;
        }
        #selectedTileInfo img {
            width: 88px;
            height: 88px;
            image-rendering: pixelated;
        }
        .paint-mode-indicator {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: #ff9800;
            color: #000;
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            z-index: 999;
            display: none;
        }
        .paint-mode-indicator.visible {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Paint Mode Indicator -->
    <div class="paint-mode-indicator" id="paintModeIndicator">
        ğŸ¨ PAINT MODE - Click on map to place tile | ESC to exit
    </div>

    <!-- Tile Palette -->
    <div id="tilePalette">
        <h3>
            ğŸ¨ Tile Palette
            <button class="close-btn" onclick="togglePalette()">âœ•</button>
        </h3>
        <div id="paletteCategories"></div>
        <div id="selectedTileInfo">
            <p>Click a tile to select it</p>
        </div>
    </div>

    <div class="main-layout">
        <!-- SIDEBAR -->
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <h1>ğŸŒ UO Terrain Generator</h1>
                <button class="sidebar-toggle" onclick="toggleSidebar()">â˜°</button>
            </div>

            <div class="controls">
        <h1>ğŸŒ UO Terrain Generator</h1>
        
            <div class="control-group">
                <label>Map Width:</label>
                <input type="number" id="width" value="50" min="10" max="200">
            </div>
            <div class="control-group">
                <label>Map Height:</label>
                <input type="number" id="height" value="50" min="10" max="200">
            </div>
            <div class="control-group">
                <label>Generation Type:</label>
                <select id="genType">
                    <option value="basic">Basic Terrain</option>
                    <option value="water">With Water Bodies</option>
                </select>
            </div>
            <div class="control-group">
                <label style="margin-left: 20px;">
                    <input type="checkbox" id="showStatics" checked> Show Statics (Height Objects)
                </label>
            </div>
            <div class="control-group">
                <label>Seed (optional):</label>
                <input type="number" id="seed" placeholder="Leave empty for random">
            </div>
            <!-- ========== GENERATE SECTION ========== -->
            <div class="section open" onclick="toggleSection(this, event)">
                <div class="section-header">
                    <span class="section-icon">ğŸ²</span>
                    <span class="section-title">Generate</span>
                    <span class="section-chevron">â–¼</span>
                </div>
                <div class="section-content" onclick="event.stopPropagation()">
                    <button onclick="generateTerrain()" class="btn-generate">
                        <span class="btn-icon">ğŸ²</span>
                        <span class="btn-text">Generate (Old)</span>
                    </button>
                    <button onclick="generateTerrainV2()" class="btn-blue">
                        <span class="btn-icon">âœ¨</span>
                        <span class="btn-text">Generate V2 (Proper Tiles)</span>
                    </button>
                </div>
            </div>

            <!-- ========== LOAD MAP SECTION ========== -->
            <div class="section open" onclick="toggleSection(this, event)">
                <div class="section-header">
                    <span class="section-icon">ğŸ—ºï¸</span>
                    <span class="section-title">Load Map</span>
                    <span class="section-chevron">â–¼</span>
                </div>
                <div class="section-content" onclick="event.stopPropagation()">
                    <button onclick="loadRealUOMap()" class="btn-orange">
                        <span class="btn-icon">ğŸ²</span>
                        <span class="btn-text">Random Region</span>
                    </button>
                    <button onclick="loadBritainRegion()" class="btn-deep-orange">
                        <span class="btn-icon">ğŸ°</span>
                        <span class="btn-text">Britain</span>
                    </button>
                    <button onclick="loadLastRegion()" class="btn-teal">
                        <span class="btn-icon">ğŸ–ï¸</span>
                        <span class="btn-text">Coastline (3197,18)</span>
                    </button>
                    <div class="input-row">
                        <label>X:</label>
                        <input type="number" id="customX" value="1400">
                        <label>Y:</label>
                        <input type="number" id="customY" value="1600">
                        <button onclick="loadCustomCoords()" class="btn-purple">ğŸ“ Load</button>
                    </div>
                </div>
            </div>

            <!-- ========== TESTING SECTION ========== -->
            <div class="section" onclick="toggleSection(this, event)">
                <div class="section-header">
                    <span class="section-icon">ğŸ§ª</span>
                    <span class="section-title">Testing</span>
                    <span class="section-chevron">â–¼</span>
                </div>
                <div class="section-content" onclick="event.stopPropagation()">
                    <button onclick="generateCliffTest('rough')" class="btn-gray">
                        <span class="btn-icon">ğŸ”ï¸</span>
                        <span class="btn-text">Rock Face</span>
                    </button>
                    <button onclick="generateCliffTest('cave')" class="btn-gray">
                        <span class="btn-icon">ğŸ•³ï¸</span>
                        <span class="btn-text">Cave Face</span>
                    </button>
                    <button onclick="generateCliffTest('match')" class="btn-brown">
                        <span class="btn-icon">â›°ï¸</span>
                        <span class="btn-text">Match Image (Mountain)</span>
                    </button>
                    <button onclick="generateTestSandWater()" class="btn-cyan">
                        <span class="btn-icon">ğŸŒŠ</span>
                        <span class="btn-text">Sand + Water</span>
                    </button>
                    <button onclick="testPureGrass2x2()" class="btn-generate">
                        <span class="btn-icon">ğŸŒ¿</span>
                        <span class="btn-text">Pure Grass 2x2</span>
                    </button>
                </div>
            </div>

            <!-- ========== TOOLS SECTION ========== -->
            <div class="section" onclick="toggleSection(this, event)">
                <div class="section-header">
                    <span class="section-icon">ğŸ› ï¸</span>
                    <span class="section-title">Tools</span>
                    <span class="section-chevron">â–¼</span>
                </div>
                <div class="section-content" onclick="event.stopPropagation()">
                    <button onclick="openTileViewer()" class="btn-purple">
                        <span class="btn-icon">ğŸ¨</span>
                        <span class="btn-text">Tile Viewer</span>
                    </button>
                    <button onclick="togglePalette()" class="btn-orange">
                        <span class="btn-icon">ğŸ–Œï¸</span>
                        <span class="btn-text">Paint Mode</span>
                    </button>
                    <button onclick="toggleTileTeacher()" class="btn-purple">
                        <span class="btn-icon">ğŸ“</span>
                        <span class="btn-text">Tile Teacher</span>
                    </button>
                    <button onclick="togglePatternDesigner()" class="btn-brown">
                        <span class="btn-icon">ğŸ§±</span>
                        <span class="btn-text">Stitch Designer</span>
                    </button>
                </div>
            </div>

            <!-- ========== ADVANCED SECTION ========== -->
            <div class="section open" onclick="toggleSection(this, event)">
                <div class="section-header">
                    <span class="section-icon">âš¡</span>
                    <span class="section-title">Advanced</span>
                    <span class="section-chevron">â–¼</span>
                </div>
                <div class="section-content" onclick="event.stopPropagation()">
                    <button onclick="testProceduralStatics()" class="btn-gradient-fire">
                        <span class="btn-icon">ğŸŒ²</span>
                        <span class="btn-text">Procedural Statics</span>
                    </button>
                    <button onclick="spawnCharacter()" class="btn-gradient-magic">
                        <span class="btn-icon">ğŸ§™</span>
                        <span class="btn-text">Spawn Character</span>
                    </button>
                    <button onclick="toggleLearningMode()" class="btn-purple">
                        <span class="btn-icon">ğŸ§ </span>
                        <span class="btn-text">Learning Mode</span>
                    </button>
                </div>
            </div>

            <!-- ========== EXPORT/DATA SECTION ========== -->
            <div class="section" onclick="toggleSection(this, event)">
                <div class="section-header">
                    <span class="section-icon">ğŸ’¾</span>
                    <span class="section-title">Export / Data</span>
                    <span class="section-chevron">â–¼</span>
                </div>
                <div class="section-content" onclick="event.stopPropagation()">
                    <button onclick="exportMap()" class="btn-generate">
                        <span class="btn-icon">ğŸ’¾</span>
                        <span class="btn-text">Export Map Data</span>
                    </button>
                    <button onclick="exportForLearning()" class="btn-pink">
                        <span class="btn-icon">ğŸ“š</span>
                        <span class="btn-text">Export for AI Learning</span>
                    </button>
                    <button onclick="loadLandTiles()" class="btn-gray">
                        <span class="btn-icon">ğŸ”„</span>
                        <span class="btn-text">Reload Tile Data</span>
                    </button>
                </div>
            </div>

            <!-- ========== DISPLAY OPTIONS ========== -->
            <div class="section open" onclick="toggleSection(this, event)">
                <div class="section-header">
                    <span class="section-icon">ğŸ‘ï¸</span>
                    <span class="section-title">Display</span>
                    <span class="section-chevron">â–¼</span>
                </div>
                <div class="section-content" onclick="event.stopPropagation()">
                    <div class="checkbox-group">
                        <label class="checkbox-item">
                            <input type="checkbox" id="showTileIds" onchange="toggleTileIds()">
                            <span class="cb-icon">ğŸ”¢</span>
                            <span class="cb-label">Show Tile IDs</span>
                        </label>
                        <label class="checkbox-item" style="background: linear-gradient(135deg, #3a1a2e, #1a1a2e);">
                            <input type="checkbox" id="enable3DHeight" checked>
                            <span class="cb-icon">ğŸ”ï¸</span>
                            <span class="cb-label">3D Height</span>
                        </label>
                        <label class="checkbox-item" style="background: #0d3d35;">
                            <input type="checkbox" id="trustOriginalTiles" checked>
                            <span class="cb-icon">ğŸ“œ</span>
                            <span class="cb-label">Trust Original Map</span>
                        </label>
                    </div>
                </div>
            </div>
            
            <!-- ANIMATION SETTINGS SECTION -->
            <div class="section open" onclick="toggleSection(this, event)">
                <div class="section-header">
                    <span class="section-icon">ğŸ¬</span>
                    <span class="section-title">Animation</span>
                    <span class="section-chevron">â–¼</span>
                </div>
                <div class="section-content" onclick="event.stopPropagation()">
                    <div style="padding: 5px 0;">
                        <label style="color: #aaa; font-size: 11px; display: block; margin-bottom: 3px;">Animation Mode</label>
                        <select id="animModeSelect" onchange="updateAnimationMode()" style="width: 100%; padding: 6px; background: #2a2a3e; color: #fff; border: 1px solid #444; border-radius: 4px;">
                            <option value="classic">ClassicUO (5 frames, movement synced)</option>
                            <option value="smooth" selected>Smooth (110ms/70ms, all frames)</option>
                            <option value="fast">Fast Run (60ms walk, 40ms run)</option>
                            <option value="custom">Custom</option>
                        </select>
                    </div>
                    <div style="padding: 5px 0;">
                        <label style="color: #aaa; font-size: 11px; display: block; margin-bottom: 3px;">Walk Frame Duration: <span id="walkFrameLabel">110</span>ms</label>
                        <input type="range" id="walkFrameSlider" min="20" max="200" value="110" onchange="updateWalkFrameDuration()" style="width: 100%;">
                    </div>
                    <div style="padding: 5px 0;">
                        <label style="color: #aaa; font-size: 11px; display: block; margin-bottom: 3px;">Run Frame Duration: <span id="runFrameLabel">70</span>ms</label>
                        <input type="range" id="runFrameSlider" min="10" max="120" value="70" onchange="updateRunFrameDuration()" style="width: 100%;">
                    </div>
                    <div style="padding: 5px 0;">
                        <label style="color: #aaa; font-size: 11px; display: block; margin-bottom: 3px;">Frame Selection</label>
                        <select id="frameSkipSelect" onchange="updateFrameSkip()" style="width: 100%; padding: 6px; background: #2a2a3e; color: #fff; border: 1px solid #444; border-radius: 4px;">
                            <option value="all" selected>All frames (0,1,2,3...9)</option>
                            <option value="skip2">Skip every other (0,2,4,6,8)</option>
                            <option value="first5">First 5 only (0,1,2,3,4)</option>
                            <option value="last5">Last 5 only (5,6,7,8,9)</option>
                        </select>
                    </div>
                    <div style="padding: 5px 0;">
                        <label style="color: #aaa; font-size: 11px; display: block; margin-bottom: 3px;">Animation Sync</label>
                        <select id="animSyncSelect" onchange="updateAnimSync()" style="width: 100%; padding: 6px; background: #2a2a3e; color: #fff; border: 1px solid #444; border-radius: 4px;">
                            <option value="time" selected>Time-based (independent)</option>
                            <option value="movement">Movement-synced (UO style)</option>
                        </select>
                    </div>
                    <div style="padding: 5px 0; font-size: 10px; color: #666; border-top: 1px solid #333; margin-top: 8px; padding-top: 8px;">
                        <strong style="color: #888;">Debug Info (top-right corner)</strong><br>
                        â€¢ Green box = current frame<br>
                        â€¢ Cyan = frames in use<br>
                        â€¢ Gray = skipped frames
                    </div>
                </div>
            </div>
            </div>
        
        <!-- LEARNING MODE PANEL -->
        <div id="learningMode" style="display: none; background: #1a1a2e; border: 2px solid #9C27B0; border-radius: 8px; padding: 15px; margin: 10px 0;">
            <h3 style="color: #9C27B0; margin-top: 0;">ğŸ§  Learning Mode - Analyze Real UO Maps</h3>
            <p style="color: #ccc; font-size: 12px; margin-bottom: 15px;">
                Load larger regions to learn patterns: tile transitions, biome distributions, embankment placement, static object locations.
                This data will improve V2 terrain generation accuracy.
            </p>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                <div>
                    <label style="color: #fff; display: block; margin-bottom: 5px;">Region X:</label>
                    <input type="number" id="learnRegionX" value="1400" style="width: 100%; padding: 5px;">
                </div>
                <div>
                    <label style="color: #fff; display: block; margin-bottom: 5px;">Region Y:</label>
                    <input type="number" id="learnRegionY" value="1600" style="width: 100%; padding: 5px;">
                </div>
                <div>
                    <label style="color: #fff; display: block; margin-bottom: 5px;">Width:</label>
                    <input type="number" id="learnWidth" value="100" style="width: 100%; padding: 5px;">
                </div>
                <div>
                    <label style="color: #fff; display: block; margin-bottom: 5px;">Height:</label>
                    <input type="number" id="learnHeight" value="100" style="width: 100%; padding: 5px;">
                </div>
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="color: #fff; display: block; margin-bottom: 5px;">Analysis Options:</label>
                <label style="color: #ccc; display: block; margin: 5px 0;">
                    <input type="checkbox" id="learnTileTransitions" checked> Analyze Tile Transitions
                </label>
                <label style="color: #ccc; display: block; margin: 5px 0;">
                    <input type="checkbox" id="learnBiomeDistribution" checked> Analyze Biome Distribution
                </label>
                <label style="color: #ccc; display: block; margin: 5px 0;">
                    <input type="checkbox" id="learnEmbankments" checked> Analyze Embankment Placement
                </label>
                <label style="color: #ccc; display: block; margin: 5px 0;">
                    <input type="checkbox" id="learnStatics" checked> Analyze Static Object Placement
                </label>
                <label style="color: #ccc; display: block; margin: 5px 0;">
                    <input type="checkbox" id="learnZHeight" checked> Analyze Z-Height Patterns
                </label>
            </div>
            
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                <button onclick="startLearningAnalysis()" style="background: #9C27B0; padding: 10px 20px; border: none; border-radius: 5px; color: white; cursor: pointer;">
                    ğŸ” Start Analysis
                </button>
                <button onclick="exportLearningData()" style="background: #4CAF50; padding: 10px 20px; border: none; border-radius: 5px; color: white; cursor: pointer;">
                    ğŸ’¾ Export Findings
                </button>
                <button onclick="clearLearningData()" style="background: #f44336; padding: 10px 20px; border: none; border-radius: 5px; color: white; cursor: pointer;">
                    ğŸ—‘ï¸ Clear Data
                </button>
            </div>
            
            <div id="learningResults" style="background: #252545; padding: 10px; border-radius: 5px; max-height: 300px; overflow-y: auto; font-family: monospace; font-size: 11px; color: #ccc;">
                <div style="color: #9C27B0; font-weight: bold; margin-bottom: 10px;">Analysis Results:</div>
                <div id="learningOutput">No analysis run yet. Click "Start Analysis" to begin.</div>
            </div>
        </div>
        
        <!-- TILE TEACHER PANEL -->
        <div id="tileTeacher" style="display: none; background: #1a1a2e; border: 2px solid #4CAF50; border-radius: 8px; padding: 15px; margin: 10px 0;">
            <h3 style="color: #4CAF50; margin-top: 0;">ğŸ“ Tile Teaching System</h3>
            
            <!-- TRANSITION TYPE SELECTOR -->
            <div style="margin-bottom: 15px; padding: 10px; background: #252545; border-radius: 5px;">
                <label style="color: #fff; font-weight: bold; margin-right: 10px;">ğŸ”„ Transition Type:</label>
                <select id="transitionSelect" onchange="switchTransition(this.value)" style="padding: 8px 15px; font-size: 14px; border-radius: 5px; background: #333; color: #fff; border: 2px solid #4CAF50;">
                    <option value="grass_sand">ğŸŒ±â†”ğŸ–ï¸ Grass â†” Sand âœ…</option>
                    <option value="grass_water">ğŸŒ±â†”ğŸ’§ Grass â†” Water</option>
                    <option value="sand_water">ğŸ–ï¸â†”ğŸ’§ Sand â†” Water</option>
                    <option value="grass_dirt">ğŸŒ±â†”ğŸŸ¤ Grass â†” Dirt</option>
                    <option value="grass_rock">ğŸŒ±â†”ğŸª¨ Grass â†” Rock</option>
                    <option value="grass_jungle">ğŸŒ±â†”ğŸŒ´ Grass â†” Jungle</option>
                    <option value="grass_forest">ğŸŒ±â†”ğŸŒ² Grass â†” Forest</option>
                    <option value="sand_dirt">ğŸ–ï¸â†”ğŸŸ¤ Sand â†” Dirt</option>
                    <option value="jungle_sand">ğŸŒ´â†”ğŸ–ï¸ Jungle â†” Sand</option>
                    <option value="forest_sand">ğŸŒ²â†”ğŸ–ï¸ Forest â†” Sand</option>
                    <option value="jungle_dirt">ğŸŒ´â†”ğŸŸ¤ Jungle â†” Dirt (Mud)</option>
                    <option value="forest_dirt">ğŸŒ²â†”ğŸŸ¤ Forest â†” Dirt (Mud)</option>
                    <option value="grass_embank_water">ğŸ”ï¸ Grass Cliff â†” Water</option>
                    <option value="sand_embank_water">ğŸ–ï¸ Sand Cliff â†” Water</option>
                    <option value="rock_cliff_land">ğŸ”ï¸ Rock Cliff â†” Grass</option>
                    <option value="browse_all">ğŸ” Browse ALL Tiles (512)</option>
                </select>
                <span id="transitionStatus" style="color: #4CAF50; margin-left: 15px;">âœ… Grass/Sand loaded</span>
            </div>
            
            <p style="color: #aaa; font-size: 12px;">Click tiles on the map to select them, then click a tile below to replace. Changes auto-save per transition.</p>
            
            <!-- TEST PATTERN BUTTONS -->
            <div style="margin-bottom: 15px; padding: 10px; background: #252545; border-radius: 5px;">
                <label style="color: #fff; font-weight: bold; margin-right: 10px;">ğŸ§ª Test Patterns:</label>
                <button onclick="generateTestDiagonal1()" style="background: #FF9800; margin: 2px;">â†—ï¸ Diagonal 1</button>
                <button onclick="generateTestDiagonal2()" style="background: #FF5722; margin: 2px;">â†˜ï¸ Diagonal 2</button>
                <button onclick="generateTestOuterCorners()" style="background: #8BC34A; margin: 2px;">â—‡ Outer Corners</button>
                <button onclick="generateTestInnerCorners()" style="background: #CDDC39; margin: 2px;">â—† Inner Corners</button>
            </div>
            
            <div style="margin-bottom: 10px;">
                <label style="color: #fff; margin-right: 10px;">Selection Mode:</label>
                <button onclick="setSelectionMode('diag1')" id="btnDiag1" style="background: #FF9800;">Diagonal â†—</button>
                <button onclick="setSelectionMode('diag2')" id="btnDiag2">Diagonal â†˜</button>
                <button onclick="setSelectionMode('case')" id="btnCase">By Case</button>
                <span id="selectionInfo" style="color: #ff0; margin-left: 15px;">Click a tile on the map...</span>
            </div>
            
            <div style="margin-bottom: 10px;">
                <button onclick="saveTileMappings()" style="background: #4CAF50;">ğŸ’¾ Save Mappings</button>
                <button onclick="resetTileMappings()" style="background: #f44336;">ğŸ”„ Reset to Default</button>
                <button onclick="exportTileMappings()">ğŸ“‹ Export JSON</button>
                <button onclick="exportAllTransitions()" style="background: #9C27B0;">ğŸ“¦ Export ALL Transitions</button>
            </div>
            
            <h4 style="color: #fff; margin: 10px 0 5px 0;">Current 16 Cases for <span id="currentTransitionLabel">Grassâ†”Sand</span>:</h4>
            <div id="caseGrid" style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 5px; margin-bottom: 15px;"></div>
            
            <h4 style="color: #fff; margin: 10px 0 5px 0;">Available Tiles for <span id="availableTilesLabel">Grass/Sand</span> (<span id="tileCount">0</span>):</h4>
            <div id="allTilesGrid" style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 5px; max-height: 300px; overflow-y: auto;"></div>
        </div>

        <!-- PATTERN DESIGNER PANEL -->
        <div id="patternDesigner" style="display: none; background: #2e1a1a; border: 2px solid #795548; border-radius: 8px; padding: 15px; margin: 10px 0;">
            <h3 style="color: #bcaaa4; margin-top: 0;">ğŸ§± Mountain Stitch Designer</h3>
            <p style="color: #ccc; font-size: 13px;">Paint the 8 mountain tiles (`0x01D3`-`0x01DA`) onto this 4x4 grid to define the stitching pattern. 
            This allows you to show exactly how the tiles should tessellate.</p>
            
            <div style="display: flex; gap: 20px; margin-top: 15px;">
                <!-- The Grid -->
                <div style="background: #1a0e0e; padding: 10px; border-radius: 6px;">
                    <h4 style="margin: 0 0 10px 0; color: #ccc;">Pattern Grid (4x4)</h4>
                    <div id="stitchGrid" style="display: grid; grid-template-columns: repeat(4, 64px); gap: 2px; background: #000; padding: 2px; border: 1px solid #555;">
                        <!-- 16 cells generated by JS -->
                    </div>
                    <div style="text-align: center; margin-top: 5px; color: #777; font-size: 11px;">Click to paint</div>
                </div>
                
                <!-- The Palette -->
                <div style="background: #1a0e0e; padding: 10px; border-radius: 6px;">
                    <h4 style="margin: 0 0 10px 0; color: #ccc;">Mountain Tiles (Palette)</h4>
                    <div id="stitchPalette" style="display: grid; grid-template-columns: repeat(4, 64px); gap: 5px;">
                        <!-- 8 tiles generated by JS -->
                    </div>
                    <div style="margin-top: 10px; padding: 5px; background: #333; border-radius: 4px; text-align: center;">
                        <span style="color: #aaa; font-size: 12px;">Selected:</span>
                        <span id="currentStitchTileDisplay" style="color: #fff; font-weight: bold;">None</span>
                    </div>
                </div>
            </div>
            
            <div style="margin-top: 15px; display: flex; gap: 10px;">
                <button onclick="applyStitchPattern()" style="background: #4CAF50; padding: 8px 15px;">ğŸ’¾ Apply Pattern & Test</button>
                <button onclick="clearStitchGrid()" style="background: #FF9800;">ğŸ§¹ Clear</button>
                <button onclick="togglePatternDesigner()" style="background: #f44336;">âŒ Close</button>
            </div>
        </div>
        
            <div class="controls viewport-controls">
                <label>Viewport:</label>
                <button onclick="zoomIn()">â• Zoom In</button>
                <button onclick="zoomOut()">â– Zoom Out</button>
                <span id="zoomLevel">100%</span>
                <button onclick="resetView()">ğŸ”„ Reset View</button>
                <button onclick="centerOnTerrain()">ğŸ¯ Center</button>
                <button onclick="fitToView()">ğŸ“ Fit All</button>
            </div>
            
            <div class="info">
                <h3>Biome Legend:</h3>
                <div class="biome-legend">
                    <span class="biome-item grass">ğŸŒ± Grass</span>
                    <span class="biome-item sand">ğŸ–ï¸ Sand</span>
                    <span class="biome-item dirt">ğŸŸ¤ Dirt</span>
                    <span class="biome-item water">ğŸ’§ Water</span>
                    <span class="biome-item forest">ğŸŒ² Forest</span>
                    <span class="biome-item jungle">ğŸŒ´ Jungle</span>
                    <span class="biome-item furrows">ğŸŒ¾ Furrows</span>
                </div>
                <div id="statusContainer" style="background: #1a1a2e; padding: 10px; border-radius: 5px; margin: 10px 0; border: 2px solid #4CAF50;">
                    <p id="status" style="margin: 0; font-size: 14px; font-weight: bold; color: #4CAF50;">Ready</p>
                    <div id="progressBar" style="width: 0%; height: 4px; background: #4CAF50; margin-top: 5px; border-radius: 2px; transition: width 0.3s;"></div>
                </div>
            </div>
            
            <!-- COLLAPSIBLE TILE TESTER SECTION -->
        <details style="margin-top: 20px;">
            <summary style="background: #3a3a3a; padding: 15px; border-radius: 8px; cursor: pointer; font-size: 18px; color: #ff9800;">
                ğŸ”§ <strong>Tile Transition Testers</strong> (Click to expand)
            </summary>
            
            <div class="controls" style="margin-top: 10px;">
            
            <!-- Sand Transition Tile Tester - EDGES + CORNERS with Auto-Apply -->
            <div class="control-group" style="background: #3a3a3a; padding: 15px; border-radius: 8px; margin-top: 10px;">
                <h4 style="margin: 0 0 10px 0; color: #ff9800;">ğŸ–ï¸ Sand Transition Tile Tester - EDGES & CORNERS</h4>
                
                <!-- Visual diagram showing isometric diamond with corners -->
                <div style="text-align: center; margin-bottom: 15px; padding: 10px; background: #222; border-radius: 8px;">
                    <pre style="color: #aaa; font-family: monospace; margin: 0; font-size: 11px;">
           TOP-LEFT corner    TOP-RIGHT corner
                  â†˜              â†™
        GRASS â—¢â—£â—¢â—£â—¢â—£â—¢â—£ GRASS
              â—¢          â—£
    LEFT  â—¢                â—£  RIGHT
    edge  â—¥                â—¤  edge
              â—¥          â—¤
        GRASS â—¥â—¤â—¥â—¤â—¥â—¤â—¥â—¤ GRASS
                  â†—              â†–
         BOTTOM-LEFT corner  BOTTOM-RIGHT corner
                    </pre>
                </div>
                
                <!-- EDGES Section -->
                <h5 style="color: #4fc3f7; margin: 10px 0 5px 0;">ğŸ“ SINGLE EDGES (grass on ONE side)</h5>
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px;">
                    <div style="background: #2a3a4a; padding: 8px; border-radius: 6px; text-align: center;">
                        <label style="color: #64b5f6; font-weight: bold; font-size: 12px;">â¬†ï¸ TOP</label><br>
                        <img id="topEdgePreview" src="" style="width: 44px; height: 44px; margin: 5px 0; background: #111; border: 1px solid #444;">
                        <select id="topEdgeSelect" onchange="autoApplyTest()" style="width: 100%; font-size: 11px;">
                            <optgroup label="Basic (0x0033-0x003E)">
                                <option value="0x0033">0x0033</option>
                                <option value="0x0034">0x0034</option>
                                <option value="0x0035">0x0035</option>
                                <option value="0x0036">0x0036</option>
                                <option value="0x0037">0x0037</option>
                                <option value="0x0038">0x0038</option>
                                <option value="0x0039">0x0039</option>
                                <option value="0x003A" selected>0x003A âœ“</option>
                                <option value="0x003B">0x003B</option>
                                <option value="0x003C">0x003C</option>
                                <option value="0x003D">0x003D</option>
                                <option value="0x003E">0x003E</option>
                            </optgroup>
                            <optgroup label="Extended (0x01A8-0x01BF)">
                                <option value="0x01A8">0x01A8</option>
                                <option value="0x01A9">0x01A9</option>
                                <option value="0x01AA">0x01AA</option>
                                <option value="0x01AB">0x01AB</option>
                                <option value="0x01AC">0x01AC</option>
                                <option value="0x01AD">0x01AD</option>
                                <option value="0x01AE">0x01AE</option>
                                <option value="0x01AF">0x01AF</option>
                                <option value="0x01B0">0x01B0</option>
                                <option value="0x01B1">0x01B1</option>
                                <option value="0x01B2">0x01B2</option>
                                <option value="0x01B3">0x01B3</option>
                                <option value="0x01B4">0x01B4</option>
                                <option value="0x01B5">0x01B5</option>
                                <option value="0x01B6">0x01B6</option>
                                <option value="0x01B7">0x01B7</option>
                                <option value="0x01B8">0x01B8</option>
                                <option value="0x01B9">0x01B9</option>
                                <option value="0x01BA">0x01BA</option>
                                <option value="0x01BB">0x01BB</option>
                                <option value="0x01BC">0x01BC</option>
                                <option value="0x01BD">0x01BD</option>
                                <option value="0x01BE">0x01BE</option>
                                <option value="0x01BF">0x01BF</option>
                            </optgroup>
                            <optgroup label="Grass-Heavy (0x03BF-0x03C6)">
                                <option value="0x03BF">0x03BF</option>
                                <option value="0x03C0">0x03C0</option>
                                <option value="0x03C1">0x03C1</option>
                                <option value="0x03C2">0x03C2</option>
                                <option value="0x03C3">0x03C3</option>
                                <option value="0x03C4">0x03C4</option>
                                <option value="0x03C5">0x03C5</option>
                                <option value="0x03C6">0x03C6</option>
                            </optgroup>
                            <optgroup label="Pure">
                                <option value="0x0016">Pure Sand</option>
                            </optgroup>
                        </select>
                    </div>
                    <div style="background: #4a3a2a; padding: 8px; border-radius: 6px; text-align: center;">
                        <label style="color: #ffb74d; font-weight: bold; font-size: 12px;">â¬‡ï¸ BOTTOM</label><br>
                        <img id="bottomEdgePreview" src="" style="width: 44px; height: 44px; margin: 5px 0; background: #111; border: 1px solid #444;">
                        <select id="bottomEdgeSelect" onchange="autoApplyTest()" style="width: 100%; font-size: 11px;">
                            <optgroup label="Basic (0x0033-0x003E)">
                                <option value="0x0033">0x0033</option>
                                <option value="0x0034">0x0034</option>
                                <option value="0x0035">0x0035</option>
                                <option value="0x0036">0x0036</option>
                                <option value="0x0037">0x0037</option>
                                <option value="0x0038">0x0038</option>
                                <option value="0x0039" selected>0x0039 âœ“</option>
                                <option value="0x003A">0x003A</option>
                                <option value="0x003B">0x003B</option>
                                <option value="0x003C">0x003C</option>
                                <option value="0x003D">0x003D</option>
                                <option value="0x003E">0x003E</option>
                            </optgroup>
                            <optgroup label="Extended (0x01A8-0x01BF)">
                                <option value="0x01A8">0x01A8</option>
                                <option value="0x01A9">0x01A9</option>
                                <option value="0x01AA">0x01AA</option>
                                <option value="0x01AB">0x01AB</option>
                                <option value="0x01AC">0x01AC</option>
                                <option value="0x01AD">0x01AD</option>
                                <option value="0x01AE">0x01AE</option>
                                <option value="0x01AF">0x01AF</option>
                                <option value="0x01B0">0x01B0</option>
                                <option value="0x01B1">0x01B1</option>
                                <option value="0x01B2">0x01B2</option>
                                <option value="0x01B3">0x01B3</option>
                                <option value="0x01B4">0x01B4</option>
                                <option value="0x01B5">0x01B5</option>
                                <option value="0x01B6">0x01B6</option>
                                <option value="0x01B7">0x01B7</option>
                                <option value="0x01B8">0x01B8</option>
                                <option value="0x01B9">0x01B9</option>
                                <option value="0x01BA">0x01BA</option>
                                <option value="0x01BB">0x01BB</option>
                                <option value="0x01BC">0x01BC</option>
                                <option value="0x01BD">0x01BD</option>
                                <option value="0x01BE">0x01BE</option>
                                <option value="0x01BF">0x01BF</option>
                            </optgroup>
                            <optgroup label="Grass-Heavy (0x03BF-0x03C6)">
                                <option value="0x03BF">0x03BF</option>
                                <option value="0x03C0">0x03C0</option>
                                <option value="0x03C1">0x03C1</option>
                                <option value="0x03C2">0x03C2</option>
                                <option value="0x03C3">0x03C3</option>
                                <option value="0x03C4">0x03C4</option>
                                <option value="0x03C5">0x03C5</option>
                                <option value="0x03C6">0x03C6</option>
                            </optgroup>
                            <optgroup label="Pure">
                                <option value="0x0016">Pure Sand</option>
                            </optgroup>
                        </select>
                    </div>
                    <div style="background: #2a4a2a; padding: 8px; border-radius: 6px; text-align: center;">
                        <label style="color: #81c784; font-weight: bold; font-size: 12px;">â¬…ï¸ LEFT</label><br>
                        <img id="leftEdgePreview" src="" style="width: 44px; height: 44px; margin: 5px 0; background: #111; border: 1px solid #444;">
                        <select id="leftEdgeSelect" onchange="autoApplyTest()" style="width: 100%; font-size: 11px;">
                            <optgroup label="Basic (0x0033-0x003E)">
                                <option value="0x0033">0x0033</option>
                                <option value="0x0034">0x0034</option>
                                <option value="0x0035">0x0035</option>
                                <option value="0x0036">0x0036</option>
                                <option value="0x0037">0x0037</option>
                                <option value="0x0038" selected>0x0038 âœ“</option>
                                <option value="0x0039">0x0039</option>
                                <option value="0x003A">0x003A</option>
                                <option value="0x003B">0x003B</option>
                                <option value="0x003C">0x003C</option>
                                <option value="0x003D">0x003D</option>
                                <option value="0x003E">0x003E</option>
                            </optgroup>
                            <optgroup label="Extended (0x01A8-0x01BF)">
                                <option value="0x01A8">0x01A8</option>
                                <option value="0x01A9">0x01A9</option>
                                <option value="0x01AA">0x01AA</option>
                                <option value="0x01AB">0x01AB</option>
                                <option value="0x01AC">0x01AC</option>
                                <option value="0x01AD">0x01AD</option>
                                <option value="0x01AE">0x01AE</option>
                                <option value="0x01AF">0x01AF</option>
                                <option value="0x01B0">0x01B0</option>
                                <option value="0x01B1">0x01B1</option>
                                <option value="0x01B2">0x01B2</option>
                                <option value="0x01B3">0x01B3</option>
                                <option value="0x01B4">0x01B4</option>
                                <option value="0x01B5">0x01B5</option>
                                <option value="0x01B6">0x01B6</option>
                                <option value="0x01B7">0x01B7</option>
                                <option value="0x01B8">0x01B8</option>
                                <option value="0x01B9">0x01B9</option>
                                <option value="0x01BA">0x01BA</option>
                                <option value="0x01BB">0x01BB</option>
                                <option value="0x01BC">0x01BC</option>
                                <option value="0x01BD">0x01BD</option>
                                <option value="0x01BE">0x01BE</option>
                                <option value="0x01BF">0x01BF</option>
                            </optgroup>
                            <optgroup label="Grass-Heavy (0x03BF-0x03C6)">
                                <option value="0x03BF">0x03BF</option>
                                <option value="0x03C0">0x03C0</option>
                                <option value="0x03C1">0x03C1</option>
                                <option value="0x03C2">0x03C2</option>
                                <option value="0x03C3">0x03C3</option>
                                <option value="0x03C4">0x03C4</option>
                                <option value="0x03C5">0x03C5</option>
                                <option value="0x03C6">0x03C6</option>
                            </optgroup>
                            <optgroup label="Pure">
                                <option value="0x0016">Pure Sand</option>
                            </optgroup>
                        </select>
                    </div>
                    <div style="background: #4a4a2a; padding: 8px; border-radius: 6px; text-align: center;">
                        <label style="color: #dce775; font-weight: bold; font-size: 12px;">â¡ï¸ RIGHT</label><br>
                        <img id="rightEdgePreview" src="" style="width: 44px; height: 44px; margin: 5px 0; background: #111; border: 1px solid #444;">
                        <select id="rightEdgeSelect" onchange="autoApplyTest()" style="width: 100%; font-size: 11px;">
                            <optgroup label="Basic (0x0033-0x003E)">
                                <option value="0x0033">0x0033</option>
                                <option value="0x0034">0x0034</option>
                                <option value="0x0035">0x0035</option>
                                <option value="0x0036">0x0036</option>
                                <option value="0x0037" selected>0x0037 âœ“</option>
                                <option value="0x0038">0x0038</option>
                                <option value="0x0039">0x0039</option>
                                <option value="0x003A">0x003A</option>
                                <option value="0x003B">0x003B</option>
                                <option value="0x003C">0x003C</option>
                                <option value="0x003D">0x003D</option>
                                <option value="0x003E">0x003E</option>
                            </optgroup>
                            <optgroup label="Extended (0x01A8-0x01BF)">
                                <option value="0x01A8">0x01A8</option>
                                <option value="0x01A9">0x01A9</option>
                                <option value="0x01AA">0x01AA</option>
                                <option value="0x01AB">0x01AB</option>
                                <option value="0x01AC">0x01AC</option>
                                <option value="0x01AD">0x01AD</option>
                                <option value="0x01AE">0x01AE</option>
                                <option value="0x01AF">0x01AF</option>
                                <option value="0x01B0">0x01B0</option>
                                <option value="0x01B1">0x01B1</option>
                                <option value="0x01B2">0x01B2</option>
                                <option value="0x01B3">0x01B3</option>
                                <option value="0x01B4">0x01B4</option>
                                <option value="0x01B5">0x01B5</option>
                                <option value="0x01B6">0x01B6</option>
                                <option value="0x01B7">0x01B7</option>
                                <option value="0x01B8">0x01B8</option>
                                <option value="0x01B9">0x01B9</option>
                                <option value="0x01BA">0x01BA</option>
                                <option value="0x01BB">0x01BB</option>
                                <option value="0x01BC">0x01BC</option>
                                <option value="0x01BD">0x01BD</option>
                                <option value="0x01BE">0x01BE</option>
                                <option value="0x01BF">0x01BF</option>
                            </optgroup>
                            <optgroup label="Grass-Heavy (0x03BF-0x03C6)">
                                <option value="0x03BF">0x03BF</option>
                                <option value="0x03C0">0x03C0</option>
                                <option value="0x03C1">0x03C1</option>
                                <option value="0x03C2">0x03C2</option>
                                <option value="0x03C3">0x03C3</option>
                                <option value="0x03C4">0x03C4</option>
                                <option value="0x03C5">0x03C5</option>
                                <option value="0x03C6">0x03C6</option>
                            </optgroup>
                            <optgroup label="Pure">
                                <option value="0x0016">Pure Sand</option>
                            </optgroup>
                        </select>
                    </div>
                </div>
                
                <!-- CORNERS Section -->
                <h5 style="color: #ce93d8; margin: 15px 0 5px 0;">ğŸ”· CORNERS (grass on TWO adjacent sides)</h5>
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px;">
                    <div style="background: #3a2a4a; padding: 8px; border-radius: 6px; text-align: center;">
                        <label style="color: #b39ddb; font-weight: bold; font-size: 12px;">â†–ï¸ TOP-LEFT</label><br>
                        <img id="topLeftCornerPreview" src="" style="width: 44px; height: 44px; margin: 5px 0; background: #111; border: 1px solid #444;">
                        <select id="topLeftCornerSelect" onchange="autoApplyTest()" style="width: 100%; font-size: 11px;">
                            <optgroup label="Basic (0x0033-0x003E)">
                                <option value="0x0033">0x0033</option>
                                <option value="0x0034">0x0034</option>
                                <option value="0x0035">0x0035</option>
                                <option value="0x0036">0x0036</option>
                                <option value="0x0037">0x0037</option>
                                <option value="0x0038">0x0038</option>
                                <option value="0x0039">0x0039</option>
                                <option value="0x003A">0x003A</option>
                                <option value="0x003B">0x003B</option>
                                <option value="0x003C">0x003C</option>
                                <option value="0x003D" selected>0x003D âœ“</option>
                                <option value="0x003E">0x003E</option>
                            </optgroup>
                            <optgroup label="Extended (0x01A8-0x01BF)">
                                <option value="0x01A8">0x01A8</option>
                                <option value="0x01A9">0x01A9</option>
                                <option value="0x01AA">0x01AA</option>
                                <option value="0x01AB">0x01AB</option>
                                <option value="0x01AC">0x01AC</option>
                                <option value="0x01AD">0x01AD</option>
                                <option value="0x01AE">0x01AE</option>
                                <option value="0x01AF">0x01AF</option>
                                <option value="0x01B0">0x01B0</option>
                                <option value="0x01B1">0x01B1</option>
                                <option value="0x01B2">0x01B2</option>
                                <option value="0x01B3">0x01B3</option>
                                <option value="0x01B4">0x01B4</option>
                                <option value="0x01B5">0x01B5</option>
                                <option value="0x01B6">0x01B6</option>
                                <option value="0x01B7">0x01B7</option>
                                <option value="0x01B8">0x01B8</option>
                                <option value="0x01B9">0x01B9</option>
                                <option value="0x01BA">0x01BA</option>
                                <option value="0x01BB">0x01BB</option>
                                <option value="0x01BC">0x01BC</option>
                                <option value="0x01BD">0x01BD</option>
                                <option value="0x01BE">0x01BE</option>
                                <option value="0x01BF">0x01BF</option>
                            </optgroup>
                            <optgroup label="Grass-Heavy Corners (0x03BF-0x03C6)">
                                <option value="0x03BF">0x03BF</option>
                                <option value="0x03C0">0x03C0</option>
                                <option value="0x03C1">0x03C1</option>
                                <option value="0x03C2">0x03C2</option>
                                <option value="0x03C3">0x03C3</option>
                                <option value="0x03C4">0x03C4</option>
                                <option value="0x03C5">0x03C5</option>
                                <option value="0x03C6">0x03C6</option>
                            </optgroup>
                            <optgroup label="Pure">
                                <option value="0x0016">Pure Sand</option>
                            </optgroup>
                        </select>
                    </div>
                    <div style="background: #4a2a3a; padding: 8px; border-radius: 6px; text-align: center;">
                        <label style="color: #f48fb1; font-weight: bold; font-size: 12px;">â†—ï¸ TOP-RIGHT</label><br>
                        <img id="topRightCornerPreview" src="" style="width: 44px; height: 44px; margin: 5px 0; background: #111; border: 1px solid #444;">
                        <select id="topRightCornerSelect" onchange="autoApplyTest()" style="width: 100%; font-size: 11px;">
                            <optgroup label="Basic (0x0033-0x003E)">
                                <option value="0x0033">0x0033</option>
                                <option value="0x0034">0x0034</option>
                                <option value="0x0035">0x0035</option>
                                <option value="0x0036">0x0036</option>
                                <option value="0x0037">0x0037</option>
                                <option value="0x0038">0x0038</option>
                                <option value="0x0039">0x0039</option>
                                <option value="0x003A">0x003A</option>
                                <option value="0x003B">0x003B</option>
                                <option value="0x003C" selected>0x003C âœ“</option>
                                <option value="0x003D">0x003D</option>
                                <option value="0x003E">0x003E</option>
                            </optgroup>
                            <optgroup label="Extended (0x01A8-0x01BF)">
                                <option value="0x01A8">0x01A8</option>
                                <option value="0x01A9">0x01A9</option>
                                <option value="0x01AA">0x01AA</option>
                                <option value="0x01AB">0x01AB</option>
                                <option value="0x01AC">0x01AC</option>
                                <option value="0x01AD">0x01AD</option>
                                <option value="0x01AE">0x01AE</option>
                                <option value="0x01AF">0x01AF</option>
                                <option value="0x01B0">0x01B0</option>
                                <option value="0x01B1">0x01B1</option>
                                <option value="0x01B2">0x01B2</option>
                                <option value="0x01B3">0x01B3</option>
                                <option value="0x01B4">0x01B4</option>
                                <option value="0x01B5">0x01B5</option>
                                <option value="0x01B6">0x01B6</option>
                                <option value="0x01B7">0x01B7</option>
                                <option value="0x01B8">0x01B8</option>
                                <option value="0x01B9">0x01B9</option>
                                <option value="0x01BA">0x01BA</option>
                                <option value="0x01BB">0x01BB</option>
                                <option value="0x01BC">0x01BC</option>
                                <option value="0x01BD">0x01BD</option>
                                <option value="0x01BE">0x01BE</option>
                                <option value="0x01BF">0x01BF</option>
                            </optgroup>
                            <optgroup label="Grass-Heavy Corners (0x03BF-0x03C6)">
                                <option value="0x03BF">0x03BF</option>
                                <option value="0x03C0">0x03C0</option>
                                <option value="0x03C1">0x03C1</option>
                                <option value="0x03C2">0x03C2</option>
                                <option value="0x03C3">0x03C3</option>
                                <option value="0x03C4">0x03C4</option>
                                <option value="0x03C5">0x03C5</option>
                                <option value="0x03C6">0x03C6</option>
                            </optgroup>
                            <optgroup label="Pure">
                                <option value="0x0016">Pure Sand</option>
                            </optgroup>
                        </select>
                    </div>
                    <div style="background: #2a3a3a; padding: 8px; border-radius: 6px; text-align: center;">
                        <label style="color: #80cbc4; font-weight: bold; font-size: 12px;">â†™ï¸ BOTTOM-LEFT</label><br>
                        <img id="bottomLeftCornerPreview" src="" style="width: 44px; height: 44px; margin: 5px 0; background: #111; border: 1px solid #444;">
                        <select id="bottomLeftCornerSelect" onchange="autoApplyTest()" style="width: 100%; font-size: 11px;">
                            <optgroup label="Basic (0x0033-0x003E)">
                                <option value="0x0033">0x0033</option>
                                <option value="0x0034">0x0034</option>
                                <option value="0x0035">0x0035</option>
                                <option value="0x0036">0x0036</option>
                                <option value="0x0037">0x0037</option>
                                <option value="0x0038">0x0038</option>
                                <option value="0x0039">0x0039</option>
                                <option value="0x003A">0x003A</option>
                                <option value="0x003B" selected>0x003B âœ“</option>
                                <option value="0x003C">0x003C</option>
                                <option value="0x003D">0x003D</option>
                                <option value="0x003E">0x003E</option>
                            </optgroup>
                            <optgroup label="Extended (0x01A8-0x01BF)">
                                <option value="0x01A8">0x01A8</option>
                                <option value="0x01A9">0x01A9</option>
                                <option value="0x01AA">0x01AA</option>
                                <option value="0x01AB">0x01AB</option>
                                <option value="0x01AC">0x01AC</option>
                                <option value="0x01AD">0x01AD</option>
                                <option value="0x01AE">0x01AE</option>
                                <option value="0x01AF">0x01AF</option>
                                <option value="0x01B0">0x01B0</option>
                                <option value="0x01B1">0x01B1</option>
                                <option value="0x01B2">0x01B2</option>
                                <option value="0x01B3">0x01B3</option>
                                <option value="0x01B4">0x01B4</option>
                                <option value="0x01B5">0x01B5</option>
                                <option value="0x01B6">0x01B6</option>
                                <option value="0x01B7">0x01B7</option>
                                <option value="0x01B8">0x01B8</option>
                                <option value="0x01B9">0x01B9</option>
                                <option value="0x01BA">0x01BA</option>
                                <option value="0x01BB">0x01BB</option>
                                <option value="0x01BC">0x01BC</option>
                                <option value="0x01BD">0x01BD</option>
                                <option value="0x01BE">0x01BE</option>
                                <option value="0x01BF">0x01BF</option>
                            </optgroup>
                            <optgroup label="Grass-Heavy Corners (0x03BF-0x03C6)">
                                <option value="0x03BF">0x03BF</option>
                                <option value="0x03C0">0x03C0</option>
                                <option value="0x03C1">0x03C1</option>
                                <option value="0x03C2">0x03C2</option>
                                <option value="0x03C3">0x03C3</option>
                                <option value="0x03C4">0x03C4</option>
                                <option value="0x03C5">0x03C5</option>
                                <option value="0x03C6">0x03C6</option>
                            </optgroup>
                            <optgroup label="Pure">
                                <option value="0x0016">Pure Sand</option>
                            </optgroup>
                        </select>
                    </div>
                    <div style="background: #3a3a2a; padding: 8px; border-radius: 6px; text-align: center;">
                        <label style="color: #fff59d; font-weight: bold; font-size: 12px;">â†˜ï¸ BOTTOM-RIGHT</label><br>
                        <img id="bottomRightCornerPreview" src="" style="width: 44px; height: 44px; margin: 5px 0; background: #111; border: 1px solid #444;">
                        <select id="bottomRightCornerSelect" onchange="autoApplyTest()" style="width: 100%; font-size: 11px;">
                            <optgroup label="Basic (0x0033-0x003E)">
                                <option value="0x0033">0x0033</option>
                                <option value="0x0034">0x0034</option>
                                <option value="0x0035">0x0035</option>
                                <option value="0x0036">0x0036</option>
                                <option value="0x0037">0x0037</option>
                                <option value="0x0038">0x0038</option>
                                <option value="0x0039">0x0039</option>
                                <option value="0x003A">0x003A</option>
                                <option value="0x003B">0x003B</option>
                                <option value="0x003C">0x003C</option>
                                <option value="0x003D">0x003D</option>
                                <option value="0x003E" selected>0x003E âœ“</option>
                            </optgroup>
                            <optgroup label="Extended (0x01A8-0x01BF)">
                                <option value="0x01A8">0x01A8</option>
                                <option value="0x01A9">0x01A9</option>
                                <option value="0x01AA">0x01AA</option>
                                <option value="0x01AB">0x01AB</option>
                                <option value="0x01AC">0x01AC</option>
                                <option value="0x01AD">0x01AD</option>
                                <option value="0x01AE">0x01AE</option>
                                <option value="0x01AF">0x01AF</option>
                                <option value="0x01B0">0x01B0</option>
                                <option value="0x01B1">0x01B1</option>
                                <option value="0x01B2">0x01B2</option>
                                <option value="0x01B3">0x01B3</option>
                                <option value="0x01B4">0x01B4</option>
                                <option value="0x01B5">0x01B5</option>
                                <option value="0x01B6">0x01B6</option>
                                <option value="0x01B7">0x01B7</option>
                                <option value="0x01B8">0x01B8</option>
                                <option value="0x01B9">0x01B9</option>
                                <option value="0x01BA">0x01BA</option>
                                <option value="0x01BB">0x01BB</option>
                                <option value="0x01BC">0x01BC</option>
                                <option value="0x01BD">0x01BD</option>
                                <option value="0x01BE">0x01BE</option>
                                <option value="0x01BF">0x01BF</option>
                            </optgroup>
                            <optgroup label="Grass-Heavy Corners (0x03BF-0x03C6)">
                                <option value="0x03BF">0x03BF</option>
                                <option value="0x03C0">0x03C0</option>
                                <option value="0x03C1">0x03C1</option>
                                <option value="0x03C2">0x03C2</option>
                                <option value="0x03C3">0x03C3</option>
                                <option value="0x03C4">0x03C4</option>
                                <option value="0x03C5">0x03C5</option>
                                <option value="0x03C6">0x03C6</option>
                            </optgroup>
                            <optgroup label="Pure">
                                <option value="0x0016">Pure Sand</option>
                            </optgroup>
                        </select>
                    </div>
                </div>
                
                <!-- INNER CORNERS Section (grass on THREE sides, sand only in one corner) -->
                <h5 style="color: #ffab91; margin: 15px 0 5px 0;">ğŸ”¶ INNER CORNERS (grass on THREE sides - sand only in one corner)</h5>
                <p style="font-size: 11px; color: #888; margin: 0 0 10px 0;">These tiles are mostly grass with just a small sand corner. Used when sand is surrounded by grass on 3 sides.</p>
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px;">
                    <div style="background: #4a3a2a; padding: 8px; border-radius: 6px; text-align: center;">
                        <label style="color: #ffcc80; font-weight: bold; font-size: 12px;">â—¤ INNER TL</label><br>
                        <span style="font-size: 9px; color: #888;">Sand in TOP-LEFT only</span><br>
                        <img id="innerTopLeftPreview" src="" style="width: 44px; height: 44px; margin: 5px 0; background: #111; border: 1px solid #444;">
                        <select id="innerTopLeftSelect" onchange="autoApplyInnerCorners()" style="width: 100%; font-size: 11px;">
                            <optgroup label="Likely Inner Corners">
                                <option value="0x0033" selected>0x0033</option>
                                <option value="0x0034">0x0034</option>
                                <option value="0x0035">0x0035</option>
                                <option value="0x0036">0x0036</option>
                            </optgroup>
                            <optgroup label="Other Options">
                                <option value="0x0037">0x0037</option>
                                <option value="0x0038">0x0038</option>
                                <option value="0x0039">0x0039</option>
                                <option value="0x003A">0x003A</option>
                                <option value="0x003B">0x003B</option>
                                <option value="0x003C">0x003C</option>
                                <option value="0x003D">0x003D</option>
                                <option value="0x003E">0x003E</option>
                            </optgroup>
                            <optgroup label="Pure">
                                <option value="0x0003">Pure Grass</option>
                            </optgroup>
                        </select>
                    </div>
                    <div style="background: #4a3a2a; padding: 8px; border-radius: 6px; text-align: center;">
                        <label style="color: #ffcc80; font-weight: bold; font-size: 12px;">â—¥ INNER TR</label><br>
                        <span style="font-size: 9px; color: #888;">Sand in TOP-RIGHT only</span><br>
                        <img id="innerTopRightPreview" src="" style="width: 44px; height: 44px; margin: 5px 0; background: #111; border: 1px solid #444;">
                        <select id="innerTopRightSelect" onchange="autoApplyInnerCorners()" style="width: 100%; font-size: 11px;">
                            <optgroup label="Likely Inner Corners">
                                <option value="0x0033">0x0033</option>
                                <option value="0x0034" selected>0x0034</option>
                                <option value="0x0035">0x0035</option>
                                <option value="0x0036">0x0036</option>
                            </optgroup>
                            <optgroup label="Other Options">
                                <option value="0x0037">0x0037</option>
                                <option value="0x0038">0x0038</option>
                                <option value="0x0039">0x0039</option>
                                <option value="0x003A">0x003A</option>
                                <option value="0x003B">0x003B</option>
                                <option value="0x003C">0x003C</option>
                                <option value="0x003D">0x003D</option>
                                <option value="0x003E">0x003E</option>
                            </optgroup>
                            <optgroup label="Pure">
                                <option value="0x0003">Pure Grass</option>
                            </optgroup>
                        </select>
                    </div>
                    <div style="background: #4a3a2a; padding: 8px; border-radius: 6px; text-align: center;">
                        <label style="color: #ffcc80; font-weight: bold; font-size: 12px;">â—£ INNER BL</label><br>
                        <span style="font-size: 9px; color: #888;">Sand in BOTTOM-LEFT only</span><br>
                        <img id="innerBottomLeftPreview" src="" style="width: 44px; height: 44px; margin: 5px 0; background: #111; border: 1px solid #444;">
                        <select id="innerBottomLeftSelect" onchange="autoApplyInnerCorners()" style="width: 100%; font-size: 11px;">
                            <optgroup label="Likely Inner Corners">
                                <option value="0x0033">0x0033</option>
                                <option value="0x0034">0x0034</option>
                                <option value="0x0035" selected>0x0035</option>
                                <option value="0x0036">0x0036</option>
                            </optgroup>
                            <optgroup label="Other Options">
                                <option value="0x0037">0x0037</option>
                                <option value="0x0038">0x0038</option>
                                <option value="0x0039">0x0039</option>
                                <option value="0x003A">0x003A</option>
                                <option value="0x003B">0x003B</option>
                                <option value="0x003C">0x003C</option>
                                <option value="0x003D">0x003D</option>
                                <option value="0x003E">0x003E</option>
                            </optgroup>
                            <optgroup label="Pure">
                                <option value="0x0003">Pure Grass</option>
                            </optgroup>
                        </select>
                    </div>
                    <div style="background: #4a3a2a; padding: 8px; border-radius: 6px; text-align: center;">
                        <label style="color: #ffcc80; font-weight: bold; font-size: 12px;">â—¢ INNER BR</label><br>
                        <span style="font-size: 9px; color: #888;">Sand in BOTTOM-RIGHT only</span><br>
                        <img id="innerBottomRightPreview" src="" style="width: 44px; height: 44px; margin: 5px 0; background: #111; border: 1px solid #444;">
                        <select id="innerBottomRightSelect" onchange="autoApplyInnerCorners()" style="width: 100%; font-size: 11px;">
                            <optgroup label="Likely Inner Corners">
                                <option value="0x0033">0x0033</option>
                                <option value="0x0034">0x0034</option>
                                <option value="0x0035">0x0035</option>
                                <option value="0x0036" selected>0x0036</option>
                            </optgroup>
                            <optgroup label="Other Options">
                                <option value="0x0037">0x0037</option>
                                <option value="0x0038">0x0038</option>
                                <option value="0x0039">0x0039</option>
                                <option value="0x003A">0x003A</option>
                                <option value="0x003B">0x003B</option>
                                <option value="0x003C">0x003C</option>
                                <option value="0x003D">0x003D</option>
                                <option value="0x003E">0x003E</option>
                            </optgroup>
                            <optgroup label="Pure">
                                <option value="0x0003">Pure Grass</option>
                            </optgroup>
                        </select>
                    </div>
                </div>
                <div style="margin-top: 10px;">
                    <button onclick="testInnerCorners()" style="background: #ff7043; font-size: 14px; padding: 8px 16px;">ğŸ”¶ Test Inner Corners</button>
                </div>
                
                <!-- DIAGONAL TRANSITION TESTER -->
                <h5 style="color: #b39ddb; margin: 20px 0 5px 0;">â†—ï¸ DIAGONAL TRANSITION TESTER</h5>
                <p style="font-size: 11px; color: #888; margin: 0 0 10px 0;">Use these dropdowns to find the correct tiles for diagonal edges. Select tiles and click Test to see how they look.</p>
                
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 10px;">
                    <!-- Diagonal Row 1 - Sand tiles going into grass diagonally -->
                    <div style="background: #3a3a4a; padding: 10px; border-radius: 6px; text-align: center;">
                        <label style="color: #ce93d8; font-weight: bold; font-size: 12px;">â†—ï¸ DIAG 1</label><br>
                        <span style="font-size: 9px; color: #888;">First diagonal tile</span><br>
                        <img id="diag1Preview" src="" style="width: 44px; height: 44px; margin: 5px 0; background: #111; border: 1px solid #444;">
                        <select id="diag1Select" onchange="autoApplyDiagonal()" style="width: 100%; font-size: 11px;">
                            <optgroup label="Edge Tiles">
                                <option value="0x0037">0x0037 (RIGHT)</option>
                                <option value="0x0038">0x0038 (LEFT)</option>
                                <option value="0x0039">0x0039 (BOTTOM)</option>
                                <option value="0x003A">0x003A (TOP)</option>
                            </optgroup>
                            <optgroup label="Corner Tiles">
                                <option value="0x003B">0x003B</option>
                                <option value="0x003C" selected>0x003C</option>
                                <option value="0x003D">0x003D</option>
                                <option value="0x003E">0x003E</option>
                            </optgroup>
                            <optgroup label="Other Sand">
                                <option value="0x0033">0x0033</option>
                                <option value="0x0034">0x0034</option>
                                <option value="0x0035">0x0035</option>
                                <option value="0x0036">0x0036</option>
                                <option value="0x0016">Pure Sand</option>
                            </optgroup>
                        </select>
                    </div>
                    <div style="background: #3a3a4a; padding: 10px; border-radius: 6px; text-align: center;">
                        <label style="color: #ce93d8; font-weight: bold; font-size: 12px;">â†—ï¸ DIAG 2</label><br>
                        <span style="font-size: 9px; color: #888;">Second diagonal tile</span><br>
                        <img id="diag2Preview" src="" style="width: 44px; height: 44px; margin: 5px 0; background: #111; border: 1px solid #444;">
                        <select id="diag2Select" onchange="autoApplyDiagonal()" style="width: 100%; font-size: 11px;">
                            <optgroup label="Edge Tiles">
                                <option value="0x0037">0x0037 (RIGHT)</option>
                                <option value="0x0038">0x0038 (LEFT)</option>
                                <option value="0x0039">0x0039 (BOTTOM)</option>
                                <option value="0x003A" selected>0x003A (TOP)</option>
                            </optgroup>
                            <optgroup label="Corner Tiles">
                                <option value="0x003B">0x003B</option>
                                <option value="0x003C">0x003C</option>
                                <option value="0x003D">0x003D</option>
                                <option value="0x003E">0x003E</option>
                            </optgroup>
                            <optgroup label="Other Sand">
                                <option value="0x0033">0x0033</option>
                                <option value="0x0034">0x0034</option>
                                <option value="0x0035">0x0035</option>
                                <option value="0x0036">0x0036</option>
                                <option value="0x0016">Pure Sand</option>
                            </optgroup>
                        </select>
                    </div>
                    <div style="background: #3a3a4a; padding: 10px; border-radius: 6px; text-align: center;">
                        <label style="color: #ce93d8; font-weight: bold; font-size: 12px;">â†—ï¸ DIAG 3</label><br>
                        <span style="font-size: 9px; color: #888;">Third diagonal tile</span><br>
                        <img id="diag3Preview" src="" style="width: 44px; height: 44px; margin: 5px 0; background: #111; border: 1px solid #444;">
                        <select id="diag3Select" onchange="autoApplyDiagonal()" style="width: 100%; font-size: 11px;">
                            <optgroup label="Edge Tiles">
                                <option value="0x0037" selected>0x0037 (RIGHT)</option>
                                <option value="0x0038">0x0038 (LEFT)</option>
                                <option value="0x0039">0x0039 (BOTTOM)</option>
                                <option value="0x003A">0x003A (TOP)</option>
                            </optgroup>
                            <optgroup label="Corner Tiles">
                                <option value="0x003B">0x003B</option>
                                <option value="0x003C">0x003C</option>
                                <option value="0x003D">0x003D</option>
                                <option value="0x003E">0x003E</option>
                            </optgroup>
                            <optgroup label="Other Sand">
                                <option value="0x0033">0x0033</option>
                                <option value="0x0034">0x0034</option>
                                <option value="0x0035">0x0035</option>
                                <option value="0x0036">0x0036</option>
                                <option value="0x0016">Pure Sand</option>
                            </optgroup>
                        </select>
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button onclick="testDiagonalWithDropdowns()" style="background: #9c27b0; font-size: 14px; padding: 8px 16px;">â†—ï¸ Test Diagonal Pattern</button>
                    <button onclick="reverseDiagonal()" style="background: #673ab7; font-size: 12px; padding: 6px 12px;">ğŸ”„ Reverse Direction</button>
                </div>
                
                <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                    <button onclick="testAllEdgesAndCorners()" style="background: #ff9800; font-size: 14px; padding: 8px 16px;">ğŸ”¬ Test ALL (Edges + Corners)</button>
                    <button onclick="showAllTransitions()" style="background: #e91e63;">ğŸ“Š Show All Tiles</button>
                    <button onclick="saveMappings()" style="background: #4caf50;">ğŸ’¾ Save Mappings</button>
                </div>
                
                <div style="margin-top: 10px; padding: 10px; background: #222; border-radius: 4px; font-size: 12px;">
                    <strong>âœ… CONFIRMED MAPPINGS (Saved to Code!):</strong><br>
                    <strong>EDGES:</strong> <span style="color: #64b5f6;">TOP: 0x003A</span> | 
                    <span style="color: #ffb74d;">BOTTOM: 0x0039</span> | 
                    <span style="color: #81c784;">LEFT: 0x0038</span> | 
                    <span style="color: #dce775;">RIGHT: 0x0037</span><br>
                    <strong>OUTER CORNERS:</strong> <span style="color: #b39ddb;">TL: 0x003D</span> | 
                    <span style="color: #f48fb1;">TR: 0x003C</span> | 
                    <span style="color: #80cbc4;">BL: 0x003B</span> | 
                    <span style="color: #fff59d;">BR: 0x003E</span><br>
                    <strong>INNER CORNERS:</strong> <span style="color: #ce93d8;">TL: 0x003E</span> | 
                    <span style="color: #f48fb1;">TR: 0x003B</span> | 
                    <span style="color: #80deea;">BL: 0x003C</span> | 
                    <span style="color: #a5d6a7;">BR: 0x003D</span>
                </div>
                
                <!-- NEIGHBOR CONFIGURATION TESTER - For debugging transition logic -->
                <div style="background: #2a2a4a; padding: 15px; border-radius: 8px; margin-top: 15px; border: 2px solid #ff5722;">
                    <h5 style="color: #ff5722; margin: 0 0 10px 0;">ğŸ”§ NEIGHBOR CONFIGURATION TESTER</h5>
                    <p style="font-size: 11px; color: #aaa; margin: 0 0 10px 0;">
                        Check which neighbors are GRASS, see what tile the code picks, and tell me what it SHOULD be.
                    </p>
                    
                    <!-- 3x3 Grid for neighbor selection -->
                    <div style="display: grid; grid-template-columns: repeat(3, 70px); gap: 5px; justify-content: center; margin-bottom: 15px;">
                        <!-- Top row -->
                        <label style="background: #333; padding: 8px; border-radius: 4px; text-align: center; cursor: pointer;">
                            <input type="checkbox" id="nbr_tl" onchange="updateNeighborTest()"> 
                            <span style="color: #81c784; font-size: 10px;">â†–TL</span>
                        </label>
                        <label style="background: #333; padding: 8px; border-radius: 4px; text-align: center; cursor: pointer;">
                            <input type="checkbox" id="nbr_t" onchange="updateNeighborTest()"> 
                            <span style="color: #4fc3f7; font-size: 10px;">â¬†TOP</span>
                        </label>
                        <label style="background: #333; padding: 8px; border-radius: 4px; text-align: center; cursor: pointer;">
                            <input type="checkbox" id="nbr_tr" onchange="updateNeighborTest()"> 
                            <span style="color: #81c784; font-size: 10px;">â†—TR</span>
                        </label>
                        
                        <!-- Middle row -->
                        <label style="background: #333; padding: 8px; border-radius: 4px; text-align: center; cursor: pointer;">
                            <input type="checkbox" id="nbr_l" onchange="updateNeighborTest()"> 
                            <span style="color: #4fc3f7; font-size: 10px;">â¬…LEFT</span>
                        </label>
                        <div style="background: #ffb74d; padding: 8px; border-radius: 4px; text-align: center;">
                            <span style="color: #333; font-size: 10px; font-weight: bold;">SAND<br>TILE</span>
                        </div>
                        <label style="background: #333; padding: 8px; border-radius: 4px; text-align: center; cursor: pointer;">
                            <input type="checkbox" id="nbr_r" onchange="updateNeighborTest()"> 
                            <span style="color: #4fc3f7; font-size: 10px;">RIGHTâ¡</span>
                        </label>
                        
                        <!-- Bottom row -->
                        <label style="background: #333; padding: 8px; border-radius: 4px; text-align: center; cursor: pointer;">
                            <input type="checkbox" id="nbr_bl" onchange="updateNeighborTest()"> 
                            <span style="color: #81c784; font-size: 10px;">â†™BL</span>
                        </label>
                        <label style="background: #333; padding: 8px; border-radius: 4px; text-align: center; cursor: pointer;">
                            <input type="checkbox" id="nbr_b" onchange="updateNeighborTest()"> 
                            <span style="color: #4fc3f7; font-size: 10px;">â¬‡BOT</span>
                        </label>
                        <label style="background: #333; padding: 8px; border-radius: 4px; text-align: center; cursor: pointer;">
                            <input type="checkbox" id="nbr_br" onchange="updateNeighborTest()"> 
                            <span style="color: #81c784; font-size: 10px;">â†˜BR</span>
                        </label>
                    </div>
                    
                    <!-- Results -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div style="background: #1a1a2e; padding: 10px; border-radius: 6px;">
                            <div style="color: #f44336; font-weight: bold; margin-bottom: 5px;">âŒ CODE PICKS:</div>
                            <img id="codePicksPreview" src="" style="width: 44px; height: 44px; background: #111; border: 1px solid #444;">
                            <div id="codePicksId" style="color: #fff; font-family: monospace; margin-top: 5px;">-</div>
                            <div id="codePicksBitmask" style="color: #888; font-size: 10px;">Bitmask: -</div>
                        </div>
                        <div style="background: #1a2e1a; padding: 10px; border-radius: 6px;">
                            <div style="color: #4caf50; font-weight: bold; margin-bottom: 5px;">âœ… SHOULD BE:</div>
                            <img id="shouldBePreview" src="" style="width: 44px; height: 44px; background: #111; border: 1px solid #444;">
                            <select id="shouldBeSelect" onchange="updateShouldBePreview()" style="width: 100%; margin-top: 5px;">
                                <option value="">-- Select correct tile --</option>
                                <option value="0x0003">Pure Grass (0x0003)</option>
                                <option value="0x0016">Pure Sand (0x0016)</option>
                                <optgroup label="Edges (0x0037-0x003A)">
                                    <option value="0x0037">0x0037 - RIGHT edge</option>
                                    <option value="0x0038">0x0038 - LEFT edge</option>
                                    <option value="0x0039">0x0039 - BOTTOM edge</option>
                                    <option value="0x003A">0x003A - TOP edge</option>
                                </optgroup>
                                <optgroup label="Outer Corners (0x003B-0x003E)">
                                    <option value="0x003B">0x003B - BL corner</option>
                                    <option value="0x003C">0x003C - TR corner</option>
                                    <option value="0x003D">0x003D - TL corner</option>
                                    <option value="0x003E">0x003E - BR corner</option>
                                </optgroup>
                                <optgroup label="Inner Corners (0x0033-0x0036)">
                                    <option value="0x0033">0x0033 - Inner TL</option>
                                    <option value="0x0034">0x0034 - Inner TR</option>
                                    <option value="0x0035">0x0035 - Inner BL</option>
                                    <option value="0x0036">0x0036 - Inner BR</option>
                                </optgroup>
                            </select>
                        </div>
                    </div>
                    
                    <div style="margin-top: 10px;">
                        <button onclick="renderNeighborTest()" style="background: #ff5722;">ğŸ¨ Render This Config</button>
                        <button onclick="logCorrection()" style="background: #4caf50;">ğŸ“‹ Log Correction</button>
                        <button onclick="clearNeighborTest()" style="background: #666;">ğŸ—‘ï¸ Clear All</button>
                    </div>
                    
                    <!-- Logged corrections -->
                    <div id="correctionLog" style="background: #111; padding: 10px; border-radius: 4px; margin-top: 10px; max-height: 150px; overflow-y: auto; font-family: monospace; font-size: 11px; color: #0f0;">
                        // Corrections will appear here...
                    </div>
                </div>
            </div>
            </div>
        </details>
        
        <!-- Hidden duplicate elements removed - canvas/viewport/legend now at top -->
        <div class="info" style="display: none;">
            <div class="biome-legend">
                <span class="biome-item grass">ğŸŒ± Grass</span>
                <span class="biome-item sand">ğŸ–ï¸ Sand</span>
                <span class="biome-item dirt">ğŸŸ¤ Dirt</span>
                <span class="biome-item water">ğŸ’§ Water</span>
                <span class="biome-item forest">ğŸŒ² Forest</span>
                <span class="biome-item jungle">ğŸŒ´ Jungle</span>
                <span class="biome-item furrows">ğŸŒ¾ Furrows</span>
            </div>
            <p id="status">Click "Generate Terrain" to start!</p>
        </div>
        </div>
        <!-- END SIDEBAR -->

        <!-- MAP AREA -->
        <div class="map-area">
            <div id="canvasContainer">
                <canvas id="canvas" width="500" height="500"></canvas>
            </div>
        </div>
        <!-- END MAP AREA -->
    </div>
    <!-- END MAIN LAYOUT -->

    <script type="module">
        import { LandTileLoader } from './js/modules/landTileLoader.js';
        import { TerrainGenerator } from './js/modules/terrainGenerator.js';
        import { TerrainGeneratorV2 } from './js/modules/terrainGeneratorV2.js?v=20251130_fixed_v3'; // Bump version
        import { WebGLTerrainRenderer } from './js/modules/webglTerrainRenderer.js?v=camerafollow1';
        import { initializeDynamicSets } from './js/data/uoTileSetsClean.js';
        import { UOMapLoader } from './js/modules/uoMapLoader.js';
        import { UOStaticLoader } from './js/modules/uoStaticLoader.js';
        import { UOArtLoader } from './js/modules/uoArtLoader.js';
        import { Character } from './js/modules/character.js';
        import { BiomeStaticPlacer } from './js/modules/biomeStaticPlacer.js';
        import { UOItemLoader } from './js/modules/uoItemLoader.js';

        console.log('[OK] Modules imported successfully');
        
        // Global art loader for static graphics
        let artLoader = null;
        
        // WebGL renderer instance (created on first use)
        let webglRenderer = null;
        console.log('LandTileLoader:', typeof LandTileLoader);
        console.log('TerrainGenerator:', typeof TerrainGenerator);
        console.log('TerrainGeneratorV2:', typeof TerrainGeneratorV2);
        
        // V2 generator (uses proper tile sets)
        let terrainGeneratorV2 = new TerrainGeneratorV2();
        
        // UO Map Loader for real map data
        let uoMapLoader = new UOMapLoader();

        let terrainGenerator = null;
        
        // Global storage for collision detection
        let landTileData = new Map(); // tileId (number) -> tile properties from LandData.csv
        let currentStatics = []; // Array of static objects (from map or procedural)
        let currentMap = null;
        let currentCornerHeights = null; // Store corner heights for re-rendering
        
        // Player character (reuses PvP Character class!)
        let playerCharacter = null;
        let characterSprites = {}; // { direction: canvas }
        let itemLoader = null; // For loading static BMP graphics
        
        let tileImages = {}; // Cache for processed tile images (with transparent corners)
        let showTileIds = false; // Toggle for showing tile IDs on map
        let enableZHeight = false; // Toggle for UO-style Z-height rendering (3D effect) - disabled by default because proper UO rendering requires texture stretching over triangles
        
        // Viewport state
        let viewportZoom = 1.0; // Default zoom level
        let viewportX = 0;
        let viewportY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let terrainBounds = { minX: 0, minY: 0, maxX: 0, maxY: 0 };
        
        // Camera Follow state
        let cameraZoom = 0.7;  // Start zoomed out for wider view (classic UO style)
        const MIN_ZOOM = 0.5;
        const MAX_ZOOM = 3.0;
        const ZOOM_STEP = 0.1;
        
        // Mouse interaction state
        let scrollStartX = 0;
        let scrollStartY = 0;
        let lastClickTime = 0;
        let clickStartX = 0;
        let clickStartY = 0;
        let rightMouseDown = false;

        // Biome colors for visualization (fallback if images fail to load)
        const biomeColors = {
            grass: '#228b22',
            sand: '#daa520',
            dirt: '#8b4513',
            water: '#1e90ff',
            forest: '#2d5016',
            jungle: '#1b4d1b',
            furrows: '#654321'
        };

        // DEBUG: Check corner pixel values to diagnose tessellation issues
        function debugTileCorners(tileId) {
            const img = new Image();
            img.onload = function() {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                
                const imageData = ctx.getImageData(0, 0, img.width, img.height);
                const data = imageData.data;
                const w = img.width, h = img.height;
                
                // Check the 4 corner pixels and edge centers
                const corners = [
                    { name: 'Top-Left (0,0)', x: 0, y: 0 },
                    { name: 'Top-Right', x: w - 1, y: 0 },
                    { name: 'Bottom-Left', x: 0, y: h - 1 },
                    { name: 'Bottom-Right', x: w - 1, y: h - 1 },
                    { name: 'Top-Center', x: Math.floor(w / 2), y: 0 },
                    { name: 'Left-Center', x: 0, y: Math.floor(h / 2) }
                ];
                
                console.log(`%c=== CORNER PIXELS FOR ${tileId} ===`, 'color: yellow; font-weight: bold');
                console.log(`Image size: ${w}x${h}`);
                for (const corner of corners) {
                    const i = (corner.y * w + corner.x) * 4;
                    const r = data[i], g = data[i + 1], b = data[i + 2], a = data[i + 3];
                    const isBlack = r < 20 && g < 20 && b < 20;
                    console.log(`${corner.name}: R=${r}, G=${g}, B=${b}, A=${a} - ${isBlack ? 'âœ… BLACK' : 'âŒ NOT BLACK (threshold 20)'}`);
                }
            };
            img.onerror = () => console.error(`Failed to load ${tileId}`);
            img.src = `./assets/tiles/${tileId}.bmp`;
        }

        // Process tile image to make black corners transparent
        // UO tiles have black (0,0,0) in the corners OUTSIDE the diamond shape
        // Only make transparent if: 1) pixel is black AND 2) outside diamond
        function processBlackToTransparent(img) {
            const canvas = document.createElement('canvas');
            const w = img.width || 44;
            const h = img.height || 44;
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d');
            
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, w, h);
            const data = imageData.data;
            
            // Diamond test: only make black pixels transparent if outside diamond
            const halfW = w / 2;
            const halfH = h / 2;
            
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    
                    // Diamond formula: |x-center|/half + |y-center|/half > 1 = outside
                    const dx = Math.abs(x - halfW) / halfW;
                    const dy = Math.abs(y - halfH) / halfH;
                    const outsideDiamond = (dx + dy) > 1;
                    
                    // Only make transparent if OUTSIDE diamond AND black
                    if (outsideDiamond) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        
                        // Pure black or very near black = transparent
                        if (r < 20 && g < 20 && b < 20) {
                            data[i + 3] = 0; // Set alpha to 0
                        }
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        // Load and process a tile image
        async function loadTileImage(tileId) {
            // Handle null/undefined/invalid tile IDs
            if (tileId == null) {
                console.warn('loadTileImage called with null/undefined tileId');
                return null;
            }
            
            let hexId = tileId;
            if (typeof tileId === 'number') {
                hexId = `0x${tileId.toString(16).toUpperCase().padStart(4, '0')}`;
            } else if (typeof tileId === 'string' && !tileId.startsWith('0x')) {
                const num = parseInt(tileId, 16);
                if (!isNaN(num)) {
                    hexId = `0x${num.toString(16).toUpperCase().padStart(4, '0')}`;
                }
            } else if (typeof tileId !== 'string') {
                // Unknown type - try to convert
                console.warn(`loadTileImage: unexpected tileId type: ${typeof tileId}`, tileId);
                hexId = String(tileId);
            }
            
            if (typeof hexId === 'string' && hexId.startsWith('0x')) {
                hexId = '0x' + hexId.substring(2).toUpperCase().padStart(4, '0');
            }
            
            // Return cached processed image if available
            if (tileImages[hexId]) {
                return tileImages[hexId];
            }

            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                
                img.onload = () => {
                    // Process to make black pixels transparent
                    const processed = processBlackToTransparent(img);
                    tileImages[hexId] = processed;
                    resolve(processed);
                };
                
                img.onerror = () => {
                    console.warn(`Failed to load tile: ${hexId}.bmp`);
                    resolve(null);
                };
                
                img.src = `./assets/tiles/${hexId}.bmp`;
            });
        }

        // Load land tile data
        async function loadLandTiles() {
            try {
                // Check if modules are loaded
                if (typeof LandTileLoader === 'undefined' || typeof TerrainGenerator === 'undefined') {
                    throw new Error('Modules not loaded. Check browser console for import errors.');
                }

                document.getElementById('status').textContent = 'Loading land tile data...';
                console.log('Attempting to load CSV from: ./assets/tiles/LandData.csv');
                console.log('LandTileLoader available:', typeof LandTileLoader);
                
                const tiles = await LandTileLoader.loadFromURL('./assets/tiles/LandData.csv');
                
                if (!tiles || tiles.length === 0) {
                    throw new Error('CSV file loaded but contains no tiles');
                }
                
                console.log(`Successfully loaded ${tiles.length} tiles`);
                
                // Store land tile data globally for collision detection
                landTileData = new Map();
                tiles.forEach(tile => {
                    if (tile.id !== undefined) {
                        const tileId = typeof tile.id === 'string' ? parseInt(tile.id, 16) : tile.id;
                        landTileData.set(tileId, tile);
                    }
                });
                console.log(`[Collision] Loaded ${landTileData.size} tile properties for collision detection`);
                
                // Auto-discover tile sets for V2
                console.log('Auto-discovering tile sets from CSV...');
                const discoveredSets = LandTileLoader.generateTileSets(tiles);
                initializeDynamicSets(discoveredSets);
                
                terrainGenerator = new TerrainGenerator(tiles);
                
                const tileTypes = Object.keys(terrainGenerator.tilesByType);
                console.log('Tile types found:', tileTypes.length);
                console.log('Sample types:', tileTypes.slice(0, 10));
                
                // DEBUG: Check corner pixel values (raw tiles)
                debugTileCorners('0x0003');
                debugTileCorners('0x003E');
                debugTileCorners('0x0016');
                
                // DEBUG: Check if transparency is applied after processing
                setTimeout(async () => {
                    const processedGrass = await loadTileImage('0x0003');
                    if (processedGrass) {
                        const ctx = processedGrass.getContext('2d');
                        const data = ctx.getImageData(0, 0, 44, 44).data;
                        
                        console.log('%c=== PROCESSED TILE 0x0003 (after transparency) ===', 'color: cyan; font-weight: bold');
                        
                        // Check corner alpha values
                        const corners = [
                            { name: 'Top-Left (0,0)', x: 0, y: 0 },
                            { name: 'Top-Right (43,0)', x: 43, y: 0 },
                            { name: 'Bottom-Left (0,43)', x: 0, y: 43 },
                            { name: 'Bottom-Right (43,43)', x: 43, y: 43 }
                        ];
                        
                        for (const corner of corners) {
                            const i = (corner.y * 44 + corner.x) * 4;
                            const a = data[i + 3];
                            console.log(`${corner.name}: Alpha=${a} - ${a === 0 ? 'âœ… TRANSPARENT' : 'âŒ NOT TRANSPARENT'}`);
                        }
                        
                        // CRITICAL: Check tile dimensions
                        console.log('%c=== TILE DIMENSIONS ===', 'color: orange; font-weight: bold');
                        console.log('Tile canvas size:', processedGrass.width, 'x', processedGrass.height);
                        console.log('Expected: 44 x 44');
                        console.log('Match:', processedGrass.width === 44 && processedGrass.height === 44 ? 'âœ… YES' : 'âŒ NO - THIS IS THE PROBLEM!');
                    }
                }, 500);
                
                document.getElementById('status').textContent = `[OK] Loaded ${tiles.length} land tiles! Ready to generate.`;
                
                // Initialize neighbor tester now that tiles are loaded
                if (typeof initNeighborTester === 'function') {
                    initNeighborTester();
                }
                
                // Auto-generate procedural map on page load
                console.log('[AutoGen] Auto-generating procedural map...');
                setTimeout(() => {
                    if (typeof testProceduralStatics === 'function') {
                        testProceduralStatics();
                    }
                }, 100);
            } catch (error) {
                const errorMsg = `[ERROR] ${error.message}. Check browser console (F12) for details.`;
                document.getElementById('status').textContent = errorMsg;
                console.error('Failed to load land tiles:', error);
                console.error('Error stack:', error.stack);
                
                // Try alternative path
                console.log('Attempting alternative path: assets/tiles/LandData.csv');
                try {
                    const tiles = await LandTileLoader.loadFromURL('assets/tiles/LandData.csv');
                    
                    // Auto-discover tile sets for V2
                    console.log('Auto-discovering tile sets from CSV (fallback)...');
                    const discoveredSets = LandTileLoader.generateTileSets(tiles);
                    initializeDynamicSets(discoveredSets);
                    
                    terrainGenerator = new TerrainGenerator(tiles);
                    document.getElementById('status').textContent = `[OK] Loaded ${tiles.length} tiles from alternative path!`;
                    
                    // Initialize neighbor tester now that tiles are loaded
                    if (typeof initNeighborTester === 'function') {
                        initNeighborTester();
                    }
                    
                    // Auto-generate procedural map on page load (fallback path)
                    console.log('[AutoGen] Auto-generating procedural map (fallback path)...');
                    setTimeout(() => {
                        if (typeof testProceduralStatics === 'function') {
                            testProceduralStatics();
                        }
                    }, 100);
                } catch (e) {
                    console.error('Alternative path also failed:', e);
                }
            }
        }

        // Generate terrain
        window.generateTerrain = async function() {
            if (!terrainGenerator) {
                const status = document.getElementById('status').textContent;
                if (status.includes('Loading')) {
                    alert('Land tile data is still loading. Please wait a few seconds and try again.');
                } else if (status.includes('ERROR')) {
                    alert('Land tile data failed to load. Check browser console (F12) for details. Make sure you are accessing via http://localhost:8000, not file://');
                } else {
                    alert('Land tile data not loaded. Click OK to retry loading...');
                    await loadLandTiles();
                    if (!terrainGenerator) {
                        alert('Still failed to load. Check console for errors.');
                        return;
                    }
                }
                return;
            }

            const width = parseInt(document.getElementById('width').value);
            const height = parseInt(document.getElementById('height').value);
            const genType = document.getElementById('genType').value;
            const seedInput = document.getElementById('seed').value;
            const seed = seedInput ? parseInt(seedInput) : null;

            document.getElementById('status').textContent = 'Generating terrain...';

            try {
                let map;
                if (genType === 'water') {
                    map = terrainGenerator.generateMapWithWater(width, height, { seed });
                } else {
                    map = terrainGenerator.generateMap(width, height, seed);
                }

                currentMap = map;
                await renderMap(map);
                
                // Count biomes
                const biomeCounts = {};
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const biome = map[y][x].biome;
                        biomeCounts[biome] = (biomeCounts[biome] || 0) + 1;
                    }
                }

                const counts = Object.entries(biomeCounts)
                    .map(([biome, count]) => `${biome}: ${count}`)
                    .join(', ');
                document.getElementById('status').textContent = `âœ… Generated ${width}x${height} map! Biomes: ${counts}`;
            } catch (error) {
                document.getElementById('status').textContent = `âŒ Error: ${error.message}`;
                console.error('Generation error:', error);
            }
        };

        // Generate test map (Mirror Reference) - OLD
        window.generateTestMap = async function() {
            if (!terrainGenerator) {
                alert('Please load tile data first!');
                return;
            }
            
            document.getElementById('status').textContent = 'Generating test scene...';
            
            try {
                // Fixed size for test scene
                const width = 30;
                const height = 30;
                
                const map = terrainGenerator.generateTestMap(width, height);
                currentMap = map;
                await renderMap(map);
                
                document.getElementById('status').textContent = `âœ… Generated Test Scene (Mirror Ref)`;
            } catch (error) {
                console.error(error);
                document.getElementById('status').textContent = `âŒ Error: ${error.message}`;
            }
        };

        // ============================================================
        // V2 TERRAIN GENERATOR - Uses proper UO tile sets
        // Tiles come in groups of 4 that tessellate together
        // ============================================================
        
        // Collect ALL saved transition mappings to pass to the generator
        // Returns { grass_sand: {0: '0x0003', 1: '0x0036', ...}, grass_dirt: {...}, ... }
        function getAllSavedTransitionMappings() {
            const allMappings = {};
            for (const transKey of Object.keys(ALL_TRANSITIONS)) {
                if (transKey === 'browse_all') continue; // Skip the browse option
                // Copy the mapping directly (the 16-case object)
                allMappings[transKey] = { ...ALL_TRANSITIONS[transKey].mapping };
            }
            console.log('ğŸ“¦ Collected ALL transition mappings:', Object.keys(allMappings));
            // Debug: show grass_sand mapping
            console.log('ğŸ“¦ grass_sand mapping sample:', allMappings.grass_sand);
            console.log('ğŸ“¦ grass_sand[0]:', allMappings.grass_sand[0]);
            console.log('ğŸ“¦ grass_sand["0"]:', allMappings.grass_sand["0"]);
            console.log('ğŸ“¦ grass_sand keys:', Object.keys(allMappings.grass_sand));
            return allMappings;
        }
        
        window.generateTerrainV2 = async function() {
            const use3D = document.getElementById('enable3DHeight').checked;
            
            // If 3D checkbox is checked, use WebGL renderer
            if (use3D) {
                await generateTerrainV2_WebGL();
                return;
            }
            
            // Otherwise use 2D canvas
            showCanvas2D();
            document.getElementById('status').textContent = 'Generating terrain (V2 - Proper Tile Sets)...';
            
            try {
                const width = parseInt(document.getElementById('width').value) || 50;
                const height = parseInt(document.getElementById('height').value) || 50;
                const seedInput = document.getElementById('seed').value;
                
                // Create V2 generator with seed AND ALL custom tile mappings from Tile Teacher
                const seed = seedInput ? parseInt(seedInput) : Date.now();
                const allMappings = getAllSavedTransitionMappings();
                const genV2 = new TerrainGeneratorV2(seed, allMappings);
                
                const map = genV2.generateMap(width, height);
                currentMap = map;
                await renderMap(map);
                
                const mappingCount = Object.keys(allMappings).length;
                document.getElementById('status').textContent = `âœ… V2 Generated ${width}x${height} map (Seed: ${seed}) - Using ${mappingCount} transition mappings`;
            } catch (error) {
                document.getElementById('status').textContent = `âŒ Error: ${error.message}`;
                console.error('V2 Generation error:', error);
            }
        };
        
        // WebGL 3D version of generateTerrainV2 - called when 3D checkbox is checked
        async function generateTerrainV2_WebGL() {
            document.getElementById('status').textContent = 'Generating 3D terrain with WebGL...';
            
            try {
                const width = parseInt(document.getElementById('width').value) || 50;
                const height = parseInt(document.getElementById('height').value) || 50;
                const seedInput = document.getElementById('seed').value;
                
                // Generate the map using V2 generator
                const seed = seedInput ? parseInt(seedInput) : Date.now();
                const allMappings = getAllSavedTransitionMappings();
                const genV2 = new TerrainGeneratorV2(seed, allMappings);
                const map = genV2.generateMap(width, height);
                currentMap = map;
                
                // Create a separate canvas for WebGL (can't mix 2D and WebGL contexts)
                const canvasContainer = document.getElementById('canvas').parentElement;
                const originalCanvas = document.getElementById('canvas');
                
                // Remove old WebGL canvas if exists
                if (webglCanvas && webglCanvas.parentElement) {
                    webglCanvas.parentElement.removeChild(webglCanvas);
                }
                
                // Create new WebGL canvas
                webglCanvas = document.createElement('canvas');
                webglCanvas.id = 'webgl-canvas';
                webglCanvas.style.display = 'block';
                webglCanvas.style.border = 'none';
                webglCanvas.style.background = '#1a1a2e';
                
                // Hide original canvas, show WebGL canvas
                originalCanvas.style.display = 'none';
                
                // Enable scrolling for WebGL canvas (it's larger than the container)
                canvasContainer.style.overflow = 'auto';
                canvasContainer.appendChild(webglCanvas);
                
                console.log('WebGL canvas created and appended, container:', canvasContainer);
                
                // Create WebGL renderer on the new canvas
                try {
                    webglRenderer = new WebGLTerrainRenderer(webglCanvas);
                } catch (e) {
                    document.getElementById('status').textContent = `âŒ WebGL not supported: ${e.message}`;
                    console.error('WebGL init error:', e);
                    originalCanvas.style.display = 'block';
                    return;
                }
                
                // Generate corner heights from the map
                const cornerHeights = WebGLTerrainRenderer.generateCornerHeights(map, width, height);
                
                // Preload all tile textures
                document.getElementById('status').textContent = 'Loading textures for WebGL 3D...';
                const uniqueTileIds = new Set();
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        uniqueTileIds.add(map[y][x].id);
                    }
                }
                
                // Load each unique tile as a WebGL texture
                console.log('Unique tile IDs to load for WebGL:', Array.from(uniqueTileIds));
                let loadedCount = 0;
                for (const tileId of uniqueTileIds) {
                    const processedImage = await loadTileImage(tileId);
                    if (processedImage) {
                        webglRenderer.loadTexture(tileId, processedImage);
                        loadedCount++;
                    } else {
                        console.warn('Failed to load tile for WebGL:', tileId);
                    }
                }
                
                console.log(`Loaded ${loadedCount}/${uniqueTileIds.size} textures for WebGL`);
                
                // Render with WebGL
                webglRenderer.render(map, cornerHeights, null);
                
                // Log canvas dimensions after render
                console.log('WebGL canvas after render:', webglCanvas.width, 'x', webglCanvas.height);
                
                const mappingCount = Object.keys(allMappings).length;
                document.getElementById('status').textContent = `âœ… 3D V2 Generated ${width}x${height} map (Seed: ${seed}) - WebGL with ${mappingCount} transitions. Use scroll/drag to navigate.`;
                
                // Auto-center and auto-zoom the map
                setTimeout(() => {
                    fitToView();
                }, 100);
            } catch (error) {
                document.getElementById('status').textContent = `âŒ WebGL Error: ${error.message}`;
                console.error('WebGL 3D Generation error:', error);
            }
        }
        
        // WebGL 3D Terrain Renderer - UO-style texture-mapped triangles with Z-height
        let webglCanvas = null;  // Separate canvas for WebGL
        
        // Switch back to 2D canvas when using other generators
        function showCanvas2D() {
            const originalCanvas = document.getElementById('canvas');
            const canvasContainer = document.getElementById('canvasContainer');
            if (webglCanvas && webglCanvas.parentElement) {
                webglCanvas.style.display = 'none';
            }
            originalCanvas.style.display = 'block';
            // Restore overflow hidden for 2D canvas (uses transform-based panning)
            canvasContainer.style.overflow = 'hidden';
        }
        
        window.generateTestMapV2 = async function() {
            document.getElementById('status').textContent = 'Generating V2 test scene...';
            
            try {
                const genV2 = new TerrainGeneratorV2(12345); // Fixed seed for testing
                const map = genV2.generateTestMap(40, 40);
                currentMap = map;
                await renderMap(map);
                
                document.getElementById('status').textContent = `âœ… V2 Test Scene - Proper Tile Tessellation`;
            } catch (error) {
                console.error(error);
                document.getElementById('status').textContent = `âŒ Error: ${error.message}`;
            }
        };

        window.generateCliffTest = async function(mode = 'rough') {
            // Map boolean to string for legacy compatibility
            if (typeof mode === 'boolean') {
                mode = mode ? 'cave' : 'rough';
            }
            
            let typeName = 'Rock (Rough)';
            if (mode === 'cave') typeName = 'Cave (Smooth)';
            if (mode === 'match') typeName = 'Mountain Match (0x01D3)';
            
            document.getElementById('status').textContent = `Generating ${typeName} Face test...`;
            
            try {
                const genV2 = new TerrainGeneratorV2(12345); 
                const map = genV2.generateCliffTestMap(40, 40, mode);
                currentMap = map;
                await renderMap(map);
                
                document.getElementById('status').textContent = `âœ… ${typeName} Face Test - High elevation cliff wall`;
            } catch (error) {
                console.error(error);
                document.getElementById('status').textContent = `âŒ Error: ${error.message}`;
            }
        };
        
        // Helper function to determine biome from tile ID
        function getBiomeFromTileId(tileId) {
            const id = typeof tileId === 'string' ? parseInt(tileId, 16) : tileId;
            
            // Water tiles - IMPORTANT: 0x00A8-0x00AB (168-171) is the main water tileset!
            if (id >= 0x00A8 && id <= 0x00AB) return 'water';  // Main water (168-171)
            if (id >= 0x0160 && id <= 0x017F) return 'water';  // Additional water (352-383)
            
            // Sand tiles (0x001C-0x0033) - includes sand embankments
            if (id >= 0x001C && id <= 0x0033) return 'sand';
            
            // Sand transition tiles (0x0048-0x006F)
            if (id >= 0x0048 && id <= 0x006F) return 'sand';
            
            // Dirt tiles (0x0136-0x014B)
            if (id >= 0x0136 && id <= 0x014B) return 'dirt';
            
            // Rock/Mountain tiles (0x00DC-0x00FF) - rough rock
            if (id >= 0x00DC && id <= 0x00FF) return 'rock';
            
            // Rock transitions (0x0071-0x008F)
            if (id >= 0x0071 && id <= 0x008F) return 'rock';
            
            // Rock/Cliff transitions (0x00C4-0x00DB)
            if (id >= 0x00C4 && id <= 0x00DB) return 'rock';
            
            // Mountain rock (0x01D3-0x01DA)
            if (id >= 0x01D3 && id <= 0x01DA) return 'rock';
            
            // Grass tiles (0x0003-0x001A)
            if (id >= 0x0003 && id <= 0x001A) return 'grass';
            
            // Forest/grass tiles (0x0034-0x0047)
            if (id >= 0x0034 && id <= 0x0047) return 'forest';
            
            // Grass-rock transitions (0x021F-0x0243)
            if (id >= 0x021F && id <= 0x0243) return 'grass';
            
            // Grass-sand transitions (0x0244-0x0267)
            if (id >= 0x0244 && id <= 0x0267) return 'grass';
            
            // Default to grass
            return 'grass';
        }
        
        // Helper function to detect water edges and apply embankments
        function applyEmbankmentsToRealMap(map, width, height) {
            // First pass: mark water edges
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const tile = map[y][x];
                    if (tile.biome === 'water') continue;
                    
                    // Check neighbors for water
                    let hasWaterNeighbor = false;
                    const waterDirs = {
                        north: false, south: false, east: false, west: false,
                        northEast: false, northWest: false, southEast: false, southWest: false
                    };
                    
                    // Check cardinal directions
                    if (y > 0 && map[y-1][x].biome === 'water') {
                        hasWaterNeighbor = true;
                        waterDirs.north = true;
                    }
                    if (y < height-1 && map[y+1][x].biome === 'water') {
                        hasWaterNeighbor = true;
                        waterDirs.south = true;
                    }
                    if (x < width-1 && map[y][x+1].biome === 'water') {
                        hasWaterNeighbor = true;
                        waterDirs.east = true;
                    }
                    if (x > 0 && map[y][x-1].biome === 'water') {
                        hasWaterNeighbor = true;
                        waterDirs.west = true;
                    }
                    
                    // Check diagonal directions
                    if (y > 0 && x < width-1 && map[y-1][x+1].biome === 'water') {
                        hasWaterNeighbor = true;
                        waterDirs.northEast = true;
                    }
                    if (y > 0 && x > 0 && map[y-1][x-1].biome === 'water') {
                        hasWaterNeighbor = true;
                        waterDirs.northWest = true;
                    }
                    if (y < height-1 && x < width-1 && map[y+1][x+1].biome === 'water') {
                        hasWaterNeighbor = true;
                        waterDirs.southEast = true;
                    }
                    if (y < height-1 && x > 0 && map[y+1][x-1].biome === 'water') {
                        hasWaterNeighbor = true;
                        waterDirs.southWest = true;
                    }
                    
                    if (hasWaterNeighbor) {
                        tile.isWaterEdge = true;
                        tile.waterDirs = waterDirs;
                    }
                }
            }
            
            // Second pass: apply embankment tiles
            const GRASS_EMBANKMENT = {
                waterNorth: ['0x098C', '0x098D', '0x098E', '0x098F'],
                waterSouth: ['0x0990', '0x0991', '0x0992', '0x0993'],
                waterEast:  ['0x0994', '0x0995', '0x0996', '0x0997'],
                waterWest:  ['0x0998', '0x0999', '0x099A', '0x099B'],
                waterNE: ['0x099C', '0x099D'],
                waterNW: ['0x099E', '0x099F'],
                waterSE: ['0x09A0', '0x09A1'],
                waterSW: ['0x09A2', '0x09A3'],
                landNE: ['0x09A4', '0x09A5'],
                landNW: ['0x09A6', '0x09A7'],
                landSE: ['0x09A8', '0x09A9'],
                landSW: ['0x09AA', '0x09AB'],
                surrounded: ['0x09AC', '0x09AD', '0x09AE', '0x09AF']
            };
            
            const SAND_EMBANKMENT = {
                waterNorth: ['0x001C', '0x001D', '0x001E', '0x001F'],
                waterSouth: ['0x0020', '0x0021', '0x0022', '0x0023'],
                waterEast:  ['0x0024', '0x0025', '0x0026', '0x0027'],
                waterWest:  ['0x0028', '0x0029', '0x002A', '0x002B'],
                waterNE: ['0x002C', '0x002D'],
                waterNW: ['0x002E', '0x002F'],
                waterSE: ['0x0030', '0x0031'],
                waterSW: ['0x0032', '0x0033']
            };
            
            let embankmentCount = 0;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const tile = map[y][x];
                    if (!tile.isWaterEdge || tile.biome === 'water') continue;
                    
                    const waterDirs = tile.waterDirs;
                    const cardinalWater = [waterDirs.north, waterDirs.south, waterDirs.east, waterDirs.west]
                        .filter(Boolean).length;
                    
                    const EMBANKMENT = tile.biome === 'sand' ? SAND_EMBANKMENT : GRASS_EMBANKMENT;
                    let embankTiles = null;
                    
                    // Apply embankment based on water direction
                    if (cardinalWater >= 3) {
                        // Peninsula
                        if (!waterDirs.south && !waterDirs.east) embankTiles = EMBANKMENT.landSE;
                        else if (!waterDirs.south && !waterDirs.west) embankTiles = EMBANKMENT.landSW;
                        else if (!waterDirs.north && !waterDirs.east) embankTiles = EMBANKMENT.landNE;
                        else if (!waterDirs.north && !waterDirs.west) embankTiles = EMBANKMENT.landNW;
                        else embankTiles = EMBANKMENT.surrounded || EMBANKMENT.waterNorth;
                    } else if (cardinalWater === 2) {
                        // Outer corner
                        if (waterDirs.north && waterDirs.east) embankTiles = EMBANKMENT.waterNE;
                        else if (waterDirs.north && waterDirs.west) embankTiles = EMBANKMENT.waterNW;
                        else if (waterDirs.south && waterDirs.east) embankTiles = EMBANKMENT.waterSE;
                        else if (waterDirs.south && waterDirs.west) embankTiles = EMBANKMENT.waterSW;
                        else if (waterDirs.north) embankTiles = EMBANKMENT.waterNorth;
                        else if (waterDirs.east) embankTiles = EMBANKMENT.waterEast;
                    } else if (cardinalWater === 1) {
                        // Edge
                        if (waterDirs.north) embankTiles = EMBANKMENT.waterNorth;
                        else if (waterDirs.south) embankTiles = EMBANKMENT.waterSouth;
                        else if (waterDirs.east) embankTiles = EMBANKMENT.waterEast;
                        else if (waterDirs.west) embankTiles = EMBANKMENT.waterWest;
                    } else {
                        // Diagonal only
                        if (waterDirs.northEast) embankTiles = EMBANKMENT.waterNE;
                        else if (waterDirs.northWest) embankTiles = EMBANKMENT.waterNW;
                        else if (waterDirs.southEast) embankTiles = EMBANKMENT.waterSE;
                        else if (waterDirs.southWest) embankTiles = EMBANKMENT.waterSW;
                    }
                    
                    if (embankTiles && embankTiles.length > 0) {
                        const index = ((x * 7 + y * 13) % embankTiles.length);
                        tile.id = embankTiles[index];
                        tile.isEmbankment = true;
                        embankmentCount++;
                    }
                }
            }
            
            console.log(`[loadRealUOMap] Applied ${embankmentCount} embankment tiles`);
        }
        
        // Helper function to update progress bar (make it globally accessible)
        window.updateProgress = function(percent, message = null) {
            const progressBar = document.getElementById('progressBar');
            if (progressBar) {
                progressBar.style.width = `${Math.min(100, Math.max(0, percent))}%`;
            }
            if (message) {
                const statusEl = document.getElementById('status');
                if (statusEl) {
                    statusEl.textContent = message;
                }
            }
        };
        
        window.loadRealUOMap = async function(fixedX = null, fixedY = null, regionName = 'Region') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = 'ğŸ”„ Loading real UO map data...';
            statusEl.style.color = '#4CAF50';
            updateProgress(0, 'ğŸ”„ Loading real UO map data...');
            
            try {
                console.log('[loadRealUOMap] Starting...');
                
                // Initialize static loader
                const staticLoader = new UOStaticLoader();
                
                // Load map
                updateProgress(5, 'ğŸ”„ Loading map0.mul...');
                const loaded = await uoMapLoader.loadMap('./assets/mul/map0.mul', 7168, 4096);
                
                if (!loaded) {
                    throw new Error('Failed to load map0.mul. Check console for details.');
                }
                
                updateProgress(20, 'âœ… Map loaded! Checking for static objects...');
                
                // Try to load statics (optional - may not exist yet)
                let staticsLoaded = false;
                let staticsCount = 0;
                try {
                    // First check if files exist by trying to fetch them
                    updateProgress(25, 'ğŸ” Checking for statics files...');
                    const indexCheck = await fetch('./assets/mul/staidx0.mul', { method: 'HEAD' });
                    const staticCheck = await fetch('./assets/mul/statics0.mul', { method: 'HEAD' });
                    
                    if (!indexCheck.ok || !staticCheck.ok) {
                        statusEl.textContent = 'âš ï¸  Statics files not found (statics0.mul, staidx0.mul)';
                        statusEl.style.color = '#ff9800';
                        console.warn('[loadRealUOMap] âš ï¸  Statics files not found in assets/mul/');
                        console.warn('[loadRealUOMap] Files needed: statics0.mul and staidx0.mul');
                        console.warn('[loadRealUOMap] Copy them from "Ultima Online Classic" folder to assets/mul/');
                        console.warn('[loadRealUOMap] Or run: copy_statics.bat');
                    } else {
                        updateProgress(30, 'ğŸ”„ Loading static objects...');
                        staticsLoaded = await staticLoader.loadStatics(
                            './assets/mul/statics0.mul',
                            './assets/mul/staidx0.mul',
                            7168, 4096
                        );
                        if (staticsLoaded) {
                            const info = staticLoader.getInfo();
                            updateProgress(40, `âœ… Statics loaded! (Index: ${(info.indexSize / 1024 / 1024).toFixed(1)}MB, Data: ${(info.staticSize / 1024 / 1024).toFixed(1)}MB)`);
                            statusEl.style.color = '#4CAF50';
                            console.log('[loadRealUOMap] âœ… Statics loaded successfully');
                            console.log('[loadRealUOMap] Static files:', {
                                indexSize: `${(info.indexSize / 1024 / 1024).toFixed(2)} MB`,
                                staticSize: `${(info.staticSize / 1024 / 1024).toFixed(2)} MB`
                            });
                        }
                    }
                } catch (e) {
                    statusEl.textContent = `âš ï¸  Statics not available: ${e.message}`;
                    statusEl.style.color = '#ff9800';
                    console.warn('[loadRealUOMap] âš ï¸  Statics not available:', e.message);
                    console.warn('[loadRealUOMap] Copy statics0.mul and staidx0.mul to assets/mul/ to enable static objects');
                    console.warn('[loadRealUOMap] Or run: copy_statics.bat');
                }
                
                const info = uoMapLoader.getMapInfo();
                console.log('[loadRealUOMap] Map info:', info);
                
                // Region size
                const regionWidth = 60;
                const regionHeight = 60;
                
                // Check if we should use fixed coordinates or random
                let regionX, regionY;
                if (fixedX !== null && fixedY !== null) {
                    // Use directly passed coordinates (preferred method)
                    regionX = fixedX;
                    regionY = fixedY;
                    console.log(`[loadRealUOMap] ğŸ° ${regionName}: (${regionX}, ${regionY})`);
                    updateProgress(10, `ğŸ° ${regionName}: X=${regionX}, Y=${regionY} (${regionWidth}Ã—${regionHeight})`);
                } else if (window.useFixedRegion && window.fixedRegionX !== undefined) {
                    // Legacy global variable method (for backwards compatibility)
                    regionX = window.fixedRegionX;
                    regionY = window.fixedRegionY;
                    window.useFixedRegion = false; // Reset for next time
                    console.log(`[loadRealUOMap] ğŸ° Fixed region: (${regionX}, ${regionY})`);
                } else {
                    // Random region from the map (map0 is 7168 x 4096)
                    const maxX = 7168 - regionWidth - 100;
                    const maxY = 4096 - regionHeight - 100;
                    regionX = Math.floor(Math.random() * maxX);
                    regionY = Math.floor(Math.random() * maxY);
                    console.log(`[loadRealUOMap] ğŸ² Random region: (${regionX}, ${regionY})`);
                    
                    // Show coordinates prominently
                    updateProgress(10, `ğŸ² RANDOM REGION: X=${regionX}, Y=${regionY} (${regionWidth}Ã—${regionHeight})`);
                }
                
                console.log(`[loadRealUOMap] Region size: ${regionWidth}Ã—${regionHeight}`);
                
                // Brief pause to show coordinates
                await new Promise(r => setTimeout(r, 500));
                
                updateProgress(45, `ğŸ”„ Loading region (${regionX}, ${regionY})...`);
                console.log(`[loadRealUOMap] Extracting region (${regionX}, ${regionY}) size ${regionWidth}Ã—${regionHeight}`);
                
                const region = uoMapLoader.extractRegion(regionX, regionY, regionWidth, regionHeight);
                
                updateProgress(50, 'ğŸ”„ Processing terrain data...');
                
                // Load statics for this region (limit to 50 for testing)
                let statics = [];
                if (staticsLoaded) {
                    try {
                        updateProgress(55, 'ğŸ”„ Loading static objects for region...');
                        statics = staticLoader.getStaticsForRegion(regionX, regionY, regionWidth, regionHeight);
                        staticsCount = statics.length;
                        console.log(`[loadRealUOMap] Found ${statics.length} static objects in region`);
                        if (statics.length > 0) {
                            const uniqueGraphics = new Set(statics.map(s => s.hexId));
                            updateProgress(60, `âœ… Found ${statics.length} static objects (${uniqueGraphics.size} types)`);
                            statusEl.style.color = '#4CAF50';
                            console.log(`[loadRealUOMap] Unique static graphics: ${uniqueGraphics.size}`, Array.from(uniqueGraphics).slice(0, 10));
                            console.log(`[loadRealUOMap] Sample static:`, statics[0]);
                        } else {
                            statusEl.textContent = `âš ï¸  No statics in this region (${regionX}, ${regionY})`;
                            statusEl.style.color = '#ff9800';
                            console.warn(`[loadRealUOMap] âš ï¸  No statics found in region (${regionX}, ${regionY}) size ${regionWidth}Ã—${regionHeight}`);
                            console.warn(`[loadRealUOMap] This area might not have static objects, or files might be empty`);
                        }
                    } catch (e) {
                        statusEl.textContent = `âŒ Error loading statics: ${e.message}`;
                        statusEl.style.color = '#f44336';
                        console.error(`[loadRealUOMap] Error loading statics:`, e);
                    }
                } else {
                    statusEl.textContent = 'âš ï¸  Statics files missing - copy statics0.mul and staidx0.mul to assets/mul/';
                    statusEl.style.color = '#ff9800';
                    console.warn(`[loadRealUOMap] âš ï¸  Statics not loaded - files missing or failed to load`);
                    console.warn(`[loadRealUOMap] Check: assets/mul/statics0.mul and assets/mul/staidx0.mul exist`);
                }
                
                // Convert to our map format with biome detection
                // IMPORTANT: Keep original tile IDs - don't replace with embankment IDs
                // The 3D renderer will handle height differences automatically
                const map = [];
                let minZ = Infinity;
                let maxZ = -Infinity;
                
                for (let y = 0; y < regionHeight; y++) {
                    map[y] = [];
                    for (let x = 0; x < regionWidth; x++) {
                        const tile = region[y][x];
                        const biome = getBiomeFromTileId(tile.tileId);
                        
                        // Track Z range for normalization
                        if (tile.z < minZ) minZ = tile.z;
                        if (tile.z > maxZ) maxZ = tile.z;
                        
                        map[y][x] = {
                            id: tile.hexId, // Keep original tile ID!
                            biome: biome,
                            elevation: tile.z, // Store raw Z for 3D rendering
                            moisture: biome === 'water' ? 1.0 : 0.5,
                            z: tile.z, // Signed Z-height (-128 to 127)
                            isWaterEdge: false,
                            originalTileId: tile.tileId // Keep original for reference
                        };
                    }
                }
                
                console.log(`[loadRealUOMap] Z-height range: ${minZ} to ${maxZ}`);
                
                // First, check what tile IDs are actually in the map file
                // UO map files MAY already contain embankment tiles - we should check before replacing
                const tileIdCounts = {};
                const embankmentTileIds = new Set([
                    // Grass embankments
                    '0x098C', '0x098D', '0x098E', '0x098F', '0x0990', '0x0991', '0x0992', '0x0993',
                    '0x0994', '0x0995', '0x0996', '0x0997', '0x0998', '0x0999', '0x099A', '0x099B',
                    '0x099C', '0x099D', '0x099E', '0x099F', '0x09A0', '0x09A1', '0x09A2', '0x09A3',
                    '0x09A4', '0x09A5', '0x09A6', '0x09A7', '0x09A8', '0x09A9', '0x09AA', '0x09AB',
                    '0x09AC', '0x09AD', '0x09AE', '0x09AF', '0x09B0', '0x09B1', '0x09B2', '0x09B3',
                    '0x09B4', '0x09B5', '0x09B6', '0x09B7', '0x09B8', '0x09B9', '0x09BA', '0x09BB',
                    '0x09BC', '0x09BD', '0x09BE', '0x09BF',
                    // Sand embankments
                    '0x001C', '0x001D', '0x001E', '0x001F', '0x0020', '0x0021', '0x0022', '0x0023',
                    '0x0024', '0x0025', '0x0026', '0x0027', '0x0028', '0x0029', '0x002A', '0x002B',
                    '0x002C', '0x002D', '0x002E', '0x002F', '0x0030', '0x0031', '0x0032', '0x0033'
                ]);
                
                for (let y = 0; y < regionHeight; y++) {
                    for (let x = 0; x < regionWidth; x++) {
                        const tileId = map[y][x].id;
                        tileIdCounts[tileId] = (tileIdCounts[tileId] || 0) + 1;
                    }
                }
                
                // Debug: Log all unique tile IDs to see what's in the map file
                console.log(`[loadRealUOMap] ğŸ“Š ALL TILE IDS IN REGION:`, Object.keys(tileIdCounts).sort());
                console.log(`[loadRealUOMap] ğŸ“Š Tile counts:`, Object.entries(tileIdCounts).sort((a,b) => b[1] - a[1]).slice(0, 20));
                
                // Check for sand embankment tiles specifically
                const sandEmbankIds = ['0x001C', '0x001D', '0x001E', '0x001F', '0x0020', '0x0021', '0x0022', '0x0023',
                                       '0x0024', '0x0025', '0x0026', '0x0027', '0x0028', '0x0029', '0x002A', '0x002B'];
                const foundSandEmbanks = sandEmbankIds.filter(id => tileIdCounts[id]);
                console.log(`[loadRealUOMap] ğŸ–ï¸ SAND EMBANKMENT TILES FOUND:`, foundSandEmbanks.length > 0 ? foundSandEmbanks : 'NONE!');
                
                const foundEmbankments = Object.keys(tileIdCounts).filter(id => embankmentTileIds.has(id));
                console.log(`[loadRealUOMap] Found ${foundEmbankments.length} embankment tile types already in map:`, foundEmbankments);
                console.log(`[loadRealUOMap] Top 10 tile IDs in map:`, Object.entries(tileIdCounts)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 10)
                    .map(([id, count]) => `${id} (${count})`));
                
                // Check if we should trust original tiles (skip embankment replacement)
                const trustOriginal = document.getElementById('trustOriginalTiles')?.checked ?? true;
                
                if (trustOriginal) {
                    console.log('[loadRealUOMap] ğŸ“œ Trusting original map tiles - no embankment replacement');
                }
                
                // Apply embankment tiles at water edges (UO Classic style)
                // BUT: Only if "Trust Original Map" is unchecked
                // If embankments are already in the map file, trust them!
                // UO uses specific embankment tile graphics (0x098C-0x09BF) at water edges
                // These tiles show the cliff face, and 3D rendering adds the height effect
                const GRASS_EMBANKMENT = {
                    waterNorth: ['0x098C', '0x098D', '0x098E', '0x098F'],
                    waterSouth: ['0x0990', '0x0991', '0x0992', '0x0993'],
                    waterEast:  ['0x0994', '0x0995', '0x0996', '0x0997'],
                    waterWest:  ['0x0998', '0x0999', '0x099A', '0x099B'],
                    waterNE: ['0x099C', '0x099D'],
                    waterNW: ['0x099E', '0x099F'],
                    waterSE: ['0x09A0', '0x09A1'],
                    waterSW: ['0x09A2', '0x09A3'],
                    landNE: ['0x09A4', '0x09A5'],
                    landNW: ['0x09A6', '0x09A7'],
                    landSE: ['0x09A8', '0x09A9'],
                    landSW: ['0x09AA', '0x09AB'],
                    surrounded: ['0x09AC', '0x09AD', '0x09AE', '0x09AF']
                };
                
                const SAND_EMBANKMENT = {
                    waterNorth: ['0x001C', '0x001D', '0x001E', '0x001F'],
                    waterSouth: ['0x0020', '0x0021', '0x0022', '0x0023'],
                    waterEast:  ['0x0024', '0x0025', '0x0026', '0x0027'],
                    waterWest:  ['0x0028', '0x0029', '0x002A', '0x002B'],
                    waterNE: ['0x002C', '0x002D'],
                    waterNW: ['0x002E', '0x002F'],
                    waterSE: ['0x0030', '0x0031'],
                    waterSW: ['0x0032', '0x0033'],
                    // For peninsulas (land surrounded by water on 3 sides)
                    landNE: ['0x002C', '0x002D'],
                    landNW: ['0x002E', '0x002F'],
                    landSE: ['0x0030', '0x0031'],
                    landSW: ['0x0032', '0x0033'],
                    surrounded: ['0x001C', '0x0020', '0x0024', '0x0028']
                };
                
                let embankmentCount = 0;
                
                // Only apply embankment replacement if "Trust Original Map" is unchecked
                if (!trustOriginal) {
                for (let y = 0; y < regionHeight; y++) {
                    for (let x = 0; x < regionWidth; x++) {
                        const tile = map[y][x];
                        if (tile.biome === 'water') continue;
                        
                        // Check neighbors for water
                        const waterDirs = {
                            north: y > 0 && map[y-1][x].biome === 'water',
                            south: y < regionHeight-1 && map[y+1][x].biome === 'water',
                            east: x < regionWidth-1 && map[y][x+1].biome === 'water',
                            west: x > 0 && map[y][x-1].biome === 'water',
                            northEast: y > 0 && x < regionWidth-1 && map[y-1][x+1].biome === 'water',
                            northWest: y > 0 && x > 0 && map[y-1][x-1].biome === 'water',
                            southEast: y < regionHeight-1 && x < regionWidth-1 && map[y+1][x+1].biome === 'water',
                            southWest: y < regionHeight-1 && x > 0 && map[y+1][x-1].biome === 'water'
                        };
                        
                        const cardinalWater = [waterDirs.north, waterDirs.south, waterDirs.east, waterDirs.west]
                            .filter(Boolean).length;
                        
                        if (cardinalWater === 0 && !waterDirs.northEast && !waterDirs.northWest && 
                            !waterDirs.southEast && !waterDirs.southWest) {
                            continue; // No water neighbors
                        }
                        
                        tile.isWaterEdge = true;
                        
                        // Select embankment tiles based on biome
                        // UO uses SAND embankments at most coastlines (creates beach effect)
                        // Only use rocky cliff embankments for actual rock/mountain tiles
                        const isRockTile = tile.biome === 'rock' || tile.biome === 'mountain' || 
                            (parseInt(tile.id, 16) >= 0x00DC && parseInt(tile.id, 16) <= 0x00E7) || // Dark stone
                            (parseInt(tile.id, 16) >= 0x00E8 && parseInt(tile.id, 16) <= 0x00EB) || // Light rock
                            (parseInt(tile.id, 16) >= 0x021F && parseInt(tile.id, 16) <= 0x0243);   // Mountain rock
                        
                        // Use sand embankments for grass/forest/jungle (beach effect)
                        // Use cliff embankments only for actual rock/mountain tiles  
                        const EMBANKMENT = isRockTile ? GRASS_EMBANKMENT : SAND_EMBANKMENT;
                        let embankTiles = null;
                        
                        // Apply embankment based on water direction
                        if (cardinalWater >= 3) {
                            // Peninsula
                            if (!waterDirs.south && !waterDirs.east) embankTiles = EMBANKMENT.landSE;
                            else if (!waterDirs.south && !waterDirs.west) embankTiles = EMBANKMENT.landSW;
                            else if (!waterDirs.north && !waterDirs.east) embankTiles = EMBANKMENT.landNE;
                            else if (!waterDirs.north && !waterDirs.west) embankTiles = EMBANKMENT.landNW;
                            else embankTiles = EMBANKMENT.surrounded || EMBANKMENT.waterNorth;
                        } else if (cardinalWater === 2) {
                            // Outer corner
                            if (waterDirs.north && waterDirs.east) embankTiles = EMBANKMENT.waterNE;
                            else if (waterDirs.north && waterDirs.west) embankTiles = EMBANKMENT.waterNW;
                            else if (waterDirs.south && waterDirs.east) embankTiles = EMBANKMENT.waterSE;
                            else if (waterDirs.south && waterDirs.west) embankTiles = EMBANKMENT.waterSW;
                            else if (waterDirs.north) embankTiles = EMBANKMENT.waterNorth;
                            else if (waterDirs.east) embankTiles = EMBANKMENT.waterEast;
                        } else if (cardinalWater === 1) {
                            // Edge
                            if (waterDirs.north) embankTiles = EMBANKMENT.waterNorth;
                            else if (waterDirs.south) embankTiles = EMBANKMENT.waterSouth;
                            else if (waterDirs.east) embankTiles = EMBANKMENT.waterEast;
                            else if (waterDirs.west) embankTiles = EMBANKMENT.waterWest;
                        } else {
                            // Diagonal only
                            if (waterDirs.northEast) embankTiles = EMBANKMENT.waterNE;
                            else if (waterDirs.northWest) embankTiles = EMBANKMENT.waterNW;
                            else if (waterDirs.southEast) embankTiles = EMBANKMENT.waterSE;
                            else if (waterDirs.southWest) embankTiles = EMBANKMENT.waterSW;
                        }
                        
                        if (embankTiles && embankTiles.length > 0) {
                            // Only replace if the original tile is NOT already an embankment
                            // The map file may already have correct embankment tiles!
                            const originalId = tile.originalTileId.toString(16).toUpperCase().padStart(4, '0');
                            const originalHexId = `0x${originalId}`;
                            
                            if (!embankmentTileIds.has(originalHexId)) {
                                // Original tile is NOT an embankment - replace it
                                const index = ((x * 7 + y * 13) % embankTiles.length);
                                tile.id = embankTiles[index]; // Replace with embankment tile
                                tile.isEmbankment = true;
                                tile.wasReplaced = true; // Mark that we replaced it
                                embankmentCount++;
                            } else {
                                // Original tile IS already an embankment - keep it!
                                tile.isEmbankment = true;
                                tile.wasReplaced = false; // Mark that we kept the original
                            }
                        }
                    }
                }
                } // End of if (!trustOriginal)
                
                const replacedCount = map.flat().filter(t => t.wasReplaced === true).length;
                const keptCount = map.flat().filter(t => t.isEmbankment && t.wasReplaced === false).length;
                
                if (!trustOriginal) {
                    console.log(`[loadRealUOMap] Embankment summary:`);
                    console.log(`  - Applied ${embankmentCount} embankment tiles at water edges`);
                    console.log(`  - Replaced ${replacedCount} tiles (were not embankments)`);
                    console.log(`  - Kept ${keptCount} original embankment tiles (already in map file)`);
                }
                
                // Summary: Are we accurately mirroring the file?
                const totalTiles = regionWidth * regionHeight;
                const waterTiles = map.flat().filter(t => t.biome === 'water').length;
                const landTiles = totalTiles - waterTiles;
                console.log(`[loadRealUOMap] Map summary:`);
                console.log(`  - Total tiles: ${totalTiles}`);
                console.log(`  - Water tiles: ${waterTiles}`);
                console.log(`  - Land tiles: ${landTiles}`);
                console.log(`  - Water edges: ${map.flat().filter(t => t.isWaterEdge).length}`);
                console.log(`  - Unique tile IDs: ${Object.keys(tileIdCounts).length}`);
                
                // Check if we're missing statics
                console.log(`[loadRealUOMap] âš ï¸  MISSING: Static objects (trees, rocks, buildings) are NOT loaded yet.`);
                console.log(`[loadRealUOMap] To load statics, we need statics0.mul and staidx0.mul files.`);
                console.log(`[loadRealUOMap] See MAP_ACCURACY_CHECKLIST.md for full list of missing features.`);
                
                updateProgress(75, 'ğŸ”„ Preparing WebGL 3D renderer...');
                console.log('[loadRealUOMap] Map converted, using WebGL 3D renderer...');
                
                // Use WebGL renderer for proper 3D stretched tiles (like ClassicUO)
                const originalCanvas = document.getElementById('canvas');
                const canvasContainer = document.getElementById('canvasContainer');
                
                // Enable scrolling for WebGL canvas (it's larger than the container)
                canvasContainer.style.overflow = 'auto';
                canvasContainer.style.cursor = 'grab';
                
                // Create or get WebGL canvas
                if (!webglCanvas) {
                    webglCanvas = document.createElement('canvas');
                    webglCanvas.id = 'webgl-canvas'; // Match the ID the drag handler checks for
                    webglCanvas.style.display = 'block';
                    webglCanvas.style.border = '1px solid #444';
                    webglCanvas.style.imageRendering = 'pixelated';
                    webglCanvas.style.imageRendering = '-moz-crisp-edges';
                    webglCanvas.style.imageRendering = 'crisp-edges';
                    canvasContainer.appendChild(webglCanvas);
                }
                
                // Hide 2D canvas, show WebGL canvas
                originalCanvas.style.display = 'none';
                webglCanvas.style.display = 'block';
                
                // Ensure canvas can be scrolled (don't constrain its size)
                webglCanvas.style.maxWidth = 'none';
                webglCanvas.style.maxHeight = 'none';
                
                // Initialize WebGL renderer
                if (!webglRenderer) {
                    try {
                        webglRenderer = new WebGLTerrainRenderer(webglCanvas);
                    } catch (e) {
                        document.getElementById('status').textContent = `âŒ WebGL not supported: ${e.message}`;
                        console.error('WebGL init error:', e);
                        originalCanvas.style.display = 'block';
                        return;
                    }
                }
                
                // Generate corner heights from UO map Z-values
                updateProgress(80, 'ğŸ”„ Calculating 3D corner heights...');
                // In UO, each tile has a Z-value, and corners are shared between tiles
                // Corner height = average of the 4 tiles that share that corner
                const cornerHeights = [];
                for (let cy = 0; cy <= regionHeight; cy++) {
                    cornerHeights[cy] = [];
                    for (let cx = 0; cx <= regionWidth; cx++) {
                        // Get the 4 tiles that share this corner
                        // Corner [cy][cx] is shared by tiles:
                        // - [cy-1][cx-1] (top-left)
                        // - [cy-1][cx]   (top-right)
                        // - [cy][cx-1]   (bottom-left)
                        // - [cy][cx]     (bottom-right)
                        const tiles = [];
                        if (cy > 0 && cx > 0) tiles.push(map[cy-1][cx-1].z);
                        if (cy > 0 && cx < regionWidth) tiles.push(map[cy-1][cx].z);
                        if (cy < regionHeight && cx > 0) tiles.push(map[cy][cx-1].z);
                        if (cy < regionHeight && cx < regionWidth) tiles.push(map[cy][cx].z);
                        
                        // Average the Z-values, normalize to 0-50 range for rendering
                        // UO Z-values are typically 0-127, but we'll normalize to 0-50
                        const avgZ = tiles.length > 0 
                            ? tiles.reduce((sum, z) => sum + z, 0) / tiles.length 
                            : 0;
                        
                        // Normalize: UO Z is typically 0-127, map to 0-50 for rendering
                        // Also handle negative Z (caves) by clamping to 0
                        const normalizedZ = Math.max(0, Math.min(50, Math.round((avgZ - minZ) / (maxZ - minZ || 1) * 50)));
                        cornerHeights[cy][cx] = normalizedZ;
                    }
                }
                
                console.log(`[loadRealUOMap] Generated corner heights: min=${minZ}, max=${maxZ}`);
                
                // Preload all tile textures
                updateProgress(85, 'ğŸ”„ Collecting unique tile IDs...');
                const uniqueTileIds = new Set();
                for (let y = 0; y < regionHeight; y++) {
                    for (let x = 0; x < regionWidth; x++) {
                        uniqueTileIds.add(map[y][x].id);
                    }
                }
                
                // Load each unique tile as a WebGL texture
                const totalTextures = uniqueTileIds.size;
                console.log(`[loadRealUOMap] Loading ${totalTextures} unique tile textures...`);
                let loadedCount = 0;
                let textureIndex = 0;
                for (const tileId of uniqueTileIds) {
                    textureIndex++;
                    if (textureIndex % 10 === 0 || textureIndex === totalTextures) {
                        const percent = 85 + Math.round((textureIndex / totalTextures) * 10);
                        updateProgress(percent, `ğŸ”„ Loading textures... ${textureIndex}/${totalTextures} (${Math.round(textureIndex/totalTextures*100)}%)`);
                    }
                    const processedImage = await loadTileImage(tileId);
                    if (processedImage) {
                        webglRenderer.loadTexture(tileId, processedImage);
                        loadedCount++;
                    } else {
                        console.warn(`[loadRealUOMap] Failed to load tile: ${tileId}`);
                    }
                }
                
                updateProgress(95, `âœ… Loaded ${loadedCount}/${totalTextures} textures`);
                console.log(`[loadRealUOMap] Loaded ${loadedCount}/${totalTextures} textures`);
                
                // Try to load art for static objects
                let artTextures = {};
                if (statics.length > 0) {
                    updateProgress(96, 'ğŸ”„ Loading static object graphics...');
                    try {
                        // Initialize art loader if not already done
                        let artFromUOPAvailable = false;
                        if (!artLoader) {
                            artLoader = new UOArtLoader();
                            const artLoaded = await artLoader.loadFromUOP('./assets/mul/artLegacyMUL.uop');
                            if (artLoaded) {
                                artFromUOPAvailable = true;
                                console.log('[loadRealUOMap] âœ… Art UOP loaded');
                            } else {
                                console.warn('[loadRealUOMap] âš ï¸ Could not load artLegacyMUL.uop');
                                console.warn('[loadRealUOMap] Run copy_art.bat to copy the file');
                            }
                        } else if (artLoader.isUOP) {
                            artFromUOPAvailable = true;
                        }

                        if (!itemLoader) {
                            itemLoader = new UOItemLoader();
                        }
                        
                        const uniqueGraphics = [...new Set(statics.map(s => s.graphic))];
                        console.log(`[loadRealUOMap] Loading ${uniqueGraphics.length} unique static graphics...`);
                        console.log(`[loadRealUOMap] First 5 graphic IDs:`, uniqueGraphics.slice(0, 5));
                        
                        let loadedArt = 0;
                        let triedFallback = false;
                        for (let i = 0; i < uniqueGraphics.length; i++) {
                            const graphic = uniqueGraphics[i];
                            if (i % 25 === 0 || i === uniqueGraphics.length - 1) {
                                const artProgress = 96 + Math.min(2, Math.round(((i + 1) / uniqueGraphics.length) * 2));
                                updateProgress(artProgress, `ğŸ”„ Static art ${i + 1}/${uniqueGraphics.length}`);
                            }

                            let texture = null;
                            
                            if (artFromUOPAvailable) {
                                try {
                                    texture = await artLoader.getStaticTexture(graphic);
                                } catch (err) {
                                    console.warn(`[loadRealUOMap] UOP art load failed for 0x${graphic.toString(16).toUpperCase()}: ${err.message}`);
                                }
                            }

                            if (!texture && itemLoader) {
                                if (!triedFallback && i === 0) {
                                    console.log('[loadRealUOMap] Using exported BMP items as fallback for static art');
                                    triedFallback = true;
                                }
                                try {
                                    texture = await itemLoader.getTexture(graphic);
                                } catch (err) {
                                    // BMP fallback may not have every asset; ignore per-id failures
                                }
                            }

                            if (texture) {
                                artTextures[graphic] = texture;
                                loadedArt++;
                            }
                        }
                        console.log(`[loadRealUOMap] Loaded ${loadedArt}/${uniqueGraphics.length} static art textures (UOP + BMP fallback)`);
                    } catch (e) {
                        console.warn('[loadRealUOMap] Art loading failed:', e.message);
                    }
                }
                
                // Convert statics to region-relative coordinates
                const regionStatics = statics.map(s => ({
                    ...s,
                    relX: s.worldX - regionX, // Relative X within region
                    relY: s.worldY - regionY,  // Relative Y within region
                    artTexture: artTextures[s.graphic] || null // Attach art if available
                }));
                
                // Store statics globally for collision detection
                currentStatics = regionStatics;
                
                // Render with WebGL (proper 3D stretched tiles + statics)
                updateProgress(98, 'ğŸ”„ Rendering 3D terrain with WebGL...');
                webglRenderer.render(map, cornerHeights, null, regionStatics);
                
                // Log statics info
                if (statics.length > 0) {
                    const uniqueGraphics = new Set(statics.map(s => s.hexId));
                    const artCount = Object.keys(artTextures).length;
                    const renderMode = artCount > 0 ? `${artCount} with graphics` : 'placeholder squares';
                    updateProgress(100, `âœ… Map rendered! ${statics.length} statics (${renderMode})`);
                    statusEl.style.color = '#4CAF50';
                    console.log(`[loadRealUOMap] âœ… ${statics.length} static objects loaded (${uniqueGraphics.size} unique types)`);
                    console.log(`[loadRealUOMap] Static rendering: ${artCount > 0 ? `${artCount} art textures loaded` : 'Placeholder mode (colored squares)'}`);
                } else {
                    updateProgress(100, `âœ… Map rendered! (No static objects in this region)`);
                    statusEl.style.color = '#4CAF50';
                }
                
                currentMap = map;
                
                // Auto-center and auto-zoom the map
                setTimeout(() => {
                    fitToView();
                }, 100);
                
                // Final status - show coordinates prominently
                const finalStatus = `âœ… LOADED: X=${regionX}, Y=${regionY} | Size: ${regionWidth}Ã—${regionHeight} | Z: ${minZ} to ${maxZ} | Statics: ${staticsCount}`;
                updateProgress(100, finalStatus);
                statusEl.style.color = '#4CAF50';
                statusEl.style.fontSize = '14px';
                statusEl.style.fontWeight = 'bold';
                
            } catch (error) {
                console.error('[loadRealUOMap] Error:', error);
                document.getElementById('status').textContent = `âŒ Error: ${error.message}`;
                alert(`Error loading map: ${error.message}\n\nCheck browser console (F12) for details.`);
            }
        };
        
        // TEST: Sand + Water example for user to review transitions
        window.generateTestSandWater = async function() {
            document.getElementById('status').textContent = 'Generating Sand + Water test...';
            
            try {
                const width = 20;
                const height = 20;
                
                // Create a DIAMOND test map matching user's painted map shape
                // Uses Manhattan distance for diamond shape
                const map = [];
                const centerX = width / 2;
                const centerY = height / 2;
                
                for (let y = 0; y < height; y++) {
                    map[y] = [];
                    for (let x = 0; x < width; x++) {
                        // Manhattan distance for diamond shape
                        const dist = Math.abs(x - centerX) + Math.abs(y - centerY);
                        
                        let biome, tileId;
                        
                        if (dist < 3) {
                            // Water in center (diamond)
                            biome = 'water';
                            tileId = '0x00A8';
                        } else if (dist < 5) {
                            // Sand beach around water (diamond ring)
                            biome = 'sand';
                            tileId = '0x0016';
                        } else {
                            // Grass everywhere else
                            biome = 'grass';
                            tileId = '0x0003';
                        }
                        
                        map[y][x] = {
                            biome: biome,
                            id: tileId,
                            x: x,
                            y: y
                        };
                    }
                }
                
                // Apply sand-to-grass transitions using our 8-bit system
                const { apply8BitTransitions } = await import('./js/data/transitionTiles8bit.js?v=' + Date.now());
                apply8BitTransitions(map, width, height);
                
                currentMap = map;
                await renderMap(map);
                
                document.getElementById('status').textContent = `âœ… Sand + Water Test (20x20) - Diamond shape to match your painted map!`;
            } catch (error) {
                console.error(error);
                document.getElementById('status').textContent = `âŒ Error: ${error.message}`;
            }
        };

        // ============================================
        // TILE TEACHING SYSTEM
        // ============================================
        
        // State for tile teaching
        let selectionMode = 'diag1'; // 'diag1', 'diag2', or 'case'
        let selectedDiag1 = null;
        let selectedDiag2 = null;
        let selectedCase = null;
        let tileTeacherVisible = false;
        let currentTransition = 'grass_sand';
        
        // ===========================================
        // ALL TRANSITION TILE MAPPINGS
        // ===========================================
        // Each transition has its own 16-case mapping
        // Pure tiles (case 0 and 15) are the two biomes
        // Cases 1-14 are the transition tiles
        
        const ALL_TRANSITIONS = {
            // âœ… GRASS â†” SAND (COMPLETE - You already set this up!)
            grass_sand: {
                name: 'Grass â†” Sand',
                biomeA: 'grass',
                biomeB: 'sand',
                // Tile ranges to show in "Available Tiles" section
                tileRanges: [[0x0003, 0x0006], [0x0016, 0x0019], [0x0033, 0x003F]],
                mapping: {
                    0:  '0x0003',  // Pure Grass
                    15: '0x0016',  // Pure Sand
                    1:  '0x0036',  // Outer NW - BL is sand
                    2:  '0x0033',  // Outer SE - BR is sand
                    4:  '0x0034',  // Outer SW - TR is sand
                    8:  '0x0035',  // Outer NE - TL is sand
                    3:  '0x0038',  // Edge S
                    6:  '0x003a',  // Edge E
                    9:  '0x0039',  // Edge W
                    12: '0x0005',  // Edge N
                    7:  '0x003b',  // Inner SE
                    11: '0x003c',  // Inner SW
                    13: '0x003d',  // Inner NE
                    14: '0x003e',  // Inner NW
                    5:  '0x0037',  // Saddle 1
                    10: '0x0004'   // Saddle 2
                }
            },
            
            // ğŸ’§ GRASS â†” WATER - Browse tiles 0x0000-0x00FF to find water/grass transitions
            grass_water: {
                name: 'Grass â†” Water',
                biomeA: 'grass',
                biomeB: 'water',
                // Show a broad range - you need to find the correct water transition tiles!
                tileRanges: [[0x0000, 0x00FF]],  // Browse first 256 tiles
                mapping: {
                    0:  '0x0003',  // Pure Grass
                    15: '0x00A8',  // Pure Water (PLACEHOLDER - find correct!)
                    1:  '0x0003', 2:  '0x0003', 4:  '0x0003', 8:  '0x0003',
                    3:  '0x0003', 6:  '0x0003', 9:  '0x0003', 12: '0x0003',
                    7:  '0x0003', 11: '0x0003', 13: '0x0003', 14: '0x0003',
                    5:  '0x0003', 10: '0x0003'
                }
            },
            
            // ğŸ–ï¸ğŸ’§ SAND â†” WATER
            sand_water: {
                name: 'Sand â†” Water',
                biomeA: 'sand',
                biomeB: 'water',
                tileRanges: [[0x0000, 0x00FF]],  // Browse first 256 tiles
                mapping: {
                    0:  '0x0016',  // Pure Sand
                    15: '0x00A8',  // Pure Water (PLACEHOLDER)
                    1:  '0x0016', 2:  '0x0016', 4:  '0x0016', 8:  '0x0016',
                    3:  '0x0016', 6:  '0x0016', 9:  '0x0016', 12: '0x0016',
                    7:  '0x0016', 11: '0x0016', 13: '0x0016', 14: '0x0016',
                    5:  '0x0016', 10: '0x0016'
                }
            },
            
            // ğŸŒ±ğŸŸ¤ GRASS â†” DIRT - Browse tiles to find grass/dirt transitions
            grass_dirt: {
                name: 'Grass â†” Dirt',
                biomeA: 'grass',
                biomeB: 'dirt',
                tileRanges: [[0x0000, 0x00FF]],  // Browse first 256 tiles
                mapping: {
                    0:  '0x0003',  // Pure Grass
                    15: '0x0031',  // Pure Dirt (PLACEHOLDER - 0x0031 is dirt?)
                    1:  '0x0003', 2:  '0x0003', 4:  '0x0003', 8:  '0x0003',
                    3:  '0x0003', 6:  '0x0003', 9:  '0x0003', 12: '0x0003',
                    7:  '0x0003', 11: '0x0003', 13: '0x0003', 14: '0x0003',
                    5:  '0x0003', 10: '0x0003'
                }
            },
            
            // ğŸŒ±ğŸª¨ GRASS â†” ROCK (Based on UO tile analysis)
            // Rock tiles: 0x00E4-0x00E7 (pure rock)
            // Rock transitions: 0x00F4-0x00F7, 0x0104-0x0107, 0x021F-0x0226, 0x0231-0x0238
            grass_rock: {
                name: 'Grass â†” Rock',
                biomeA: 'grass',
                biomeB: 'rock',
                tileRanges: [[0x00DC, 0x00FF], [0x0100, 0x0127], [0x021F, 0x0240]],  // Rock and transition tiles
                mapping: {
                    0:  '0x0003',  // Pure Grass
                    15: '0x00E4',  // Pure Rock (grey rock)
                    // Outer corners - rock pokes into grass (single rock corner)
                    1:  '0x00F5',  // Rock in BL corner - grass/rock edge
                    2:  '0x00F4',  // Rock in BR corner
                    4:  '0x00F6',  // Rock in TR corner
                    8:  '0x00F7',  // Rock in TL corner
                    // Edges - rock on one side
                    3:  '0x0104',  // Rock on bottom (S edge)
                    6:  '0x0106',  // Rock on right (E edge)
                    9:  '0x0105',  // Rock on left (W edge)
                    12: '0x0107',  // Rock on top (N edge)
                    // Inner corners - grass pokes into rock (mostly rock with grass corner)
                    7:  '0x0223',  // Grass in TL corner (rock on TR, BR, BL)
                    11: '0x0224',  // Grass in TR corner
                    13: '0x0225',  // Grass in BR corner
                    14: '0x0226',  // Grass in BL corner
                    // Saddles - diagonal rock pattern
                    5:  '0x021F',  // Rock in TR+BL
                    10: '0x0220'   // Rock in TL+BR
                }
            },
            
            // ğŸŒ±ğŸŒ´ GRASS â†” JUNGLE
            grass_jungle: {
                name: 'Grass â†” Jungle',
                biomeA: 'grass',
                biomeB: 'jungle',
                tileRanges: [[0x0000, 0x00FF]],
                mapping: {
                    0:  '0x0003',  // Pure Grass
                    15: '0x00AC',  // Pure Jungle (PLACEHOLDER)
                    1:  '0x0003', 2:  '0x0003', 4:  '0x0003', 8:  '0x0003',
                    3:  '0x0003', 6:  '0x0003', 9:  '0x0003', 12: '0x0003',
                    7:  '0x0003', 11: '0x0003', 13: '0x0003', 14: '0x0003',
                    5:  '0x0003', 10: '0x0003'
                }
            },
            
            // ğŸŒ±ğŸŒ² GRASS â†” FOREST
            grass_forest: {
                name: 'Grass â†” Forest',
                biomeA: 'grass',
                biomeB: 'forest',
                tileRanges: [[0x0000, 0x00FF]],
                mapping: {
                    0:  '0x0003',  // Pure Grass
                    15: '0x00C4',  // Pure Forest (PLACEHOLDER)
                    1:  '0x0003', 2:  '0x0003', 4:  '0x0003', 8:  '0x0003',
                    3:  '0x0003', 6:  '0x0003', 9:  '0x0003', 12: '0x0003',
                    7:  '0x0003', 11: '0x0003', 13: '0x0003', 14: '0x0003',
                    5:  '0x0003', 10: '0x0003'
                }
            },
            
            // ğŸ–ï¸ğŸŸ¤ SAND â†” DIRT
            sand_dirt: {
                name: 'Sand â†” Dirt',
                biomeA: 'sand',
                biomeB: 'dirt',
                tileRanges: [[0x0000, 0x00FF]],
                mapping: {
                    0:  '0x0016',  // Pure Sand
                    15: '0x0031',  // Pure Dirt (PLACEHOLDER)
                    1:  '0x0016', 2:  '0x0016', 4:  '0x0016', 8:  '0x0016',
                    3:  '0x0016', 6:  '0x0016', 9:  '0x0016', 12: '0x0016',
                    7:  '0x0016', 11: '0x0016', 13: '0x0016', 14: '0x0016',
                    5:  '0x0016', 10: '0x0016'
                }
            },
            
            // ğŸŒ´ğŸ–ï¸ JUNGLE â†” SAND
            jungle_sand: {
                name: 'Jungle â†” Sand',
                biomeA: 'jungle',
                biomeB: 'sand',
                tileRanges: [[0x0000, 0x00FF]],
                mapping: {
                    0:  '0x00AC',  // Pure Jungle (PLACEHOLDER - find correct!)
                    15: '0x0016',  // Pure Sand
                    1:  '0x00AC', 2:  '0x00AC', 4:  '0x00AC', 8:  '0x00AC',
                    3:  '0x00AC', 6:  '0x00AC', 9:  '0x00AC', 12: '0x00AC',
                    7:  '0x00AC', 11: '0x00AC', 13: '0x00AC', 14: '0x00AC',
                    5:  '0x00AC', 10: '0x00AC'
                }
            },
            
            // ğŸŒ²ğŸ–ï¸ FOREST â†” SAND
            forest_sand: {
                name: 'Forest â†” Sand',
                biomeA: 'forest',
                biomeB: 'sand',
                tileRanges: [[0x0000, 0x00FF]],
                mapping: {
                    0:  '0x00C4',  // Pure Forest (PLACEHOLDER - find correct!)
                    15: '0x0016',  // Pure Sand
                    1:  '0x00C4', 2:  '0x00C4', 4:  '0x00C4', 8:  '0x00C4',
                    3:  '0x00C4', 6:  '0x00C4', 9:  '0x00C4', 12: '0x00C4',
                    7:  '0x00C4', 11: '0x00C4', 13: '0x00C4', 14: '0x00C4',
                    5:  '0x00C4', 10: '0x00C4'
                }
            },
            
            // ğŸŒ´ğŸŸ¤ JUNGLE â†” DIRT (MUD)
            jungle_dirt: {
                name: 'Jungle â†” Dirt (Mud)',
                biomeA: 'jungle',
                biomeB: 'dirt',
                tileRanges: [[0x0000, 0x00FF]],
                mapping: {
                    0:  '0x00AC',  // Pure Jungle (PLACEHOLDER)
                    15: '0x0031',  // Pure Dirt/Mud (PLACEHOLDER)
                    1:  '0x00AC', 2:  '0x00AC', 4:  '0x00AC', 8:  '0x00AC',
                    3:  '0x00AC', 6:  '0x00AC', 9:  '0x00AC', 12: '0x00AC',
                    7:  '0x00AC', 11: '0x00AC', 13: '0x00AC', 14: '0x00AC',
                    5:  '0x00AC', 10: '0x00AC'
                }
            },
            
            // ğŸŒ²ğŸŸ¤ FOREST â†” DIRT (MUD)
            forest_dirt: {
                name: 'Forest â†” Dirt (Mud)',
                biomeA: 'forest',
                biomeB: 'dirt',
                tileRanges: [[0x0000, 0x00FF]],
                mapping: {
                    0:  '0x00C4',  // Pure Forest (PLACEHOLDER)
                    15: '0x0031',  // Pure Dirt/Mud (PLACEHOLDER)
                    1:  '0x00C4', 2:  '0x00C4', 4:  '0x00C4', 8:  '0x00C4',
                    3:  '0x00C4', 6:  '0x00C4', 9:  '0x00C4', 12: '0x00C4',
                    7:  '0x00C4', 11: '0x00C4', 13: '0x00C4', 14: '0x00C4',
                    5:  '0x00C4', 10: '0x00C4'
                }
            },
            
            // ğŸ” BROWSE ALL - Show all tiles so you can find any transition!
            browse_all: {
                name: 'ğŸ” Browse ALL Tiles',
                biomeA: 'any',
                biomeB: 'any',
                tileRanges: [[0x0000, 0x01FF]],  // First 512 tiles
                mapping: {
                    0:  '0x0003', 15: '0x0016',
                    1:  '0x0003', 2:  '0x0003', 4:  '0x0003', 8:  '0x0003',
                    3:  '0x0003', 6:  '0x0003', 9:  '0x0003', 12: '0x0003',
                    7:  '0x0003', 11: '0x0003', 13: '0x0003', 14: '0x0003',
                    5:  '0x0003', 10: '0x0003'
                }
            },
            
            // ğŸ”ï¸ğŸ”ï¸ ROCK CLIFF (Land-to-Land)
            // Uses 0x09EC series (Rock Embankment)
            rock_cliff_land: {
                name: 'ğŸ”ï¸ Rock Cliff â†” Grass',
                biomeA: 'rock_cliff',
                biomeB: 'grass',
                tileRanges: [[0x09EC, 0x09FF], [0x00E4, 0x00E7], [0x0003, 0x0006]], 
                mapping: {
                    0:  '0x00E4',  // Pure Rock Top
                    15: '0x0003',  // Pure Grass Bottom
                    // Use placeholders, user will teach
                    1: '0x00E4', 2: '0x00E4', 4: '0x00E4', 8: '0x00E4',
                    3: '0x00E4', 6: '0x00E4', 9: '0x00E4', 12: '0x00E4',
                    7: '0x00E4', 11: '0x00E4', 13: '0x00E4', 14: '0x00E4',
                    5: '0x00E4', 10: '0x00E4'
                }
            },

            // ğŸ”ï¸ğŸ’§ GRASS EMBANKMENT â†” WATER (Cliff edges at water)
            // Grass embankment tiles: 0x098C-0x09BF (darker cliff tiles)
            grass_embank_water: {
                name: 'ğŸ”ï¸ Grass Cliff â†” Water',
                biomeA: 'grass_cliff',
                biomeB: 'water',
                tileRanges: [[0x098C, 0x09BF], [0x00A8, 0x00B0]],  // Grass embankment + water tiles
                mapping: {
                    0:  '0x098C',  // Pure Grass Cliff
                    15: '0x00A8',  // Pure Water
                    // Edges - cliff face towards water
                    1:  '0x098C', 2:  '0x098E', 4:  '0x0990', 8:  '0x0992',
                    // Edge combinations
                    3:  '0x098E', 6:  '0x0990', 9:  '0x0992', 12: '0x098C',
                    // Inner corners
                    7:  '0x0998', 11: '0x099A', 13: '0x099C', 14: '0x099E',
                    // Saddles
                    5:  '0x09A4', 10: '0x09A6'
                }
            },
            
            // ğŸ–ï¸ğŸ”ï¸ğŸ’§ SAND EMBANKMENT â†” WATER (Beach cliffs at water)
            // Sand embankment tiles: 0x001C-0x0033 and 0x0044-0x004B
            sand_embank_water: {
                name: 'ğŸ–ï¸ Sand Cliff â†” Water',
                biomeA: 'sand_cliff',
                biomeB: 'water',
                tileRanges: [[0x001C, 0x0033], [0x0044, 0x004B], [0x00A8, 0x00B0]],  // Sand embankment + water tiles
                mapping: {
                    0:  '0x001C',  // Pure Sand Cliff
                    15: '0x00A8',  // Pure Water
                    // Edges - based on the tile viewer images you showed
                    1:  '0x001C', 2:  '0x001E', 4:  '0x0020', 8:  '0x0022',
                    // Edge combinations
                    3:  '0x001E', 6:  '0x0020', 9:  '0x0022', 12: '0x001C',
                    // Corners
                    7:  '0x0028', 11: '0x002A', 13: '0x002C', 14: '0x002E',
                    // Saddles
                    5:  '0x0044', 10: '0x0046'
                }
            }
        };
        
        // Current editable mapping (points to the active transition)
        let EDITABLE_TILE_DATA = { ...ALL_TRANSITIONS.grass_sand.mapping };
        let DEFAULT_TILE_DATA = { ...ALL_TRANSITIONS.grass_sand.mapping };
        
        // Load saved mappings for ALL transitions on startup
        function loadTileMappings() {
            // Migrate old single-key storage to new multi-transition system
            const oldSaved = localStorage.getItem('uoTileMappings');
            if (oldSaved) {
                try {
                    const oldMappings = JSON.parse(oldSaved);
                    // Save to new grass_sand key if not already saved
                    if (!localStorage.getItem('uoTiles_grass_sand')) {
                        localStorage.setItem('uoTiles_grass_sand', JSON.stringify(oldMappings));
                        console.log('Migrated old uoTileMappings to uoTiles_grass_sand');
                    }
                    // Remove old key after migration
                    localStorage.removeItem('uoTileMappings');
                } catch (e) {
                    console.error('Error migrating old tile mappings:', e);
                }
            }
            
            // Load all saved transitions
            for (const transKey of Object.keys(ALL_TRANSITIONS)) {
                const saved = localStorage.getItem(`uoTiles_${transKey}`);
                if (saved) {
                    try {
                        const mappings = JSON.parse(saved);
                        for (let i = 0; i < 16; i++) {
                            if (mappings[i]) ALL_TRANSITIONS[transKey].mapping[i] = mappings[i];
                        }
                        console.log(`Loaded saved mappings for ${transKey}`);
                    } catch (e) {
                        console.error(`Error loading ${transKey} mappings:`, e);
                    }
                }
            }
            
            // Set current transition to grass_sand
            EDITABLE_TILE_DATA = { ...ALL_TRANSITIONS.grass_sand.mapping };
            DEFAULT_TILE_DATA = { ...ALL_TRANSITIONS.grass_sand.mapping };
            
            console.log('Grass/Sand mappings loaded:', EDITABLE_TILE_DATA);
        }
        
        // Switch to a different transition
        window.switchTransition = function(transKey) {
            if (!ALL_TRANSITIONS[transKey]) {
                console.error('Unknown transition:', transKey);
                return;
            }
            
            // Save current transition before switching
            saveTileMappingsForTransition(currentTransition, true);
            
            // Switch to new transition
            currentTransition = transKey;
            const trans = ALL_TRANSITIONS[transKey];
            
            // Update EDITABLE_TILE_DATA to point to this transition
            EDITABLE_TILE_DATA = { ...trans.mapping };
            DEFAULT_TILE_DATA = { ...trans.mapping };
            
            // Update UI labels
            document.getElementById('currentTransitionLabel').textContent = trans.name;
            document.getElementById('availableTilesLabel').textContent = trans.name;
            document.getElementById('transitionStatus').textContent = `âœ… ${trans.name} loaded`;
            document.getElementById('transitionStatus').style.color = '#4CAF50';
            
            // Rebuild tile reference grid
            buildTileReference();
            
            // Run a test pattern to show the new transition
            generateTestForCurrentTransition();
            
            console.log(`Switched to ${trans.name} transition`);
        };
        
        // Save mappings for a specific transition
        function saveTileMappingsForTransition(transKey, silent = false) {
            ALL_TRANSITIONS[transKey].mapping = { ...EDITABLE_TILE_DATA };
            localStorage.setItem(`uoTiles_${transKey}`, JSON.stringify(EDITABLE_TILE_DATA));
            if (!silent) {
                document.getElementById('transitionStatus').textContent = `ğŸ’¾ ${ALL_TRANSITIONS[transKey].name} saved!`;
                document.getElementById('transitionStatus').style.color = '#4CAF50';
            }
        }
        
        // Generate test pattern for current transition
        window.generateTestForCurrentTransition = async function() {
            const trans = ALL_TRANSITIONS[currentTransition];
            document.getElementById('status').textContent = `Testing ${trans.name} transition...`;
            
            // For cliff types, use Plateau test
            if (currentTransition === 'rock_cliff_land' || 
                currentTransition === 'grass_embank_water' || 
                currentTransition === 'sand_embank_water') {
                return generatePlateauTestMap(trans);
            }
            
            try {
                const width = 20;
                const height = 20;
                
                // Generate diagonal test
                const corners = [];
                for (let cy = 0; cy <= height; cy++) {
                    corners[cy] = [];
                    for (let cx = 0; cx <= width; cx++) {
                        corners[cy][cx] = { biome: (cx > cy) ? trans.biomeB : trans.biomeA };
                    }
                }
                
                const map = [];
                const caseCounts = {};
                
                for (let y = 0; y < height; y++) {
                    map[y] = [];
                    for (let x = 0; x < width; x++) {
                        const tl = corners[y][x].biome === trans.biomeB ? 1 : 0;
                        const tr = corners[y][x + 1].biome === trans.biomeB ? 1 : 0;
                        const bl = corners[y + 1][x].biome === trans.biomeB ? 1 : 0;
                        const br = corners[y + 1][x + 1].biome === trans.biomeB ? 1 : 0;
                        
                        const caseIndex = (tl << 3) | (tr << 2) | (br << 1) | bl;
                        caseCounts[caseIndex] = (caseCounts[caseIndex] || 0) + 1;
                        
                        const tileId = EDITABLE_TILE_DATA[caseIndex];
                        
                        map[y][x] = {
                            biome: caseIndex === 0 ? trans.biomeA : (caseIndex === 15 ? trans.biomeB : 'transition'),
                            id: tileId,
                            caseIndex: caseIndex,
                            x: x,
                            y: y
                        };
                    }
                }
                
                currentMap = map;
                await renderMap(map);
                
                document.getElementById('status').textContent = `âœ… ${trans.name} diagonal test - Cases: ${JSON.stringify(caseCounts)}`;
            } catch (error) {
                console.error(error);
                document.getElementById('status').textContent = `âŒ Error: ${error.message}`;
            }
        };
        
        // Generate a PLATEAU test map for cliffs (High center, Low edges)
        window.generatePlateauTestMap = async function(trans) {
            const width = 20;
            const height = 20;
            const map = [];
            
            // 5x5 Plateau in center
            const plateauX = 7;
            const plateauY = 7;
            const plateauW = 6;
            const plateauH = 6;
            
            // Generate corners first (Marching Squares needs corners)
            const corners = [];
            for (let cy = 0; cy <= height; cy++) {
                corners[cy] = [];
                for (let cx = 0; cx <= width; cx++) {
                    // Inside plateau = A (High), Outside = B (Low)
                    const isPlateau = cx >= plateauX && cx <= plateauX + plateauW && 
                                      cy >= plateauY && cy <= plateauY + plateauH;
                    
                    corners[cy][cx] = { biome: isPlateau ? trans.biomeA : trans.biomeB };
                }
            }
            
            // Generate tiles from corners
            for (let y = 0; y < height; y++) {
                map[y] = [];
                for (let x = 0; x < width; x++) {
                    const tl = corners[y][x].biome === trans.biomeB ? 1 : 0;
                    const tr = corners[y][x + 1].biome === trans.biomeB ? 1 : 0;
                    const bl = corners[y + 1][x].biome === trans.biomeB ? 1 : 0;
                    const br = corners[y + 1][x + 1].biome === trans.biomeB ? 1 : 0;
                    
                    const caseIndex = (tl << 3) | (tr << 2) | (br << 1) | bl;
                    
                    // Use current editable mapping
                    let tileId = EDITABLE_TILE_DATA[caseIndex];
                    
                    let z = 0;
                    // Elevation: Center is high (20), Outside is low (0)
                    if (caseIndex === 0) { // All A (High)
                        z = 20;
                    } else if (caseIndex === 15) { // All B (Low)
                        z = 0;
                    } else {
                        z = 10; // Cliff edge mid-point
                    }
                    
                    map[y][x] = {
                        biome: caseIndex === 0 ? trans.biomeA : (caseIndex === 15 ? trans.biomeB : 'transition'),
                        id: tileId,
                        caseIndex: caseIndex,
                        x: x,
                        y: y,
                        z: z,
                        moisture: 0.5,
                        elevation: z / 20
                    };
                }
            }
            
            currentMap = map;
            await renderMap(map);
            document.getElementById('status').textContent = `âœ… ${trans.name} Plateau Test - High Center, Low Edges`;
        };
        
        // Export ALL transitions as one JSON
        window.exportAllTransitions = function() {
            // Save current first
            saveTileMappingsForTransition(currentTransition, true);
            
            const exportData = {};
            for (const [key, trans] of Object.entries(ALL_TRANSITIONS)) {
                exportData[key] = {
                    name: trans.name,
                    biomeA: trans.biomeA,
                    biomeB: trans.biomeB,
                    mapping: trans.mapping
                };
            }
            
            const json = JSON.stringify(exportData, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'uo_all_transitions.json';
            a.click();
            URL.revokeObjectURL(url);
            
            document.getElementById('transitionStatus').textContent = 'ğŸ“¦ All transitions exported!';
        };
        
        window.toggleTileTeacher = function() {
            tileTeacherVisible = !tileTeacherVisible;
            document.getElementById('tileTeacher').style.display = tileTeacherVisible ? 'block' : 'none';
            if (tileTeacherVisible) {
                buildTileReference();
                // Add click listener to canvas
                setupCanvasClickHandler();
            }
        };
        
        window.setSelectionMode = function(mode) {
            selectionMode = mode;
            selectedDiag1 = null;
            selectedDiag2 = null;
            selectedCase = null;
            
            // Update button styles
            document.getElementById('btnDiag1').style.background = mode === 'diag1' ? '#FF9800' : '#444';
            document.getElementById('btnDiag2').style.background = mode === 'diag2' ? '#FF9800' : '#444';
            document.getElementById('btnCase').style.background = mode === 'case' ? '#FF9800' : '#444';
            
            document.getElementById('selectionInfo').textContent = 'Click a tile on the map...';
        };
        
        let canvasClickHandlerAdded = false;
        function setupCanvasClickHandler() {
            if (canvasClickHandlerAdded) return;
            canvasClickHandlerAdded = true;
            
            const canvas = document.getElementById('canvas');
            canvas.addEventListener('click', function(e) {
                if (!tileTeacherVisible || !currentMap) return;
                
                const rect = canvas.getBoundingClientRect();
                // Get click position relative to container
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;
                
                // CRITICAL: Account for viewport transform (pan and zoom)
                const canvasX = (clickX - viewportX) / viewportZoom;
                const canvasY = (clickY - viewportY) / viewportZoom;
                
                const height = currentMap.length;
                const width = currentMap[0].length;
                const tileWidth = 44;
                const tileHeight = 44;
                const halfWidth = tileWidth / 2;
                const halfHeight = tileHeight / 2;
                const canvasWidth = (width + height) * halfWidth + tileWidth;
                
                // MUST match rendering offsets
                const pixelsPerZ = 2;
                const maxZ = 15;
                const yOffset = maxZ * pixelsPerZ;  // 30 pixels - same as rendering
                
                // Convert screen coordinates to isometric tile coordinates
                // Reverse the rendering formula:
                // screenX = (x - y) * halfWidth + (canvasWidth / 2) - halfWidth
                // screenY = (x + y) * halfHeight + yOffset
                
                const adjustedX = canvasX - (canvasWidth / 2) + halfWidth;
                const adjustedY = canvasY - yOffset;  // Remove the yOffset that rendering adds
                
                // Solve for x and y:
                // adjustedX = (x - y) * halfWidth
                // adjustedY = (x + y) * halfHeight
                // 
                // adjustedX / halfWidth = x - y
                // adjustedY / halfHeight = x + y
                // 
                // x = (adjustedX/halfWidth + adjustedY/halfHeight) / 2
                // y = (adjustedY/halfHeight - adjustedX/halfWidth) / 2
                
                const tileX = Math.floor((adjustedX / halfWidth + adjustedY / halfHeight) / 2);
                const tileY = Math.floor((adjustedY / halfHeight - adjustedX / halfWidth) / 2);
                
                console.log(`Click at screen (${clickX.toFixed(0)}, ${clickY.toFixed(0)}) -> tile (${tileX}, ${tileY})`);
                
                // Check bounds
                if (tileX >= 0 && tileX < width && tileY >= 0 && tileY < height) {
                    const tile = currentMap[tileY][tileX];
                    
                    if (selectionMode === 'diag1') {
                        selectedDiag1 = tileX - tileY;
                        document.getElementById('selectionInfo').textContent = 
                            `Selected Diagonal â†— (x-y=${selectedDiag1}). Click a tile below to replace.`;
                    } else if (selectionMode === 'diag2') {
                        selectedDiag2 = tileX + tileY;
                        document.getElementById('selectionInfo').textContent = 
                            `Selected Diagonal â†˜ (x+y=${selectedDiag2}). Click a tile below to replace.`;
                    } else if (selectionMode === 'case') {
                        selectedCase = tile.caseIndex;
                        document.getElementById('selectionInfo').textContent = 
                            `Selected Case ${selectedCase} (${EDITABLE_TILE_DATA[selectedCase]}). Click a tile below to replace.`;
                    }
                    
                    // Re-render with highlight
                    renderWithHighlight();
                }
            });
        }

        // ==========================================
        // PATTERN DESIGNER (STITCHER) LOGIC
        // ==========================================
        let currentStitchTile = null;
        let stitchGridState = new Array(16).fill(null);
        
        window.togglePatternDesigner = function() {
            const panel = document.getElementById('patternDesigner');
            const isVisible = panel.style.display !== 'none';
            panel.style.display = isVisible ? 'none' : 'block';
            
            if (!isVisible) {
                initPatternDesigner();
            }
        };
        
        window.initPatternDesigner = function() {
            // 1. Populate Palette with ALL Rock/Mountain tiles
            const palette = document.getElementById('stitchPalette');
            palette.innerHTML = '';
            palette.style.gridTemplateColumns = 'repeat(6, 44px)'; // Wider grid for more tiles
            palette.style.width = '300px'; // Wider container
            
            // Define all rock ranges found in LandData.csv
            const rockRanges = [
                // Mountain Rock (The ones we had)
                { start: 0x01D3, end: 0x01DA, name: 'Mountain' },
                // Grey Rock (Basic)
                { start: 0x00E4, end: 0x00E7, name: 'Grey Rock 1' },
                { start: 0x00F4, end: 0x00F7, name: 'Grey Rock 2' },
                { start: 0x0104, end: 0x0107, name: 'Grey Rock 3' },
                { start: 0x0110, end: 0x0113, name: 'Grey Rock 4' },
                // Cave/Dungeon Rock
                { start: 0x021F, end: 0x0238, name: 'Cave Rock' },
                // Dark Rock
                { start: 0x06CD, end: 0x06DE, name: 'Dark Rock' }
            ];
            
            // Helper to format hex ID
            const toHex = (num) => '0x' + num.toString(16).toUpperCase().padStart(4, '0');
            
            rockRanges.forEach(range => {
                // Add separator/header
                const header = document.createElement('div');
                header.style.gridColumn = '1 / -1';
                header.style.color = '#888';
                header.style.fontSize = '10px';
                header.style.marginTop = '5px';
                header.innerText = range.name;
                palette.appendChild(header);
                
                // Add tiles
                for (let id = range.start; id <= range.end; id++) {
                    const hexId = toHex(id);
                    
                    const div = document.createElement('div');
                    div.className = 'palette-tile';
                    div.style.width = '40px'; // Smaller tiles to fit more
                    div.style.height = '40px';
                    div.onclick = () => selectStitchTile(hexId, div);
                    
                    const img = document.createElement('img');
                    img.src = `assets/tiles/${hexId}.bmp`;
                    div.appendChild(img);
                    
                    // Tooltip instead of label for space
                    div.title = hexId;
                    
                    palette.appendChild(div);
                }
            });
            
            // 2. Initialize Grid
            renderStitchGrid();
        };
        
        window.selectStitchTile = function(id, element) {
            currentStitchTile = id;
            document.getElementById('currentStitchTileDisplay').innerText = id;
            
            // Highlight selection
            const tiles = document.querySelectorAll('#stitchPalette .palette-tile');
            tiles.forEach(t => t.style.borderColor = '#444');
            element.style.borderColor = '#FF9800';
        };
        
        window.renderStitchGrid = function() {
            const grid = document.getElementById('stitchGrid');
            grid.innerHTML = '';
            
            stitchGridState.forEach((tileId, index) => {
                const cell = document.createElement('div');
                cell.style.width = '64px';
                cell.style.height = '64px';
                cell.style.border = '1px solid #333';
                cell.style.cursor = 'pointer';
                cell.style.background = '#111';
                cell.onclick = () => paintStitchCell(index);
                
                if (tileId) {
                    const img = document.createElement('img');
                    img.src = `assets/tiles/${tileId}.bmp`;
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.imageRendering = 'pixelated';
                    cell.appendChild(img);
                }
                
                grid.appendChild(cell);
            });
        };
        
        window.paintStitchCell = function(index) {
            if (!currentStitchTile) return;
            stitchGridState[index] = currentStitchTile;
            renderStitchGrid();
        };
        
        window.clearStitchGrid = function() {
            stitchGridState = new Array(16).fill(null);
            renderStitchGrid();
        };
        
        window.applyStitchPattern = async function() {
            console.log('Applying Stitch Pattern...');
            document.getElementById('status').textContent = 'Generating...';
            
            // Convert flat array to 4x4 matrix
            const pattern = [];
            let hasData = false;
            for (let y = 0; y < 4; y++) {
                pattern[y] = [];
                for (let x = 0; x < 4; x++) {
                    const val = stitchGridState[y * 4 + x];
                    pattern[y][x] = val || '0x01D3'; 
                    if (val) hasData = true;
                }
            }
            
            console.log('Pattern to apply:', pattern);
            
            try {
                const genV2 = new TerrainGeneratorV2(12345);
                const map = genV2.generateCliffTestMap(40, 40, 'custom_pattern', pattern);
                currentMap = map;
                await renderMap(map);
                
                document.getElementById('status').textContent = 'âœ… Custom Stitch Pattern Applied! (Scroll up)';
                
                // Scroll to map
                const canvas = document.getElementById('canvas');
                if(canvas) canvas.scrollIntoView({behavior: 'smooth', block: 'center'});
                
            } catch (e) {
                console.error(e);
                document.getElementById('status').textContent = 'âŒ Error: ' + e.message;
                alert('Error: ' + e.message);
            }
        };
        
        async function renderWithHighlight() {
            if (!currentMap) return;
            await renderMap(currentMap);
            
            // Draw highlights over selected tiles
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const height = currentMap.length;
            const width = currentMap[0].length;
            const tileWidth = 44;
            const halfWidth = tileWidth / 2;
            const halfHeight = tileWidth / 2;
            // Use the same canvas width formula as the rendering
            const canvasWidth = (width + height) * halfWidth + tileWidth;
            
            // MUST match rendering offsets
            const pixelsPerZ = 2;
            const maxZ = 15;
            const yOffset = maxZ * pixelsPerZ;  // 30 pixels - same as rendering
            
            ctx.strokeStyle = '#ff0';
            ctx.lineWidth = 2;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const tile = currentMap[y][x];
                    let highlight = false;
                    
                    if (selectionMode === 'diag1' && selectedDiag1 !== null && (x - y) === selectedDiag1) highlight = true;
                    else if (selectionMode === 'diag2' && selectedDiag2 !== null && (x + y) === selectedDiag2) highlight = true;
                    else if (selectionMode === 'case' && selectedCase !== null && tile.caseIndex === selectedCase) highlight = true;
                    
                    if (highlight) {
                        const screenX = (x - y) * halfWidth + (canvasWidth / 2) - halfWidth;
                        const screenY = (x + y) * halfHeight + yOffset;  // Add yOffset to match rendering
                        
                        // Draw diamond outline
                        ctx.beginPath();
                        ctx.moveTo(screenX + halfWidth, screenY + 2);
                        ctx.lineTo(screenX + tileWidth - 2, screenY + halfHeight);
                        ctx.lineTo(screenX + halfWidth, screenY + tileWidth - 2);
                        ctx.lineTo(screenX + 2, screenY + halfHeight);
                        ctx.closePath();
                        ctx.stroke();
                    }
                }
            }
        }
        
        function replaceTile(newTileId) {
            if (selectionMode === 'diag1' && selectedDiag1 === null) return;
            if (selectionMode === 'diag2' && selectedDiag2 === null) return;
            if (selectionMode === 'case' && selectedCase === null) return;
            
            // Update all matching tiles
            for (let y = 0; y < currentMap.length; y++) {
                for (let x = 0; x < currentMap[0].length; x++) {
                    const tile = currentMap[y][x];
                    let match = false;
                    
                    if (selectionMode === 'diag1' && (x - y) === selectedDiag1) match = true;
                    else if (selectionMode === 'diag2' && (x + y) === selectedDiag2) match = true;
                    else if (selectionMode === 'case' && tile.caseIndex === selectedCase) match = true;
                    
                    if (match) {
                        // Update the mapping for this case
                        EDITABLE_TILE_DATA[tile.caseIndex] = newTileId;
                        // Update the tile's id
                        tile.id = newTileId;
                    }
                }
            }
            
            // Refresh UI
            buildTileReference();
            renderWithHighlight();
            
            // Auto-save to the CORRECT per-transition key (not the old single key!)
            saveTileMappingsForTransition(currentTransition, true);  // true = silent
            
            document.getElementById('selectionInfo').textContent = 
                `Replaced with ${newTileId}. Click another tile to continue.`;
        }
        
        async function buildTileReference() {
            const caseGrid = document.getElementById('caseGrid');
            const allTilesGrid = document.getElementById('allTilesGrid');
            
            caseGrid.innerHTML = '';
            allTilesGrid.innerHTML = '';
            
            // Get current transition info
            const trans = ALL_TRANSITIONS[currentTransition];
            
            // Show 16 marching squares cases
            for (let c = 0; c < 16; c++) {
                const tileId = EDITABLE_TILE_DATA[c];
                const card = document.createElement('div');
                card.style.cssText = 'background: #2a2a4e; border-radius: 4px; padding: 3px; text-align: center; cursor: pointer;';
                card.innerHTML = `
                    <div style="color: #ff0; font-size: 10px;">Case ${c}</div>
                    <img src="assets/tiles/${tileId.toUpperCase()}.bmp" style="width: 40px; height: 40px; image-rendering: pixelated;" onerror="this.style.display='none'">
                    <div style="color: #aaa; font-size: 9px;">${tileId}</div>
                `;
                card.onclick = () => replaceTile(tileId);
                card.onmouseover = () => card.style.background = '#3a3a6e';
                card.onmouseout = () => card.style.background = '#2a2a4e';
                caseGrid.appendChild(card);
            }
            
            // Build tile list from transition's tile ranges
            const transitionTiles = [];
            
            // Add tiles from the defined ranges for this transition
            if (trans.tileRanges) {
                for (const [start, end] of trans.tileRanges) {
                    for (let i = start; i <= end; i++) {
                        const hex = '0x' + i.toString(16).toUpperCase().padStart(4, '0');
                        transitionTiles.push(hex);
                    }
                }
            }
            
            // Also add any tiles currently in the mapping that aren't in ranges
            for (let c = 0; c < 16; c++) {
                const tileId = EDITABLE_TILE_DATA[c];
                if (tileId && !transitionTiles.includes(tileId.toUpperCase())) {
                    transitionTiles.push(tileId.toUpperCase());
                }
            }
            
            // Update tile count
            document.getElementById('tileCount').textContent = transitionTiles.length;
            
            for (const tileId of transitionTiles) {
                const card = document.createElement('div');
                card.style.cssText = 'background: #222; border-radius: 3px; padding: 4px; text-align: center; cursor: pointer;';
                card.innerHTML = `
                    <img src="assets/tiles/${tileId.toUpperCase()}.bmp" style="width: 40px; height: 40px; image-rendering: pixelated;" onerror="this.parentElement.style.display='none'">
                    <div style="color: #aaa; font-size: 9px;">${tileId.toLowerCase()}</div>
                `;
                card.onclick = () => replaceTile(tileId.toLowerCase());
                card.onmouseover = () => card.style.background = '#444';
                card.onmouseout = () => card.style.background = '#222';
                allTilesGrid.appendChild(card);
            }
        }
        
        window.saveTileMappings = function() {
            saveTileMappingsForTransition(currentTransition, false);
            console.log(`Saved ${currentTransition} tile mappings:`, EDITABLE_TILE_DATA);
            document.getElementById('selectionInfo').textContent = `âœ… ${ALL_TRANSITIONS[currentTransition].name} mappings saved!`;
        };
        
        window.resetTileMappings = function() {
            // Reset to original defaults for this transition
            const originalDefaults = {
                grass_sand: ALL_TRANSITIONS.grass_sand.mapping,
                grass_water: ALL_TRANSITIONS.grass_water.mapping,
                // ... etc - we'll use the hardcoded defaults
            };
            
            // Reset EDITABLE_TILE_DATA to defaults
            const trans = ALL_TRANSITIONS[currentTransition];
            for (let i = 0; i < 16; i++) {
                EDITABLE_TILE_DATA[i] = DEFAULT_TILE_DATA[i];
            }
            localStorage.removeItem(`uoTiles_${currentTransition}`);
            buildTileReference();
            if (currentMap) {
                // Re-apply default mappings to current map
                for (let y = 0; y < currentMap.length; y++) {
                    for (let x = 0; x < currentMap[0].length; x++) {
                        const tile = currentMap[y][x];
                        if (tile.caseIndex !== undefined) {
                            tile.id = EDITABLE_TILE_DATA[tile.caseIndex];
                        }
                    }
                }
                renderWithHighlight();
            }
            document.getElementById('selectionInfo').textContent = `ğŸ”„ ${trans.name} mappings reset to defaults!`;
        };
        
        window.exportTileMappings = function() {
            const trans = ALL_TRANSITIONS[currentTransition];
            const exportData = {
                transition: currentTransition,
                name: trans.name,
                biomeA: trans.biomeA,
                biomeB: trans.biomeB,
                mapping: EDITABLE_TILE_DATA
            };
            const json = JSON.stringify(exportData, null, 2);
            console.log(`Current ${trans.name} mappings:\n`, json);
            navigator.clipboard.writeText(json).then(() => {
                document.getElementById('selectionInfo').textContent = `ğŸ“‹ ${trans.name} mappings copied to clipboard!`;
            });
        };
        
        // Load saved mappings on page load
        loadTileMappings();
        
        // ============================================
        // END TILE TEACHING SYSTEM
        // ============================================

        // DIAGONAL TEST - Simple grass/sand diagonal to verify core rendering
        // If this diagonal is smooth, the core system works!
        // Test: Pure grass 2x2 - if seams appear, tessellation is broken
        window.testPureGrass2x2 = async function() {
            document.getElementById('status').textContent = 'Testing Pure Grass 2x2...';
            
            try {
                const map = [];
                for (let y = 0; y < 2; y++) {
                    map[y] = [];
                    for (let x = 0; x < 2; x++) {
                        map[y][x] = { biome: 'grass', id: '0x0003', x: x, y: y };
                    }
                }
                
                currentMap = map;
                await renderMap(map);
                
                document.getElementById('status').textContent = 'âœ… Pure Grass 2x2 - If seams visible, tessellation is broken!';
            } catch (error) {
                console.error(error);
                document.getElementById('status').textContent = `âŒ Error: ${error.message}`;
            }
        };
        
        // ===========================================
        // TEST PATTERN GENERATORS
        // ===========================================
        
        // Helper function to generate map from corners
        async function generateMapFromCorners(corners, width, height, testName) {
            const map = [];
            const caseCounts = {};
            
            for (let y = 0; y < height; y++) {
                map[y] = [];
                for (let x = 0; x < width; x++) {
                    // Get the 4 corners of this tile
                    const tl = corners[y][x].biome === 'sand' ? 1 : 0;
                    const tr = corners[y][x + 1].biome === 'sand' ? 1 : 0;
                    const bl = corners[y + 1][x].biome === 'sand' ? 1 : 0;
                    const br = corners[y + 1][x + 1].biome === 'sand' ? 1 : 0;
                    
                    // Calculate case index: TL=8, TR=4, BR=2, BL=1
                    const caseIndex = (tl << 3) | (tr << 2) | (br << 1) | bl;
                    
                    // Track cases
                    caseCounts[caseIndex] = (caseCounts[caseIndex] || 0) + 1;
                    
                    // Get tile ID from EDITABLE mapping (can be modified by Tile Teacher)
                    const tileId = EDITABLE_TILE_DATA[caseIndex];
                    
                    map[y][x] = {
                        biome: caseIndex === 0 ? 'grass' : (caseIndex === 15 ? 'sand' : 'transition'),
                        id: tileId,
                        caseIndex: caseIndex,
                        x: x,
                        y: y
                    };
                }
            }
            
            currentMap = map;
            await renderMap(map);
            
            console.log(`${testName} Case Counts:`, caseCounts);
            return caseCounts;
        }
        
        // DIAGONAL 1: cx > cy diagonal (sand on right)
        // Tests smooth diagonal transitions (cases 4, 7, 14 along edge)
        window.generateTestDiagonal1 = async function() {
            document.getElementById('status').textContent = 'Generating Diagonal 1 (cx > cy)...';
            selectionMode = 'diag1';
            
            try {
                const width = 20;
                const height = 20;
                
                const corners = [];
                for (let cy = 0; cy <= height; cy++) {
                    corners[cy] = [];
                    for (let cx = 0; cx <= width; cx++) {
                        corners[cy][cx] = { biome: (cx > cy) ? 'sand' : 'grass' };
                    }
                }
                
                const caseCounts = await generateMapFromCorners(corners, width, height, 'Diagonal 1');
                document.getElementById('status').textContent = `âœ… Diagonal 1 (cx > cy) - Cases: ${JSON.stringify(caseCounts)}`;
            } catch (error) {
                console.error(error);
                document.getElementById('status').textContent = `âŒ Error: ${error.message}`;
            }
        };
        
        // DIAGONAL 2: cx + cy > width diagonal (sand on bottom-right)
        // Tests opposite angle diagonal (different case distribution)
        window.generateTestDiagonal2 = async function() {
            document.getElementById('status').textContent = 'Generating Diagonal 2 (cx + cy > width)...';
            selectionMode = 'diag2';
            
            try {
                const width = 20;
                const height = 20;
                
                const corners = [];
                for (let cy = 0; cy <= height; cy++) {
                    corners[cy] = [];
                    for (let cx = 0; cx <= width; cx++) {
                        corners[cy][cx] = { biome: (cx + cy > width) ? 'sand' : 'grass' };
                    }
                }
                
                const caseCounts = await generateMapFromCorners(corners, width, height, 'Diagonal 2');
                document.getElementById('status').textContent = `âœ… Diagonal 2 (cx + cy > width) - Cases: ${JSON.stringify(caseCounts)}`;
            } catch (error) {
                console.error(error);
                document.getElementById('status').textContent = `âŒ Error: ${error.message}`;
            }
        };
        
        // OUTER CORNERS: Small sand squares in grass (tests cases 1, 2, 4, 8)
        // Sand "pokes into" grass from one corner
        window.generateTestOuterCorners = async function() {
            document.getElementById('status').textContent = 'Generating Outer Corners test...';
            selectionMode = 'case';
            selectedCase = null;
            
            try {
                const width = 20;
                const height = 20;
                
                const corners = [];
                for (let cy = 0; cy <= height; cy++) {
                    corners[cy] = [];
                    for (let cx = 0; cx <= width; cx++) {
                        const inSquare = (cx % 4 >= 1 && cx % 4 <= 2) && (cy % 4 >= 1 && cy % 4 <= 2);
                        corners[cy][cx] = { biome: inSquare ? 'sand' : 'grass' };
                    }
                }
                
                const caseCounts = await generateMapFromCorners(corners, width, height, 'Outer Corners');
                document.getElementById('status').textContent = `âœ… Outer Corners (sand in grass) - Cases: ${JSON.stringify(caseCounts)}`;
            } catch (error) {
                console.error(error);
                document.getElementById('status').textContent = `âŒ Error: ${error.message}`;
            }
        };
        
        // INNER CORNERS: Small grass squares in sand (tests cases 7, 11, 13, 14)
        // Grass "pokes into" sand from one corner
        window.generateTestInnerCorners = async function() {
            document.getElementById('status').textContent = 'Generating Inner Corners test...';
            selectionMode = 'case';
            selectedCase = null;
            
            try {
                const width = 20;
                const height = 20;
                
                const corners = [];
                for (let cy = 0; cy <= height; cy++) {
                    corners[cy] = [];
                    for (let cx = 0; cx <= width; cx++) {
                        const inSquare = (cx % 4 >= 1 && cx % 4 <= 2) && (cy % 4 >= 1 && cy % 4 <= 2);
                        corners[cy][cx] = { biome: inSquare ? 'grass' : 'sand' };  // INVERTED from outer
                    }
                }
                
                const caseCounts = await generateMapFromCorners(corners, width, height, 'Inner Corners');
                document.getElementById('status').textContent = `âœ… Inner Corners (grass in sand) - Cases: ${JSON.stringify(caseCounts)}`;
            } catch (error) {
                console.error(error);
                document.getElementById('status').textContent = `âŒ Error: ${error.message}`;
            }
        };
        
        // Keep old function name for backwards compatibility
        window.generateDiagonalTest = window.generateTestDiagonal1;

        // Render map to canvas
        async function renderMap(map) {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const width = map[0].length;
            const height = map.length;
            
            const renderMode = 'isometric'; // Always use isometric mode
            const tileWidth = 44;
            const tileHeight = 44;
            
            // UO uses 22 pixel spacing (half tile) for isometric
            const halfWidth = tileWidth / 2;  // 22
            const halfHeight = tileHeight / 2; // 22
            
            let canvasWidth, canvasHeight;
            
            // UO-style Z-height rendering: pixels per Z unit
            // Reduced from 4 to 2 for subtler effect that tessellates better
            const pixelsPerZ = 2;  // Each Z unit = 2 pixels up
            const maxZ = 15;       // Max Z-height in our system (reduced for smoother terrain)
            
            if (renderMode === 'isometric') {
                // Isometric (diamond) layout - UO style
                // Canvas needs to fit the full isometric projection
                // Width: spans from leftmost tile to rightmost tile
                // Height: spans from top tile to bottom tile + extra for Z-height
                canvasWidth = (width + height) * halfWidth + tileWidth;
                canvasHeight = (width + height) * halfWidth + tileHeight + (maxZ * pixelsPerZ);
            } else {
                // Simple square grid
                canvasWidth = width * tileWidth;
                canvasHeight = height * tileHeight;
            }
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            // Configure canvas for pixel-perfect rendering
            ctx.imageSmoothingEnabled = false;
            ctx.imageSmoothingQuality = 'low';

            // UO uses BLACK background - tiles sit on black and overlap each other
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            document.getElementById('status').textContent = 'Loading tile images...';

            let loadedCount = 0;
            let fallbackCount = 0;

            if (renderMode === 'isometric') {
                // UO-style isometric rendering
                // UO tiles are 44x44 BMPs with a diamond inside
                // The diamond is 44 wide x 44 tall (point to point)
                // For proper tessellation, tiles must OVERLAP
                // Each tile covers the black corners of adjacent tiles
                
                // Track terrain bounds for viewport centering
                terrainBounds = { 
                    minX: Infinity, minY: Infinity, 
                    maxX: -Infinity, maxY: -Infinity 
                };
                
                // Draw all land tiles (back to front for proper overlap)
                // UO-style Z-height: tiles are offset UP based on their Z value
                // This creates the 3D elevation effect (mountains rise, water sinks)
                for (let row = 0; row < width + height; row++) {
                    for (let x = 0; x < width; x++) {
                        const y = row - x;
                        if (y < 0 || y >= height) continue;
                        
                        const tile = map[y][x];
                        const tileId = tile.id;
                        const tileZ = tile.z || 0;  // UO-style Z-height
                        
                        // Standard isometric coordinates with optional Z-height offset
                        // Higher Z = tile drawn HIGHER on screen (lower screenY)
                        const screenX = (x - y) * halfWidth + (canvasWidth / 2) - halfWidth;
                        const baseScreenY = (x + y) * halfHeight;
                        
                        let screenY;
                        if (enableZHeight) {
                            const zOffset = tileZ * pixelsPerZ;  // Z raises tile up
                            screenY = baseScreenY - zOffset + (maxZ * pixelsPerZ);  // Add maxZ offset to keep tiles in view
                        } else {
                            screenY = baseScreenY + (maxZ * pixelsPerZ);  // Flat rendering (still offset for consistent canvas size)
                        }
                        
                        // Track bounds
                        terrainBounds.minX = Math.min(terrainBounds.minX, screenX);
                        terrainBounds.minY = Math.min(terrainBounds.minY, screenY);
                        terrainBounds.maxX = Math.max(terrainBounds.maxX, screenX + tileWidth);
                        terrainBounds.maxY = Math.max(terrainBounds.maxY, screenY + tileHeight);
                        
                        const processedTile = await loadTileImage(tileId);
                        
                        // DEBUG: Log spacing and tile type (only once)
                        if (x === 0 && y === 0) {
                            console.log('%c=== RENDER DEBUG ===', 'color: lime; font-weight: bold');
                            console.log('Spacing (halfWidth, halfHeight):', halfWidth, halfHeight);
                            console.log('Tile canvas dimensions:', processedTile ? `${processedTile.width}x${processedTile.height}` : 'null');
                            console.log('Draw size (tileWidth, tileHeight):', tileWidth, tileHeight);
                            console.log('ctx.imageSmoothingEnabled:', ctx.imageSmoothingEnabled);
                            console.log('drawImage call: ctx.drawImage(tile, screenX, screenY, 44, 44)');
                            
                            // Check if tile dimensions match draw size
                            if (processedTile && (processedTile.width !== 44 || processedTile.height !== 44)) {
                                console.log('%câŒ TILE SIZE MISMATCH! This breaks tessellation!', 'color: red; font-weight: bold');
                            }
                        }
                        
                        if (processedTile && processedTile.width > 0) {
                            ctx.drawImage(processedTile, screenX, screenY, tileWidth, tileHeight);
                            loadedCount++;
                        } else {
                            // Fallback: draw a diamond shape with biome color
                            const color = biomeColors[tile.biome] || '#444';
                            ctx.fillStyle = color;
                            ctx.beginPath();
                            ctx.moveTo(screenX + halfWidth, screenY); // Top
                            ctx.lineTo(screenX + tileWidth, screenY + halfHeight); // Right
                            ctx.lineTo(screenX + halfWidth, screenY + tileHeight); // Bottom
                            ctx.lineTo(screenX, screenY + halfHeight); // Left
                            ctx.closePath();
                            ctx.fill();
                            fallbackCount++;
                        }
                        
                        // Draw tile ID if enabled
                        if (showTileIds) {
                            const shortId = tileId.replace('0x', '').toUpperCase();
                            ctx.font = 'bold 9px monospace';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            // Draw background for readability
                            ctx.fillStyle = 'rgba(0,0,0,0.7)';
                            ctx.fillRect(screenX + halfWidth - 14, screenY + halfHeight - 6, 28, 12);
                            // Draw text
                            ctx.fillStyle = '#0f0';
                            ctx.fillText(shortId, screenX + halfWidth, screenY + halfHeight);
                            // Also show coordinates below
                            ctx.font = '7px monospace';
                            ctx.fillStyle = '#ff0';
                            ctx.fillText(`${x},${y}`, screenX + halfWidth, screenY + halfHeight + 10);
                        }
                    }
                    
                    if (row % 10 === 0) {
                        document.getElementById('status').textContent = `Rendering... ${Math.floor((row / (width + height)) * 100)}%`;
                    }
                }
            } else {
                // Simple square grid mode
                terrainBounds = { 
                    minX: 0, minY: 0, 
                    maxX: width * tileWidth, maxY: height * tileHeight 
                };
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const tile = map[y][x];
                        const tileId = tile.id;
                        const screenX = x * tileWidth;
                        const screenY = y * tileHeight;
                        
                        // First fill with biome color as background
                        const color = biomeColors[tile.biome] || '#444';
                        ctx.fillStyle = color;
                        ctx.fillRect(screenX, screenY, tileWidth, tileHeight);
                        
                        const processedTile = await loadTileImage(tileId);
                        
                        if (processedTile && processedTile.width > 0) {
                            ctx.drawImage(processedTile, screenX, screenY, tileWidth, tileHeight);
                            loadedCount++;
                        } else {
                            fallbackCount++;
                        }
                    }
                    
                    if (y % 10 === 0) {
                        document.getElementById('status').textContent = `Rendering... ${Math.floor((y / height) * 100)}%`;
                    }
                }
            }

            document.getElementById('status').textContent = `Rendering complete! ${loadedCount} tiles loaded, ${fallbackCount} fallbacks`;
            
            // Auto-center and auto-zoom on terrain after rendering
            setTimeout(() => {
                fitToView();
            }, 100);
        }

        /**
         * SAND TILE ANALYZER
         * Analyzes sand tile images to determine which edges have grass/sand
         * Uses pixel color sampling in each corner region of the isometric diamond
         */
        window.analyzeSandTiles = async function() {
            if (!terrainGenerator) {
                alert('Please load tile data first!');
                return;
            }
            
            document.getElementById('status').textContent = 'Analyzing sand tiles...';
            
            // Get all sand tiles from the terrain generator
            const sandTiles = terrainGenerator.tilesByType['sand'] || [];
            console.log(`Found ${sandTiles.length} sand tiles to analyze`);
            
            if (sandTiles.length === 0) {
                alert('No sand tiles found!');
                return;
            }
            
            const analysisResults = [];
            const tileWidth = 44;
            const tileHeight = 44;
            
            // Sample regions for each corner of the isometric diamond
            // Each region is a small area around the corner point
            const cornerRegions = {
                // North (top corner) - sample around (22, 0-10)
                north: { x: 17, y: 0, w: 10, h: 8 },
                // East (right corner) - sample around (34-43, 17-27)
                east: { x: 36, y: 17, w: 8, h: 10 },
                // South (bottom corner) - sample around (17-27, 36-43)
                south: { x: 17, y: 36, w: 10, h: 8 },
                // West (left corner) - sample around (0-8, 17-27)
                west: { x: 0, y: 17, w: 8, h: 10 }
            };
            
            // Helper: detect if a color is green (grass)
            function isGreenish(r, g, b) {
                // Green dominant, moderate R and B
                return g > 60 && g > r * 1.1 && g > b * 1.1;
            }
            
            // Helper: detect if a color is tan/brown (sand)
            function isSandish(r, g, b) {
                // Tan/brown: R > G > B, all fairly bright
                return r > 100 && g > 80 && r > g * 0.9 && g > b * 1.1;
            }
            
            // Helper: check if pixel is transparent (black was made transparent)
            function isTransparent(r, g, b, a) {
                return a < 50 || (r < 10 && g < 10 && b < 10);
            }
            
            // Analyze a single tile image
            async function analyzeTile(tileId) {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width || tileWidth;
                        canvas.height = img.height || tileHeight;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;
                        
                        // Analyze each corner
                        const edges = {};
                        
                        for (const [corner, region] of Object.entries(cornerRegions)) {
                            let greenCount = 0;
                            let sandCount = 0;
                            let totalSampled = 0;
                            
                            for (let y = region.y; y < region.y + region.h; y++) {
                                for (let x = region.x; x < region.x + region.w; x++) {
                                    if (x >= canvas.width || y >= canvas.height) continue;
                                    
                                    const idx = (y * canvas.width + x) * 4;
                                    const r = data[idx];
                                    const g = data[idx + 1];
                                    const b = data[idx + 2];
                                    const a = data[idx + 3];
                                    
                                    // Skip transparent/black pixels
                                    if (isTransparent(r, g, b, a)) continue;
                                    
                                    totalSampled++;
                                    if (isGreenish(r, g, b)) {
                                        greenCount++;
                                    } else if (isSandish(r, g, b)) {
                                        sandCount++;
                                    }
                                }
                            }
                            
                            // Determine edge type based on ratio
                            if (totalSampled === 0) {
                                edges[corner] = 'unknown';
                            } else if (greenCount > sandCount && greenCount > totalSampled * 0.2) {
                                edges[corner] = 'grass';
                            } else if (sandCount > greenCount && sandCount > totalSampled * 0.2) {
                                edges[corner] = 'sand';
                            } else {
                                edges[corner] = 'mixed';
                            }
                        }
                        
                        // Create a bitmask: N=1, E=2, S=4, W=8 (grass on that edge)
                        let bitmask = 0;
                        if (edges.north === 'grass') bitmask |= 1;
                        if (edges.east === 'grass') bitmask |= 2;
                        if (edges.south === 'grass') bitmask |= 4;
                        if (edges.west === 'grass') bitmask |= 8;
                        
                        resolve({
                            tileId,
                            edges,
                            bitmask,
                            description: describeEdges(edges)
                        });
                    };
                    
                    img.onerror = () => {
                        resolve({
                            tileId,
                            edges: null,
                            bitmask: null,
                            description: 'LOAD FAILED'
                        });
                    };
                    
                    // Format tile ID
                    let hexId = tileId;
                    if (typeof tileId === 'string' && tileId.startsWith('0x')) {
                        hexId = '0x' + tileId.substring(2).toUpperCase().padStart(4, '0');
                    }
                    img.src = `./assets/tiles/${hexId}.bmp`;
                });
            }
            
            // Describe the edge pattern in human-readable form
            function describeEdges(edges) {
                if (!edges) return 'N/A';
                
                const grassEdges = Object.entries(edges)
                    .filter(([k, v]) => v === 'grass')
                    .map(([k]) => k.toUpperCase());
                
                if (grassEdges.length === 0) return 'PURE_SAND';
                if (grassEdges.length === 4) return 'PURE_GRASS';
                
                return 'GRASS_' + grassEdges.join('_');
            }
            
            // Analyze all sand tiles
            for (let i = 0; i < sandTiles.length; i++) {
                const tile = sandTiles[i];
                const result = await analyzeTile(tile.ID);
                analysisResults.push({
                    id: tile.ID,
                    name: tile.Name || tile.name || '',
                    ...result
                });
                
                if (i % 10 === 0) {
                    document.getElementById('status').textContent = `Analyzing... ${i}/${sandTiles.length}`;
                }
            }
            
            // Group results by bitmask
            const byBitmask = {};
            for (const result of analysisResults) {
                if (result.bitmask === null) continue;
                
                if (!byBitmask[result.bitmask]) {
                    byBitmask[result.bitmask] = [];
                }
                byBitmask[result.bitmask].push(result.id);
            }
            
            // Display results
            console.log('=== SAND TILE ANALYSIS RESULTS ===');
            console.log('');
            console.log('By Bitmask (N=1, E=2, S=4, W=8 for grass edges):');
            for (const [mask, tiles] of Object.entries(byBitmask).sort((a, b) => a[0] - b[0])) {
                const maskInt = parseInt(mask);
                const desc = [
                    maskInt & 1 ? 'N' : '',
                    maskInt & 2 ? 'E' : '',
                    maskInt & 4 ? 'S' : '',
                    maskInt & 8 ? 'W' : ''
                ].filter(x => x).join('') || 'PURE_SAND';
                console.log(`  Bitmask ${mask} (${desc}): ${tiles.length} tiles - ${tiles.slice(0, 5).join(', ')}${tiles.length > 5 ? '...' : ''}`);
            }
            
            // Create downloadable mapping
            const mapping = {
                description: 'Sand tile bitmask mapping. Bitmask bits: N=1, E=2, S=4, W=8 (1 = grass on that edge)',
                generatedAt: new Date().toISOString(),
                totalTiles: analysisResults.length,
                byBitmask: byBitmask,
                detailedResults: analysisResults
            };
            
            // Store globally for use
            window.sandTileMapping = mapping;
            
            const blob = new Blob([JSON.stringify(mapping, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `sand_tile_analysis_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            // Show summary
            const summary = Object.entries(byBitmask)
                .map(([mask, tiles]) => {
                    const maskInt = parseInt(mask);
                    const desc = [
                        maskInt & 1 ? 'N' : '',
                        maskInt & 2 ? 'E' : '',
                        maskInt & 4 ? 'S' : '',
                        maskInt & 8 ? 'W' : ''
                    ].filter(x => x).join('') || 'PURE';
                    return `${desc}:${tiles.length}`;
                })
                .join(', ');
            
            document.getElementById('status').textContent = 
                `Analysis complete! ${analysisResults.length} tiles analyzed. Results downloaded. Patterns: ${summary}`;
            
            // Create a visual preview canvas
            showTilePreview(analysisResults.slice(0, 50));
        };
        
        // Show a visual preview of analyzed tiles
        function showTilePreview(results) {
            // Create a preview container if it doesn't exist
            let preview = document.getElementById('tilePreview');
            if (!preview) {
                preview = document.createElement('div');
                preview.id = 'tilePreview';
                preview.style.cssText = 'background:#2a2a2a;padding:15px;margin-top:20px;border-radius:8px;max-height:400px;overflow-y:auto;';
                document.querySelector('.container').appendChild(preview);
            }
            
            preview.innerHTML = '<h3>Sand Tile Analysis (First 50)</h3><div style="display:flex;flex-wrap:wrap;gap:5px;"></div>';
            const grid = preview.querySelector('div');
            
            for (const result of results) {
                const tile = document.createElement('div');
                tile.style.cssText = 'text-align:center;background:#333;padding:5px;border-radius:4px;';
                
                let hexId = result.id;
                if (typeof hexId === 'string' && hexId.startsWith('0x')) {
                    hexId = '0x' + hexId.substring(2).toUpperCase().padStart(4, '0');
                }
                
                tile.innerHTML = `
                    <img src="./assets/tiles/${hexId}.bmp" style="width:44px;height:44px;image-rendering:pixelated;">
                    <div style="font-size:10px;">${hexId}</div>
                    <div style="font-size:9px;color:#888;">${result.description}</div>
                    <div style="font-size:9px;color:#4CAF50;">Mask: ${result.bitmask}</div>
                `;
                grid.appendChild(tile);
            }
        }

        // Export map data
        window.exportMap = function() {
            if (!currentMap) {
                alert('No map generated yet!');
                return;
            }

            const data = {
                width: currentMap[0].length,
                height: currentMap.length,
                tiles: currentMap.map(row => 
                    row.map(tile => ({
                        id: tile.id,
                        name: tile.name,
                        biome: tile.biome
                    }))
                )
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `terrain_map_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);

            document.getElementById('status').textContent = 'âœ… Map exported!';
        };

        // Export for AI Learning - exports ONLY transition tiles with their neighbor context
        // This is the FINAL result after manual editing - clean data for learning
        window.exportForLearning = function() {
            if (!currentMap) {
                alert('No map generated yet!');
                return;
            }

            const width = currentMap[0].length;
            const height = currentMap.length;
            
            // Helper to get tile at position
            const getTile = (x, y) => {
                if (x < 0 || x >= width || y < 0 || y >= height) {
                    return { id: 'OUT_OF_BOUNDS', biome: 'none' };
                }
                return currentMap[y][x];
            };
            
            // Helper to get biome category
            const getBiomeCategory = (tile) => {
                if (!tile || tile.biome === 'none') return 'none';
                if (tile.biome === 'grass' || tile.biome === 'forest' || tile.biome === 'jungle') return 'grass';
                if (tile.biome === 'sand') return 'sand';
                if (tile.biome === 'water') return 'water';
                return tile.biome;
            };
            
            // Collect all transition tiles (tiles at biome boundaries)
            const transitionData = [];
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const tile = currentMap[y][x];
                    const tileCategory = getBiomeCategory(tile);
                    
                    // Get all 8 neighbors
                    const neighbors = {
                        top: getTile(x, y - 1),
                        topRight: getTile(x + 1, y - 1),
                        right: getTile(x + 1, y),
                        bottomRight: getTile(x + 1, y + 1),
                        bottom: getTile(x, y + 1),
                        bottomLeft: getTile(x - 1, y + 1),
                        left: getTile(x - 1, y),
                        topLeft: getTile(x - 1, y - 1)
                    };
                    
                    // Check if this tile is at a boundary (has neighbors of different biome)
                    const neighborCategories = Object.values(neighbors).map(n => getBiomeCategory(n));
                    const hasDifferentNeighbor = neighborCategories.some(nc => nc !== tileCategory && nc !== 'none');
                    
                    if (hasDifferentNeighbor) {
                        // Create neighbor signature for easy lookup
                        const neighborSignature = {
                            T: getBiomeCategory(neighbors.top),
                            TR: getBiomeCategory(neighbors.topRight),
                            R: getBiomeCategory(neighbors.right),
                            BR: getBiomeCategory(neighbors.bottomRight),
                            B: getBiomeCategory(neighbors.bottom),
                            BL: getBiomeCategory(neighbors.bottomLeft),
                            L: getBiomeCategory(neighbors.left),
                            TL: getBiomeCategory(neighbors.topLeft)
                        };
                        
                        transitionData.push({
                            x: x,
                            y: y,
                            tileId: tile.id,
                            tileBiome: tileCategory,
                            neighbors: neighborSignature,
                            // Create a lookup key: "{topNeighbor}_T:{rightNeighbor}_R:{bottomNeighbor}_B:{leftNeighbor}_L:{tileBiome}"
                            lookupKey: `${neighborSignature.T}_T:${neighborSignature.R}_R:${neighborSignature.B}_B:${neighborSignature.L}_L:${tileCategory}`
                        });
                    }
                }
            }
            
            // Group by lookup key to find patterns
            const patterns = {};
            transitionData.forEach(t => {
                if (!patterns[t.lookupKey]) {
                    patterns[t.lookupKey] = [];
                }
                patterns[t.lookupKey].push(t.tileId);
            });
            
            // Create summary of what tile to use for each pattern
            const patternSummary = {};
            Object.keys(patterns).forEach(key => {
                // Get most common tile for this pattern
                const tileCounts = {};
                patterns[key].forEach(id => {
                    tileCounts[id] = (tileCounts[id] || 0) + 1;
                });
                const sortedTiles = Object.entries(tileCounts).sort((a, b) => b[1] - a[1]);
                patternSummary[key] = {
                    recommendedTile: sortedTiles[0][0],
                    allTilesUsed: sortedTiles.map(([id, count]) => ({ id, count }))
                };
            });
            
            const exportData = {
                exportType: 'AI_LEARNING_DATA',
                timestamp: new Date().toISOString(),
                mapSize: { width, height },
                totalTransitionTiles: transitionData.length,
                
                // The key data: what tile to use for each neighbor pattern
                patternToTile: patternSummary,
                
                // Raw data for detailed analysis
                allTransitions: transitionData
            };
            
            // Store in localStorage so it persists AND can be retrieved
            const jsonStr = JSON.stringify(exportData, null, 2);
            localStorage.setItem('ai_learning_export', jsonStr);
            
            // Also download as file for backup
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ai_learning_transitions.json`;  // Fixed name for easy finding
            a.click();
            URL.revokeObjectURL(url);
            
            // Create pattern summary for clipboard
            const summaryText = Object.entries(patternSummary)
                .map(([pattern, data]) => `"${pattern}": "${data.recommendedTile}",`)
                .join('\n');
            
            // Copy to clipboard - this is the format I need!
            navigator.clipboard.writeText(summaryText).then(() => {
                document.getElementById('status').textContent = `âœ… Exported ${transitionData.length} transitions! PASTE THE CLIPBOARD CONTENTS to show me!`;
                alert('âœ… SUCCESS!\n\nThe pattern mappings are now in your clipboard.\n\nJust PASTE (Ctrl+V) in the chat to show me the correct tiles!');
            }).catch(() => {
                document.getElementById('status').textContent = `âœ… Exported ${transitionData.length} transition tiles!`;
            });
            
            console.log('AI Learning Export:', exportData);
            console.log('\n=== COPY THIS TO SHOW ME ===\n', summaryText);
        };

        // Expose loadLandTiles globally for button onclick
        window.loadLandTiles = loadLandTiles;
        
        // Open tile viewer in new window
        window.openTileViewer = function() {
            window.open('tile_viewer.html', 'TileViewer', 'width=1200,height=800');
        };
        
        // Viewport control functions
        function updateViewport() {
            const canvas = document.getElementById('canvas');
            canvas.style.transform = `scale(${viewportZoom})`;
            canvas.style.left = `${viewportX}px`;
            canvas.style.top = `${viewportY}px`;
            document.getElementById('zoomLevel').textContent = `${Math.round(viewportZoom * 100)}%`;
        }
        
        window.zoomIn = function() {
            viewportZoom = Math.min(viewportZoom * 1.25, 5);
            updateViewport();
        };
        
        window.zoomOut = function() {
            viewportZoom = Math.max(viewportZoom / 1.25, 0.25);
            updateViewport();
        };
        
        window.toggleSidebar = function() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('collapsed');
        };
        
        window.resetView = function() {
            viewportZoom = 1;
            viewportX = 0;
            viewportY = 0;
            updateViewport();
        };
        
        window.centerOnTerrain = function() {
            // Center the viewport on the terrain (not the black edges)
            const container = document.getElementById('canvasContainer');
            const canvas = document.getElementById('canvas');
            
            // Check if we're using WebGL canvas
            const webglCanvas = document.getElementById('webgl-canvas');
            if (webglCanvas && webglCanvas.style.display !== 'none') {
                // For WebGL canvas, use scroll-based centering
                const width = parseInt(document.getElementById('width').value) || 50;
                const height = parseInt(document.getElementById('height').value) || 50;
                const maxZ = 50;
                const terrainCenterX = (width + height) * 22 / 2;
                const terrainCenterY = maxZ * 4 + (width + height) * 22 / 2;
                container.scrollLeft = Math.max(0, terrainCenterX - container.clientWidth / 2);
                container.scrollTop = Math.max(0, terrainCenterY - container.clientHeight / 2);
                return;
            }
            
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            // Calculate terrain center based on bounds
            const terrainCenterX = (terrainBounds.minX + terrainBounds.maxX) / 2;
            const terrainCenterY = (terrainBounds.minY + terrainBounds.maxY) / 2;
            
            // Position so terrain center is at viewport center
            viewportX = (containerWidth / 2) - (terrainCenterX * viewportZoom);
            viewportY = (containerHeight / 2) - (terrainCenterY * viewportZoom);
            
            updateViewport();
        };
        
        window.fitToView = function() {
            // Fit the entire terrain into the viewport and CENTER it
            const container = document.getElementById('canvasContainer');
            const webglCanvas = document.getElementById('webgl-canvas');
            
            if (webglCanvas && webglCanvas.style.display !== 'none') {
                // For WebGL canvas, calculate scale to fit entire terrain
                const canvasWidth = webglCanvas.width;
                const canvasHeight = webglCanvas.height;
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;
                
                // Calculate scale to fit with some margin
                const scaleX = containerWidth / canvasWidth;
                const scaleY = containerHeight / canvasHeight;
                const scale = Math.min(scaleX, scaleY) * 0.9;  // 90% to leave margin
                
                // Calculate the scaled dimensions
                const scaledWidth = canvasWidth * scale;
                const scaledHeight = canvasHeight * scale;
                
                // Calculate offset to center the canvas
                const offsetX = (containerWidth - scaledWidth) / 2;
                const offsetY = (containerHeight - scaledHeight) / 2;
                
                // Apply scale and translate to center
                webglCanvas.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
                webglCanvas.style.transformOrigin = 'top left';
                
                // Reset scroll
                container.scrollLeft = 0;
                container.scrollTop = 0;
                
                document.getElementById('zoomLevel').textContent = Math.round(scale * 100) + '%';
                console.log(`Fit to view: scale=${scale.toFixed(2)}, offset=(${offsetX.toFixed(0)}, ${offsetY.toFixed(0)}), canvas=${canvasWidth}x${canvasHeight}, container=${containerWidth}x${containerHeight}`);
            } else {
                // For 2D canvas, use the zoom system
                const canvas = document.getElementById('canvas');
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;
                
                // Calculate terrain dimensions
                const terrainWidth = terrainBounds.maxX - terrainBounds.minX;
                const terrainHeight = terrainBounds.maxY - terrainBounds.minY;
                
                if (terrainWidth > 0 && terrainHeight > 0) {
                    const scaleX = containerWidth / terrainWidth;
                    const scaleY = containerHeight / terrainHeight;
                    viewportZoom = Math.min(scaleX, scaleY) * 0.95;
                    
                    // Center on terrain
                    const terrainCenterX = (terrainBounds.minX + terrainBounds.maxX) / 2;
                    const terrainCenterY = (terrainBounds.minY + terrainBounds.maxY) / 2;
                    viewportX = (containerWidth / 2) - (terrainCenterX * viewportZoom);
                    viewportY = (containerHeight / 2) - (terrainCenterY * viewportZoom);
                    
                    updateViewport();
                }
            }
        };
        
        // Set up drag-to-pan
        document.addEventListener('DOMContentLoaded', () => {
            const container = document.getElementById('canvasContainer');
            
            // Helper to check if WebGL canvas is active
            function isWebGLActive() {
                const webglCanvas = document.getElementById('webgl-canvas');
                return webglCanvas && webglCanvas.style.display !== 'none';
            }
            
            container.addEventListener('mousedown', (e) => {
                isDragging = true;
                if (isWebGLActive()) {
                    // For WebGL, use scroll-based panning
                    dragStartX = e.clientX + container.scrollLeft;
                    dragStartY = e.clientY + container.scrollTop;
                } else {
                    // For 2D canvas, use transform-based panning
                    dragStartX = e.clientX - viewportX;
                    dragStartY = e.clientY - viewportY;
                }
                container.style.cursor = 'grabbing';
            });
            
            container.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                if (isWebGLActive()) {
                    // For WebGL, scroll the container
                    container.scrollLeft = dragStartX - e.clientX;
                    container.scrollTop = dragStartY - e.clientY;
                } else {
                    // For 2D canvas, transform the canvas
                    viewportX = e.clientX - dragStartX;
                    viewportY = e.clientY - dragStartY;
                    updateViewport();
                }
            });
            
            container.addEventListener('mouseup', () => {
                isDragging = false;
                container.style.cursor = 'grab';
            });
            
            container.addEventListener('mouseleave', () => {
                isDragging = false;
                container.style.cursor = 'grab';
            });
            
            // Mouse wheel zoom
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                
                if (isWebGLActive()) {
                    // For WebGL canvas, zoom by scaling the canvas
                    const webglCanvas = document.getElementById('webgl-canvas');
                    const currentTransform = webglCanvas.style.transform || 'scale(1)';
                    const scaleMatch = currentTransform.match(/scale\(([\d.]+)\)/);
                    let currentScale = scaleMatch ? parseFloat(scaleMatch[1]) : 1;
                    
                    if (e.deltaY < 0) {
                        currentScale = Math.min(currentScale * 1.1, 3);
                    } else {
                        currentScale = Math.max(currentScale / 1.1, 0.1);
                    }
                    
                    webglCanvas.style.transform = `scale(${currentScale})`;
                    document.getElementById('zoomLevel').textContent = Math.round(currentScale * 100) + '%';
                } else {
                    // For 2D canvas, use existing zoom logic
                    const rect = container.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    // Zoom towards mouse position
                    const oldZoom = viewportZoom;
                    if (e.deltaY < 0) {
                        viewportZoom = Math.min(viewportZoom * 1.1, 5);
                    } else {
                        viewportZoom = Math.max(viewportZoom / 1.1, 0.25);
                    }
                    
                    // Adjust position to zoom towards mouse
                    const zoomRatio = viewportZoom / oldZoom;
                    viewportX = mouseX - (mouseX - viewportX) * zoomRatio;
                    viewportY = mouseY - (mouseY - viewportY) * zoomRatio;
                    
                    updateViewport();
                }
            });
            
            // Initialize viewport
            updateViewport();
            
            // Set up paint mode click handler
            container.addEventListener('click', handlePaintClick);
        });
        
        // ========================================
        // TILE PALETTE & PAINT MODE
        // ========================================
        
        let paintMode = false;
        let selectedTile = null;
        let paletteLoaded = false;
        
        // Toggle paint palette visibility
        window.togglePalette = function() {
            const palette = document.getElementById('tilePalette');
            palette.classList.toggle('visible');
            
            if (palette.classList.contains('visible') && !paletteLoaded) {
                loadPalette();
            }
        };
        
        // Toggle collapsible sections
        window.toggleSection = function(section, event) {
            // Only toggle if clicking on header, not content
            if (event.target.closest('.section-content')) return;
            section.classList.toggle('open');
        };
        
        // Toggle tile IDs display
        window.toggleTileIds = function() {
            showTileIds = document.getElementById('showTileIds').checked;
            if (currentMap) {
                renderMap(currentMap);
            }
        };
        
        // Toggle Z-height (3D) rendering
        window.toggleZHeight = function() {
            enableZHeight = document.getElementById('enableZHeight').checked;
            if (currentMap) {
                renderMap(currentMap);
            }
        };
        
        // Load tiles into the palette
        async function loadPalette() {
            if (!terrainGenerator) {
                document.getElementById('paletteCategories').innerHTML = '<p style="color:#f44336;">Load tile data first!</p>';
                return;
            }
            
            paletteLoaded = true;
            const categories = document.getElementById('paletteCategories');
            categories.innerHTML = '<p>Loading tiles...</p>';
            
            // Categories to show - prioritize the ones you need for cliffs
            // Added 'statics' category for cliff faces and walls
            const categoryOrder = ['statics', 'slope', 'embank', 'sand', 'grass', 'dirt', 'rock', 'water', 'cave', 'forest'];
            
            // Define static items (cliff faces, walls, etc.)
            // These are OBJECTS placed on top of terrain, not land tiles
            const staticItems = [
                // Cliff faces (rock walls)
                { ID: '0x0080', Name: 'Cliff Face S' },
                { ID: '0x0081', Name: 'Cliff Face E' },
                { ID: '0x0082', Name: 'Cliff Face N' },
                { ID: '0x0083', Name: 'Cliff Face W' },
                // Stone walls
                { ID: '0x0028', Name: 'Stone Wall S' },
                { ID: '0x0029', Name: 'Stone Wall E' },
                { ID: '0x002A', Name: 'Stone Wall N' },
                { ID: '0x002B', Name: 'Stone Wall W' },
                // Cave walls
                { ID: '0x024E', Name: 'Cave Wall S' },
                { ID: '0x024F', Name: 'Cave Wall E' },
                { ID: '0x0250', Name: 'Cave Wall N' },
                { ID: '0x0251', Name: 'Cave Wall W' },
                // Rocks/Boulders
                { ID: '0x0ED3', Name: 'Boulder Large' },
                { ID: '0x0ED4', Name: 'Boulder Medium' },
                { ID: '0x0ED5', Name: 'Boulder Small' },
            ];
            
            // Add statics to terrainGenerator's tilesByType for palette rendering
            if (!terrainGenerator.tilesByType['statics']) {
                terrainGenerator.tilesByType['statics'] = staticItems;
            }
            
            let html = '';
            
            for (const category of categoryOrder) {
                const tiles = terrainGenerator.tilesByType[category] || [];
                if (tiles.length === 0) continue;
                
                // Show ALL tiles - no limit!
                const displayTiles = tiles;
                
                html += `
                    <div class="palette-category">
                        <div class="palette-category-header" onclick="toggleCategory('${category}')">
                            ${category.toUpperCase()} (${tiles.length} tiles)
                        </div>
                        <div class="palette-tiles" id="cat-${category}" style="display:none;">
                `;
                
                for (const tile of displayTiles) {
                    let hexId = tile.ID || tile.id;
                    if (typeof hexId === 'string' && hexId.startsWith('0x')) {
                        hexId = '0x' + hexId.substring(2).toUpperCase().padStart(4, '0');
                    }
                    
                    html += `
                        <div class="palette-tile" onclick="selectTile('${hexId}', '${category}')" data-id="${hexId}">
                            <img src="./assets/tiles/${hexId}.bmp" onerror="this.style.background='#f00'">
                            <div class="tile-id">${hexId}</div>
                        </div>
                    `;
                }
                
                html += '</div></div>';
            }
            
            // Also add a "Recent/Custom" section for manually entered IDs
            html += `
                <div class="palette-category">
                    <div class="palette-category-header">
                        CUSTOM TILE
                    </div>
                    <div style="padding: 10px;">
                        <input type="text" id="customTileId" placeholder="Enter Tile ID (e.g., 0x01BB)" style="width: 100%; margin-bottom: 5px;">
                        <button onclick="selectCustomTile()" style="width: 100%;">Select Custom Tile</button>
                    </div>
                </div>
            `;
            
            categories.innerHTML = html;
            
            // Auto-expand slope category (most important for cliffs)
            toggleCategory('slope');
        }
        
        // Toggle category visibility
        window.toggleCategory = function(category) {
            const el = document.getElementById(`cat-${category}`);
            if (el) {
                el.style.display = el.style.display === 'none' ? 'grid' : 'none';
            }
        };
        
        // Select a tile from the palette
        window.selectTile = function(tileId, category) {
            // Deselect previous
            document.querySelectorAll('.palette-tile.selected').forEach(el => el.classList.remove('selected'));
            
            // Select new
            const el = document.querySelector(`.palette-tile[data-id="${tileId}"]`);
            if (el) el.classList.add('selected');
            
            selectedTile = { id: tileId, category: category };
            paintMode = true;
            
            // Update info panel
            document.getElementById('selectedTileInfo').innerHTML = `
                <img src="./assets/tiles/${tileId}.bmp" style="image-rendering: pixelated;">
                <p><strong>${tileId}</strong></p>
                <p style="font-size: 12px; color: #888;">${category}</p>
                <p style="font-size: 11px; color: #4CAF50;">Click on map to paint!</p>
            `;
            
            // Show paint mode indicator
            document.getElementById('paintModeIndicator').classList.add('visible');
            document.getElementById('canvasContainer').style.cursor = 'crosshair';
        };
        
        // Select custom tile by ID
        window.selectCustomTile = function() {
            const input = document.getElementById('customTileId');
            let tileId = input.value.trim();
            
            if (!tileId) {
                alert('Enter a tile ID!');
                return;
            }
            
            // Normalize to 0xXXXX format
            if (!tileId.startsWith('0x')) {
                tileId = '0x' + tileId;
            }
            tileId = '0x' + tileId.substring(2).toUpperCase().padStart(4, '0');
            
            selectTile(tileId, 'custom');
        };
        
        // Handle click on map to paint tile
        function handlePaintClick(e) {
            if (!paintMode || !selectedTile || !currentMap) return;
            
            // Don't paint if we're dragging
            if (isDragging) return;
            
            const container = document.getElementById('canvasContainer');
            const canvas = document.getElementById('canvas');
            const rect = container.getBoundingClientRect();
            
            // Get click position relative to container
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            
            // Convert to canvas coordinates (accounting for viewport transform)
            const canvasX = (clickX - viewportX) / viewportZoom;
            const canvasY = (clickY - viewportY) / viewportZoom;
            
            const renderMode = 'isometric'; // Always use isometric mode
            const tileWidth = 44;
            const tileHeight = 44;
            const halfWidth = tileWidth / 2;
            const halfHeight = tileHeight / 2;
            
            let mapX, mapY;
            
            if (renderMode === 'isometric') {
                // Convert screen coords to map coords for isometric
                const width = currentMap[0].length;
                const height = currentMap.length;
                const canvasWidth = (width + height) * halfWidth + tileWidth;
                
                // MUST match rendering offsets
                const pixelsPerZ = 2;
                const maxZ = 15;
                const yOffset = maxZ * pixelsPerZ;  // 30 pixels - same as rendering
                
                // Reverse the isometric projection
                // screenX = (x - y) * halfWidth + (canvasWidth / 2) - halfWidth
                // screenY = (x + y) * halfHeight + yOffset
                
                const adjustedX = canvasX - (canvasWidth / 2) + halfWidth;
                const adjustedY = canvasY - yOffset;  // Remove the yOffset that rendering adds
                
                // Solve for x and y:
                // adjustedX = (x - y) * halfWidth
                // adjustedY = (x + y) * halfHeight
                // 
                // adjustedX / halfWidth = x - y
                // adjustedY / halfHeight = x + y
                // 
                // x = (adjustedX/halfWidth + adjustedY/halfHeight) / 2
                // y = (adjustedY/halfHeight - adjustedX/halfWidth) / 2
                
                mapX = Math.floor((adjustedX / halfWidth + adjustedY / halfHeight) / 2);
                mapY = Math.floor((adjustedY / halfHeight - adjustedX / halfWidth) / 2);
            } else {
                // Simple square grid
                mapX = Math.floor(canvasX / tileWidth);
                mapY = Math.floor(canvasY / tileHeight);
            }
            
            // Validate coordinates
            if (mapX < 0 || mapY < 0 || mapY >= currentMap.length || mapX >= currentMap[0].length) {
                console.log(`Click outside map bounds: (${mapX}, ${mapY})`);
                return;
            }
            
            console.log(`Painting tile ${selectedTile.id} at map position (${mapX}, ${mapY}), category: ${selectedTile.category}`);
            
            // Log the correction for learning
            const oldTileId = currentMap[mapY][mapX].id;
            const neighbors = getNeighborInfo(mapX, mapY);
            logPaintCorrection(mapX, mapY, oldTileId, selectedTile.id, neighbors);
            
            // Check if this is a static item or a land tile
            if (selectedTile.category === 'statics') {
                // Add as a static item ON TOP of the land tile
                const currentZ = currentMap[mapY][mapX].z || 0;
                const staticZ = currentZ + 15; // Place static 15 units above current tile
                
                if (!currentMap[mapY][mapX].statics) {
                    currentMap[mapY][mapX].statics = [];
                }
                
                currentMap[mapY][mapX].statics.push({
                    id: selectedTile.id,
                    z: staticZ,
                    painted: true
                });
                
                console.log(`Added static ${selectedTile.id} at Z=${staticZ}`);
            } else {
                // Update the land tile
                currentMap[mapY][mapX].id = selectedTile.id;
                currentMap[mapY][mapX].name = selectedTile.category;
                currentMap[mapY][mapX].painted = true; // Mark as user-painted
            }
            
            // Re-render just this tile (for speed)
            repaintTile(mapX, mapY);
        }
        
        // Repaint a single tile on the canvas (including statics)
        // Instead of partial repaint (which causes black gaps), just re-render the whole map
        async function repaintTile(mapX, mapY) {
            const tile = currentMap[mapY][mapX];
            const staticCount = tile.statics ? tile.statics.length : 0;
            document.getElementById('status').textContent = `Painting at (${mapX}, ${mapY})...`;
            
            // Re-render the entire map to avoid black gaps
            await renderMap(currentMap);
            
            document.getElementById('status').textContent = `Painted ${tile.id} at (${mapX}, ${mapY}) - Statics: ${staticCount}`;
        }
        
        // Exit paint mode with ESC
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && paintMode) {
                paintMode = false;
                selectedTile = null;
                document.querySelectorAll('.palette-tile.selected').forEach(el => el.classList.remove('selected'));
                document.getElementById('paintModeIndicator').classList.remove('visible');
                document.getElementById('canvasContainer').style.cursor = 'grab';
                document.getElementById('selectedTileInfo').innerHTML = '<p>Click a tile to select it</p>';
                clearHoverHighlight();
            }
        });
        
        // ========================================
        // HOVER HIGHLIGHT FOR PAINT MODE
        // ========================================
        
        let hoverHighlightCanvas = null;
        let lastHoverX = -1;
        let lastHoverY = -1;
        
        function initHoverHighlight() {
            // Create overlay canvas for hover highlight
            const container = document.getElementById('canvasContainer');
            hoverHighlightCanvas = document.createElement('canvas');
            hoverHighlightCanvas.id = 'hoverHighlightCanvas';
            hoverHighlightCanvas.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                pointer-events: none;
                image-rendering: pixelated;
                transform-origin: 0 0;
            `;
            container.appendChild(hoverHighlightCanvas);
        }
        
        function updateHoverHighlight(e) {
            if (!paintMode || !currentMap || !hoverHighlightCanvas) return;
            
            const container = document.getElementById('canvasContainer');
            const rect = container.getBoundingClientRect();
            
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            
            const canvasX = (clickX - viewportX) / viewportZoom;
            const canvasY = (clickY - viewportY) / viewportZoom;
            
            const tileWidth = 44;
            const tileHeight = 44;
            const halfWidth = tileWidth / 2;
            const halfHeight = tileHeight / 2;
            
            const width = currentMap[0].length;
            const height = currentMap.length;
            const canvasWidth = (width + height) * halfWidth + tileWidth;
            
            // MUST match rendering offsets
            const pixelsPerZ = 2;
            const maxZ = 15;
            const yOffset = maxZ * pixelsPerZ;  // 30 pixels - same as rendering
            
            const adjustedX = canvasX - (canvasWidth / 2) + halfWidth;
            const adjustedY = canvasY - yOffset;  // Remove the yOffset that rendering adds
            
            const mapX = Math.floor((adjustedX / halfWidth + adjustedY / halfHeight) / 2);
            const mapY = Math.floor((adjustedY / halfHeight - adjustedX / halfWidth) / 2);
            
            // Only redraw if position changed
            if (mapX === lastHoverX && mapY === lastHoverY) return;
            lastHoverX = mapX;
            lastHoverY = mapY;
            
            // Update highlight canvas size to match main canvas
            const mainCanvas = document.getElementById('canvas');
            hoverHighlightCanvas.width = mainCanvas.width;
            hoverHighlightCanvas.height = mainCanvas.height;
            hoverHighlightCanvas.style.transform = `translate(${viewportX}px, ${viewportY}px) scale(${viewportZoom})`;
            
            const ctx = hoverHighlightCanvas.getContext('2d');
            ctx.clearRect(0, 0, hoverHighlightCanvas.width, hoverHighlightCanvas.height);
            
            // Check if valid position
            if (mapX < 0 || mapY < 0 || mapY >= currentMap.length || mapX >= currentMap[0].length) {
                return;
            }
            
            // Draw diamond highlight at hover position
            const screenX = (mapX - mapY) * halfWidth + canvasWidth / 2 - halfWidth;
            const screenY = (mapX + mapY) * halfHeight + yOffset;  // Add yOffset to match rendering
            
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(screenX + halfWidth, screenY);           // Top
            ctx.lineTo(screenX + tileWidth, screenY + halfHeight); // Right
            ctx.lineTo(screenX + halfWidth, screenY + tileHeight); // Bottom
            ctx.lineTo(screenX, screenY + halfHeight);          // Left
            ctx.closePath();
            ctx.stroke();
            
            // Fill with semi-transparent color
            ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
            ctx.fill();
            
            // Show tile info and coordinates
            const tile = currentMap[mapY][mapX];
            document.getElementById('status').textContent = 
                `Hover: (${mapX}, ${mapY}) | Current: ${tile.id} (${tile.biome || tile.name || 'unknown'}) | Will place: ${selectedTile ? selectedTile.id : 'none'}`;
        }
        
        function clearHoverHighlight() {
            if (hoverHighlightCanvas) {
                const ctx = hoverHighlightCanvas.getContext('2d');
                ctx.clearRect(0, 0, hoverHighlightCanvas.width, hoverHighlightCanvas.height);
            }
            lastHoverX = -1;
            lastHoverY = -1;
        }
        
        // Add mousemove listener for hover highlight
        document.getElementById('canvasContainer').addEventListener('mousemove', updateHoverHighlight);
        
        // Initialize hover highlight canvas on load
        setTimeout(initHoverHighlight, 100);
        
        // ========================================
        // CORRECTION LOGGING SYSTEM
        // ========================================
        
        let paintCorrections = [];
        
        // Log correction when user paints a tile
        function logPaintCorrection(mapX, mapY, oldTileId, newTileId, neighbors) {
            const correction = {
                x: mapX,
                y: mapY,
                was: oldTileId,
                shouldBe: newTileId,
                neighbors: neighbors,
                timestamp: new Date().toISOString()
            };
            paintCorrections.push(correction);
            console.log('CORRECTION LOGGED:', correction);
            
            // Update the corrections display
            updateCorrectionsDisplay();
        }
        
        function getNeighborInfo(mapX, mapY) {
            if (!currentMap) return null;
            
            const neighbors = {
                top: null, right: null, bottom: null, left: null,
                topLeft: null, topRight: null, bottomLeft: null, bottomRight: null
            };
            
            const directions = [
                ['top', 0, -1], ['right', 1, 0], ['bottom', 0, 1], ['left', -1, 0],
                ['topLeft', -1, -1], ['topRight', 1, -1], ['bottomLeft', -1, 1], ['bottomRight', 1, 1]
            ];
            
            for (const [name, dx, dy] of directions) {
                const nx = mapX + dx;
                const ny = mapY + dy;
                if (ny >= 0 && ny < currentMap.length && nx >= 0 && nx < currentMap[0].length) {
                    const tile = currentMap[ny][nx];
                    neighbors[name] = { id: tile.id, biome: tile.biome || tile.name };
                }
            }
            
            return neighbors;
        }
        
        function updateCorrectionsDisplay() {
            // Create or update corrections panel
            let panel = document.getElementById('correctionsPanel');
            if (!panel) {
                panel = document.createElement('div');
                panel.id = 'correctionsPanel';
                panel.style.cssText = `
                    position: fixed;
                    bottom: 10px;
                    right: 10px;
                    width: 400px;
                    max-height: 300px;
                    background: #222;
                    border: 2px solid #4CAF50;
                    border-radius: 8px;
                    padding: 10px;
                    overflow-y: auto;
                    font-family: monospace;
                    font-size: 11px;
                    color: #0f0;
                    z-index: 1000;
                `;
                document.body.appendChild(panel);
            }
            
            let html = `<strong style="color: #ff9800;">ğŸ“ PAINT CORRECTIONS (${paintCorrections.length})</strong>
                <button onclick="exportCorrections()" style="float: right; padding: 2px 8px; font-size: 10px;">Export</button>
                <button onclick="clearCorrections()" style="float: right; padding: 2px 8px; font-size: 10px; margin-right: 5px;">Clear</button>
                <hr style="border-color: #444;">`;
            
            for (const c of paintCorrections.slice(-10).reverse()) {
                html += `<div style="margin: 5px 0; padding: 5px; background: #333; border-radius: 4px;">
                    <strong>(${c.x}, ${c.y})</strong>: ${c.was} â†’ <span style="color: #0f0;">${c.shouldBe}</span><br>
                    <small>Neighbors: T:${c.neighbors?.top?.biome || '-'} R:${c.neighbors?.right?.biome || '-'} B:${c.neighbors?.bottom?.biome || '-'} L:${c.neighbors?.left?.biome || '-'}</small>
                </div>`;
            }
            
            panel.innerHTML = html;
        }
        
        window.exportCorrections = function() {
            const json = JSON.stringify(paintCorrections, null, 2);
            console.log('=== PAINT CORRECTIONS ===');
            console.log(json);
            
            // Copy to clipboard
            navigator.clipboard.writeText(json).then(() => {
                alert('Corrections copied to clipboard! Paste them to me so I can learn from your changes.');
            });
        };
        
        window.clearCorrections = function() {
            paintCorrections = [];
            updateCorrectionsDisplay();
        };
        
        // ========================================
        // SAND TRANSITION TILE TESTER
        // ========================================
        
        // Update tile preview images
        window.updateTilePreviews = function() {
            const previewIds = [
                'topEdgePreview', 'bottomEdgePreview', 'leftEdgePreview', 'rightEdgePreview',
                'topLeftCornerPreview', 'topRightCornerPreview', 'bottomLeftCornerPreview', 'bottomRightCornerPreview'
            ];
            const selectIds = [
                'topEdgeSelect', 'bottomEdgeSelect', 'leftEdgeSelect', 'rightEdgeSelect',
                'topLeftCornerSelect', 'topRightCornerSelect', 'bottomLeftCornerSelect', 'bottomRightCornerSelect'
            ];
            
            for (let i = 0; i < previewIds.length; i++) {
                const preview = document.getElementById(previewIds[i]);
                const select = document.getElementById(selectIds[i]);
                if (preview && select && tileImages) {
                    const tileId = select.value;
                    const img = tileImages[tileId];
                    if (img) {
                        preview.src = img.src;
                    }
                }
            }
        };
        
        // Auto-apply test when dropdown changes
        window.autoApplyTest = function() {
            updateTilePreviews();
            testAllEdgesAndCorners();
        };
        
        // Test ALL edges AND corners - complete sand square with proper transitions
        window.testAllEdgesAndCorners = async function() {
            const topTile = document.getElementById('topEdgeSelect').value;
            const bottomTile = document.getElementById('bottomEdgeSelect').value;
            const leftTile = document.getElementById('leftEdgeSelect').value;
            const rightTile = document.getElementById('rightEdgeSelect').value;
            const topLeftTile = document.getElementById('topLeftCornerSelect').value;
            const topRightTile = document.getElementById('topRightCornerSelect').value;
            const bottomLeftTile = document.getElementById('bottomLeftCornerSelect').value;
            const bottomRightTile = document.getElementById('bottomRightCornerSelect').value;
            
            document.getElementById('status').textContent = `Testing edges + corners...`;
            
            const width = 20;
            const height = 20;
            const map = [];
            
            // Sand region: x from 5-14, y from 5-14
            const sandMinX = 5, sandMaxX = 14;
            const sandMinY = 5, sandMaxY = 14;
            
            for (let y = 0; y < height; y++) {
                map[y] = [];
                for (let x = 0; x < width; x++) {
                    const inSandX = x >= sandMinX && x <= sandMaxX;
                    const inSandY = y >= sandMinY && y <= sandMaxY;
                    
                    if (inSandX && inSandY) {
                        let tileId = '0x0016'; // Pure sand by default
                        
                        // CORNERS first (most specific)
                        if (x === sandMinX && y === sandMinY) {
                            tileId = topLeftTile; // TOP-LEFT corner
                        } else if (x === sandMaxX && y === sandMinY) {
                            tileId = topRightTile; // TOP-RIGHT corner
                        } else if (x === sandMinX && y === sandMaxY) {
                            tileId = bottomLeftTile; // BOTTOM-LEFT corner
                        } else if (x === sandMaxX && y === sandMaxY) {
                            tileId = bottomRightTile; // BOTTOM-RIGHT corner
                        }
                        // EDGES (not corners)
                        else if (y === sandMinY) {
                            tileId = topTile; // TOP edge
                        } else if (y === sandMaxY) {
                            tileId = bottomTile; // BOTTOM edge
                        } else if (x === sandMinX) {
                            tileId = leftTile; // LEFT edge
                        } else if (x === sandMaxX) {
                            tileId = rightTile; // RIGHT edge
                        }
                        
                        map[y][x] = { id: tileId, biome: 'sand', name: 'sand' };
                    } else {
                        // Grass region
                        map[y][x] = { id: '0x0003', biome: 'grass', name: 'grass' };
                    }
                }
            }
            
            currentMap = map;
            await renderMap(map);
            
            document.getElementById('status').textContent = 
                `Edges: T=${topTile} B=${bottomTile} L=${leftTile} R=${rightTile} | ` +
                `Corners: TL=${topLeftTile} TR=${topRightTile} BL=${bottomLeftTile} BR=${bottomRightTile}`;
        };
        
        // Update inner corner preview images
        window.updateInnerCornerPreview = function(position) {
            const select = document.getElementById(position + 'Select');
            const preview = document.getElementById(position + 'Preview');
            if (select && preview) {
                const tileId = select.value;
                // Use window.tiles (global) or just load directly from assets
                const tileData = window.tiles ? window.tiles[tileId] : null;
                if (tileData && tileData.img) {
                    preview.src = tileData.img.src;
                } else {
                    // Load directly from assets folder
                    preview.src = `assets/tiles/${tileId.toUpperCase()}.bmp`;
                }
            }
        };
        
        // Auto-apply inner corners when dropdown changes
        window.autoApplyInnerCorners = function() {
            // Update all previews
            ['innerTopLeft', 'innerTopRight', 'innerBottomLeft', 'innerBottomRight'].forEach(pos => {
                updateInnerCornerPreview(pos);
            });
            // Run the test
            testInnerCorners();
        };
        
        // Update diagonal preview images
        window.updateDiagonalPreview = function(num) {
            const select = document.getElementById('diag' + num + 'Select');
            const preview = document.getElementById('diag' + num + 'Preview');
            if (select && preview) {
                const tileId = select.value;
                preview.src = `assets/tiles/${tileId.toUpperCase()}.bmp`;
            }
        };
        
        // Auto-apply diagonal when dropdown changes
        window.autoApplyDiagonal = function() {
            [1, 2, 3].forEach(num => updateDiagonalPreview(num));
            testDiagonalWithDropdowns();
        };
        
        // Reverse the diagonal direction (swap sand and grass sides)
        window.reverseDiagonal = function() {
            window.diagonalReversed = !window.diagonalReversed;
            // Update button text to show current state
            const btn = document.querySelector('button[onclick="reverseDiagonal()"]');
            if (btn) {
                btn.textContent = window.diagonalReversed ? 'ğŸ”„ Back to Normal (Grassâ†’Sand)' : 'ğŸ”„ Reverse (Sandâ†’Grass)';
            }
            autoApplyDiagonal();
        };
        
        // Track current diagonal direction
        window.diagonalReversed = false;
        
        // Test diagonal with selected tiles from dropdowns
        window.testDiagonalWithDropdowns = async function() {
            const diag1 = document.getElementById('diag1Select').value;
            const diag2 = document.getElementById('diag2Select').value;
            const diag3 = document.getElementById('diag3Select').value;
            
            const reversed = window.diagonalReversed;
            document.getElementById('status').textContent = `Testing diagonal pattern (${reversed ? 'REVERSED: Sandâ†Grass' : 'Normal: Grassâ†’Sand'})...`;
            
            const width = 15;
            const height = 15;
            const map = [];
            
            for (let y = 0; y < height; y++) {
                map[y] = [];
                for (let x = 0; x < width; x++) {
                    // Diagonal line: x - y determines position
                    const diagonalPos = x - y + 7; // Shift to center
                    
                    if (reversed) {
                        // REVERSED: Sand on LEFT/BOTTOM, Grass on RIGHT/TOP
                        if (diagonalPos < 6) {
                            // Pure sand (bottom-left side)
                            map[y][x] = { id: '0x0016', biome: 'sand', name: 'sand' };
                        } else if (diagonalPos > 8) {
                            // Pure grass (top-right side)
                            map[y][x] = { id: '0x0003', biome: 'grass', name: 'grass' };
                        } else {
                            // Transition zone - DIAG1 is closest to sand, DIAG3 is closest to grass
                            const transitionIndex = diagonalPos - 6; // 0, 1, or 2
                            let tileId;
                            if (transitionIndex === 0) tileId = diag1;  // Next to sand
                            else if (transitionIndex === 1) tileId = diag2;  // Middle
                            else tileId = diag3;  // Next to grass
                            
                            map[y][x] = { id: tileId, biome: 'sand', name: 'sand', isTransition: true };
                        }
                    } else {
                        // NORMAL: Grass on LEFT/BOTTOM, Sand on RIGHT/TOP
                        if (diagonalPos < 6) {
                            // Pure grass (bottom-left side)
                            map[y][x] = { id: '0x0003', biome: 'grass', name: 'grass' };
                        } else if (diagonalPos > 8) {
                            // Pure sand (top-right side)
                            map[y][x] = { id: '0x0016', biome: 'sand', name: 'sand' };
                        } else {
                            // Transition zone - DIAG1 is closest to grass, DIAG3 is closest to sand
                            const transitionIndex = diagonalPos - 6; // 0, 1, or 2
                            let tileId;
                            if (transitionIndex === 0) tileId = diag1;  // Next to grass
                            else if (transitionIndex === 1) tileId = diag2;  // Middle
                            else tileId = diag3;  // Next to sand
                            
                            map[y][x] = { id: tileId, biome: 'sand', name: 'sand', isTransition: true };
                        }
                    }
                }
            }
            
            await renderMap(map);
            if (reversed) {
                document.getElementById('status').textContent = 
                    `REVERSED â†™ï¸: SAND â† DIAG1=${diag1} â† DIAG2=${diag2} â† DIAG3=${diag3} â† GRASS`;
            } else {
                document.getElementById('status').textContent = 
                    `NORMAL â†—ï¸: GRASS â†’ DIAG1=${diag1} â†’ DIAG2=${diag2} â†’ DIAG3=${diag3} â†’ SAND`;
            }
        };
        
        // Initialize diagonal previews
        setTimeout(() => {
            [1, 2, 3].forEach(num => updateDiagonalPreview(num));
        }, 2600);
        
        // Test INNER corners - grass square with sand "notches" in corners
        // Inner corners = grass on 3 sides, sand only in one corner
        window.testInnerCorners = async function() {
            const innerTL = document.getElementById('innerTopLeftSelect').value;
            const innerTR = document.getElementById('innerTopRightSelect').value;
            const innerBL = document.getElementById('innerBottomLeftSelect').value;
            const innerBR = document.getElementById('innerBottomRightSelect').value;
            
            document.getElementById('status').textContent = `Testing INNER corners...`;
            
            const width = 20;
            const height = 20;
            const map = [];
            
            // Create a grass region with sand "notches" at each corner
            // The inner corner tiles should show mostly grass with a small sand corner
            const sandMinX = 5, sandMaxX = 14;
            const sandMinY = 5, sandMaxY = 14;
            
            for (let y = 0; y < height; y++) {
                map[y] = [];
                for (let x = 0; x < width; x++) {
                    // Default to pure sand
                    let tileId = '0x0016';
                    let biome = 'sand';
                    
                    const inSandX = x >= sandMinX && x <= sandMaxX;
                    const inSandY = y >= sandMinY && y <= sandMaxY;
                    
                    if (inSandX && inSandY) {
                        // Inside the region - make it grass with inner corner tiles at corners
                        tileId = '0x0003'; // Pure grass
                        biome = 'grass';
                        
                        // Place inner corner tiles at the INNER corners of the grass region
                        // These tiles should show mostly grass with sand "poking in" from one corner
                        if (x === sandMinX && y === sandMinY) {
                            tileId = innerTL; // Sand pokes in from TOP-LEFT
                            biome = 'grass';
                        } else if (x === sandMaxX && y === sandMinY) {
                            tileId = innerTR; // Sand pokes in from TOP-RIGHT
                            biome = 'grass';
                        } else if (x === sandMinX && y === sandMaxY) {
                            tileId = innerBL; // Sand pokes in from BOTTOM-LEFT
                            biome = 'grass';
                        } else if (x === sandMaxX && y === sandMaxY) {
                            tileId = innerBR; // Sand pokes in from BOTTOM-RIGHT
                            biome = 'grass';
                        }
                    }
                    
                    map[y][x] = { id: tileId, biome: biome, name: biome };
                }
            }
            
            currentMap = map;
            await renderMap(map);
            
            document.getElementById('status').textContent = 
                `INNER Corners: TL=${innerTL} TR=${innerTR} BL=${innerBL} BR=${innerBR} ` +
                `(These tiles should show sand "poking into" the grass corners)`;
        };
        
        // Initialize inner corner previews
        setTimeout(() => {
            ['innerTopLeft', 'innerTopRight', 'innerBottomLeft', 'innerBottomRight'].forEach(pos => {
                updateInnerCornerPreview(pos);
            });
        }, 2500);
        
        // Test DIAGONAL edges - these create the "staircase" pattern that needs fixing
        // A diagonal boundary alternates between edge tiles and corner tiles
        window.testDiagonalEdgeNE = async function() {
            document.getElementById('status').textContent = `Testing DIAGONAL NE edge (sand to grass going â†—)...`;
            
            const width = 20;
            const height = 20;
            const map = [];
            
            // Get selected tiles
            const topEdge = document.getElementById('topEdgeSelect').value;
            const rightEdge = document.getElementById('rightEdgeSelect').value;
            const trCorner = document.getElementById('topRightCornerSelect').value;
            
            // Create diagonal boundary going NE (bottom-left is sand, top-right is grass)
            for (let y = 0; y < height; y++) {
                map[y] = [];
                for (let x = 0; x < width; x++) {
                    // Diagonal line: x + y < 15 is sand, x + y >= 15 is grass
                    const diagonalSum = x + y;
                    
                    if (diagonalSum < 14) {
                        // Pure sand
                        map[y][x] = { id: '0x0016', biome: 'sand', name: 'sand' };
                    } else if (diagonalSum >= 16) {
                        // Pure grass
                        map[y][x] = { id: '0x0003', biome: 'grass', name: 'grass' };
                    } else {
                        // Transition zone - this is where we need the right tiles
                        // Check neighbors to determine which tile
                        const hasGrassTop = (x + (y-1)) >= 15;
                        const hasGrassRight = ((x+1) + y) >= 15;
                        
                        if (hasGrassTop && hasGrassRight) {
                            // Both top and right are grass - use corner
                            map[y][x] = { id: trCorner, biome: 'sand', name: 'sand', isTransition: true };
                        } else if (hasGrassTop) {
                            map[y][x] = { id: topEdge, biome: 'sand', name: 'sand', isTransition: true };
                        } else if (hasGrassRight) {
                            map[y][x] = { id: rightEdge, biome: 'sand', name: 'sand', isTransition: true };
                        } else {
                            map[y][x] = { id: '0x0016', biome: 'sand', name: 'sand' };
                        }
                    }
                }
            }
            
            await renderMap(map);
            document.getElementById('status').textContent = `DIAGONAL NE: Using TOP=${topEdge}, RIGHT=${rightEdge}, TR_CORNER=${trCorner}`;
        };
        
        window.testDiagonalEdgeSE = async function() {
            document.getElementById('status').textContent = `Testing DIAGONAL SE edge (sand to grass going â†˜)...`;
            
            const width = 20;
            const height = 20;
            const map = [];
            
            const bottomEdge = document.getElementById('bottomEdgeSelect').value;
            const rightEdge = document.getElementById('rightEdgeSelect').value;
            const brCorner = document.getElementById('bottomRightCornerSelect').value;
            
            // Diagonal: top-left is sand, bottom-right is grass
            for (let y = 0; y < height; y++) {
                map[y] = [];
                for (let x = 0; x < width; x++) {
                    // x - y determines position (positive = right of diagonal)
                    const diagonalDiff = x - y;
                    
                    if (diagonalDiff < -1) {
                        map[y][x] = { id: '0x0016', biome: 'sand', name: 'sand' };
                    } else if (diagonalDiff > 1) {
                        map[y][x] = { id: '0x0003', biome: 'grass', name: 'grass' };
                    } else {
                        const hasGrassBottom = ((x) - (y+1)) > 0;
                        const hasGrassRight = ((x+1) - y) > 0;
                        
                        if (hasGrassBottom && hasGrassRight) {
                            map[y][x] = { id: brCorner, biome: 'sand', name: 'sand', isTransition: true };
                        } else if (hasGrassBottom) {
                            map[y][x] = { id: bottomEdge, biome: 'sand', name: 'sand', isTransition: true };
                        } else if (hasGrassRight) {
                            map[y][x] = { id: rightEdge, biome: 'sand', name: 'sand', isTransition: true };
                        } else {
                            map[y][x] = { id: '0x0016', biome: 'sand', name: 'sand' };
                        }
                    }
                }
            }
            
            await renderMap(map);
            document.getElementById('status').textContent = `DIAGONAL SE: Using BOTTOM=${bottomEdge}, RIGHT=${rightEdge}, BR_CORNER=${brCorner}`;
        };
        
        window.testDiagonalEdgeSW = async function() {
            document.getElementById('status').textContent = `Testing DIAGONAL SW edge (sand to grass going â†™)...`;
            
            const width = 20;
            const height = 20;
            const map = [];
            
            const bottomEdge = document.getElementById('bottomEdgeSelect').value;
            const leftEdge = document.getElementById('leftEdgeSelect').value;
            const blCorner = document.getElementById('bottomLeftCornerSelect').value;
            
            // Diagonal: top-right is sand, bottom-left is grass
            for (let y = 0; y < height; y++) {
                map[y] = [];
                for (let x = 0; x < width; x++) {
                    const diagonalSum = x + y;
                    
                    if (diagonalSum > 20) {
                        map[y][x] = { id: '0x0016', biome: 'sand', name: 'sand' };
                    } else if (diagonalSum < 18) {
                        map[y][x] = { id: '0x0003', biome: 'grass', name: 'grass' };
                    } else {
                        const hasGrassBottom = ((x) + (y+1)) < 19;
                        const hasGrassLeft = ((x-1) + y) < 19;
                        
                        if (hasGrassBottom && hasGrassLeft) {
                            map[y][x] = { id: blCorner, biome: 'sand', name: 'sand', isTransition: true };
                        } else if (hasGrassBottom) {
                            map[y][x] = { id: bottomEdge, biome: 'sand', name: 'sand', isTransition: true };
                        } else if (hasGrassLeft) {
                            map[y][x] = { id: leftEdge, biome: 'sand', name: 'sand', isTransition: true };
                        } else {
                            map[y][x] = { id: '0x0016', biome: 'sand', name: 'sand' };
                        }
                    }
                }
            }
            
            await renderMap(map);
            document.getElementById('status').textContent = `DIAGONAL SW: Using BOTTOM=${bottomEdge}, LEFT=${leftEdge}, BL_CORNER=${blCorner}`;
        };
        
        window.testDiagonalEdgeNW = async function() {
            document.getElementById('status').textContent = `Testing DIAGONAL NW edge (sand to grass going â†–)...`;
            
            const width = 20;
            const height = 20;
            const map = [];
            
            const topEdge = document.getElementById('topEdgeSelect').value;
            const leftEdge = document.getElementById('leftEdgeSelect').value;
            const tlCorner = document.getElementById('topLeftCornerSelect').value;
            
            // Diagonal: bottom-right is sand, top-left is grass
            for (let y = 0; y < height; y++) {
                map[y] = [];
                for (let x = 0; x < width; x++) {
                    const diagonalDiff = x - y;
                    
                    if (diagonalDiff > 1) {
                        map[y][x] = { id: '0x0016', biome: 'sand', name: 'sand' };
                    } else if (diagonalDiff < -1) {
                        map[y][x] = { id: '0x0003', biome: 'grass', name: 'grass' };
                    } else {
                        const hasGrassTop = ((x) - (y-1)) < 0;
                        const hasGrassLeft = ((x-1) - y) < 0;
                        
                        if (hasGrassTop && hasGrassLeft) {
                            map[y][x] = { id: tlCorner, biome: 'sand', name: 'sand', isTransition: true };
                        } else if (hasGrassTop) {
                            map[y][x] = { id: topEdge, biome: 'sand', name: 'sand', isTransition: true };
                        } else if (hasGrassLeft) {
                            map[y][x] = { id: leftEdge, biome: 'sand', name: 'sand', isTransition: true };
                        } else {
                            map[y][x] = { id: '0x0016', biome: 'sand', name: 'sand' };
                        }
                    }
                }
            }
            
            await renderMap(map);
            document.getElementById('status').textContent = `DIAGONAL NW: Using TOP=${topEdge}, LEFT=${leftEdge}, TL_CORNER=${tlCorner}`;
        };
        
        // Save the confirmed mappings
        window.saveMappings = function() {
            const mappings = {
                edges: {
                    top: document.getElementById('topEdgeSelect').value,
                    bottom: document.getElementById('bottomEdgeSelect').value,
                    left: document.getElementById('leftEdgeSelect').value,
                    right: document.getElementById('rightEdgeSelect').value
                },
                corners: {
                    topLeft: document.getElementById('topLeftCornerSelect').value,
                    topRight: document.getElementById('topRightCornerSelect').value,
                    bottomLeft: document.getElementById('bottomLeftCornerSelect').value,
                    bottomRight: document.getElementById('bottomRightCornerSelect').value
                }
            };
            
            console.log('=== CONFIRMED SAND TRANSITION MAPPINGS ===');
            console.log(JSON.stringify(mappings, null, 2));
            
            // Copy to clipboard
            const text = `SAND TRANSITION MAPPINGS:
EDGES:
  TOP: ${mappings.edges.top}
  BOTTOM: ${mappings.edges.bottom}
  LEFT: ${mappings.edges.left}
  RIGHT: ${mappings.edges.right}
CORNERS:
  TOP-LEFT: ${mappings.corners.topLeft}
  TOP-RIGHT: ${mappings.corners.topRight}
  BOTTOM-LEFT: ${mappings.corners.bottomLeft}
  BOTTOM-RIGHT: ${mappings.corners.bottomRight}`;
            
            navigator.clipboard.writeText(text).then(() => {
                alert('Mappings copied to clipboard!\n\n' + text);
            }).catch(() => {
                alert('Mappings:\n\n' + text);
            });
        };
        
        // Legacy functions
        window.testLeftRight = async function() { testAllEdgesAndCorners(); };
        window.testTopBottom = async function() { testAllEdgesAndCorners(); };
        window.testAllFourEdges = async function() { testAllEdgesAndCorners(); };
        window.testBothSides = async function() { testAllEdgesAndCorners(); };
        
        // Initialize previews after tiles load
        setTimeout(() => {
            if (typeof updateTilePreviews === 'function') {
                updateTilePreviews();
            }
        }, 2000);
        
        // Legacy single tile test
        window.testSandTransition = async function() {
            const select = document.getElementById('sandTransitionSelect');
            if (!select) {
                // Use new system
                testBothSides();
                return;
            }
            const tileId = select.value;
            
            if (!tileId) {
                alert('Please select a tile from the dropdown!');
                return;
            }
            
            document.getElementById('status').textContent = `Testing tile ${tileId}...`;
            
            const width = 20;
            const height = 20;
            const map = [];
            
            for (let y = 0; y < height; y++) {
                map[y] = [];
                for (let x = 0; x < width; x++) {
                    if (x < 10) {
                        map[y][x] = {
                            id: '0x0003',
                            biome: 'grass',
                            name: 'grass'
                        };
                    } else if (x === 10) {
                        map[y][x] = {
                            id: tileId,
                            biome: 'sand',
                            name: 'sand_transition',
                            isTransition: true
                        };
                    } else {
                        map[y][x] = {
                            id: '0x0016',
                            biome: 'sand',
                            name: 'sand'
                        };
                    }
                }
            }
            
            currentMap = map;
            await renderMap(map);
            
            document.getElementById('status').textContent = `Testing ${tileId}`;
        };
        
        // Show all transition tiles in a grid
        window.showAllTransitions = async function() {
            document.getElementById('status').textContent = 'Creating transition tile showcase...';
            
            // Create a map that shows each transition tile with its appropriate neighbors
            const width = 30;
            const height = 20;
            const map = [];
            
            // Define transition tiles with their expected grass directions
            const transitions = [
                { id: '0x0033', grassDir: 'S', label: 'S' },      // Grass to South
                { id: '0x0034', grassDir: 'W', label: 'W' },      // Grass to West
                { id: '0x0035', grassDir: 'N', label: 'N' },      // Grass to North
                { id: '0x0036', grassDir: 'E', label: 'E' },      // Grass to East
                { id: '0x0037', grassDir: 'SE', label: 'S+E' },   // Grass to South+East
                { id: '0x0038', grassDir: 'NW', label: 'N+W' },   // Grass to North+West
                { id: '0x0039', grassDir: 'SW', label: 'S+W' },   // Grass to South+West
                { id: '0x003A', grassDir: 'NE', label: 'N+E' },   // Grass to North+East
            ];
            
            // Initialize with grass
            for (let y = 0; y < height; y++) {
                map[y] = [];
                for (let x = 0; x < width; x++) {
                    map[y][x] = {
                        id: '0x0003',
                        biome: 'grass',
                        name: 'grass'
                    };
                }
            }
            
            // Place each transition tile in a row with sand on the appropriate side
            let row = 2;
            for (let i = 0; i < transitions.length; i++) {
                const t = transitions[i];
                const col = 5 + (i % 4) * 6;
                
                if (i === 4) row = 10; // Second row of transitions
                
                // Place the transition tile
                map[row][col] = {
                    id: t.id,
                    biome: 'sand',
                    name: `sand_${t.label}`,
                    isTransition: true
                };
                
                // Place sand on the grass side(s) to show the transition
                if (t.grassDir.includes('N')) {
                    map[row - 1][col] = { id: '0x0003', biome: 'grass', name: 'grass' };
                } else {
                    map[row - 1][col] = { id: '0x0016', biome: 'sand', name: 'sand' };
                }
                
                if (t.grassDir.includes('S')) {
                    map[row + 1][col] = { id: '0x0003', biome: 'grass', name: 'grass' };
                } else {
                    map[row + 1][col] = { id: '0x0016', biome: 'sand', name: 'sand' };
                }
                
                if (t.grassDir.includes('E')) {
                    map[row][col + 1] = { id: '0x0003', biome: 'grass', name: 'grass' };
                } else {
                    map[row][col + 1] = { id: '0x0016', biome: 'sand', name: 'sand' };
                }
                
                if (t.grassDir.includes('W')) {
                    map[row][col - 1] = { id: '0x0003', biome: 'grass', name: 'grass' };
                } else {
                    map[row][col - 1] = { id: '0x0016', biome: 'sand', name: 'sand' };
                }
            }
            
            currentMap = map;
            await renderMap(map);
            
            document.getElementById('status').textContent = 'Showing all 8 transition tiles with correct neighbor placement';
        };
        
        // ============================================================
        // NEIGHBOR CONFIGURATION TESTER - Debug transition logic
        // ============================================================
        
        // Import the transition module for testing
        let transitionModule = null;
        import('./js/data/transitionTiles8bit.js?v=' + Date.now()).then(module => {
            transitionModule = module;
            console.log('Transition module loaded for neighbor tester');
            // Initialize the neighbor test after module loads
            setTimeout(() => {
                if (window.tiles) {
                    updateNeighborTest();
                }
            }, 500);
        });
        
        // Helper to get tile image URL
        function getTileImageUrl(tileId) {
            // Convert hex string to padded uppercase hex
            let hexId = tileId;
            if (typeof tileId === 'number') {
                hexId = '0x' + tileId.toString(16).toUpperCase().padStart(4, '0');
            } else if (tileId.startsWith('0x')) {
                hexId = '0x' + tileId.slice(2).toUpperCase().padStart(4, '0');
            }
            return `assets/tiles/${hexId}.bmp`;
        }
        
        // Initialize neighbor tester previews when tiles are loaded
        window.initNeighborTester = function() {
            const codePicksPreview = document.getElementById('codePicksPreview');
            const shouldBePreview = document.getElementById('shouldBePreview');
            
            // Default to pure sand preview
            const sandUrl = getTileImageUrl('0x0016');
            if (codePicksPreview) codePicksPreview.src = sandUrl;
            if (shouldBePreview) shouldBePreview.src = sandUrl;
            
            updateNeighborTest();
        };
        
        window.updateNeighborTest = function() {
            // Get checkbox states
            const top = document.getElementById('nbr_t')?.checked || false;
            const right = document.getElementById('nbr_r')?.checked || false;
            const bottom = document.getElementById('nbr_b')?.checked || false;
            const left = document.getElementById('nbr_l')?.checked || false;
            const topLeft = document.getElementById('nbr_tl')?.checked || false;
            const topRight = document.getElementById('nbr_tr')?.checked || false;
            const bottomLeft = document.getElementById('nbr_bl')?.checked || false;
            const bottomRight = document.getElementById('nbr_br')?.checked || false;
            
            // Calculate bitmask (same as in transitionTiles8bit.js)
            let bitmask = 0;
            if (top) bitmask |= 1;        // TOP
            if (right) bitmask |= 2;      // RIGHT
            if (bottom) bitmask |= 4;     // BOTTOM
            if (left) bitmask |= 8;       // LEFT
            if (topLeft) bitmask |= 16;   // TOP_LEFT
            if (topRight) bitmask |= 32;  // TOP_RIGHT
            if (bottomLeft) bitmask |= 64;  // BOTTOM_LEFT
            if (bottomRight) bitmask |= 128; // BOTTOM_RIGHT
            
            // Get what the code picks
            let tileId = null;
            if (transitionModule) {
                tileId = transitionModule.getSandToGrassTile(bitmask);
            }
            
            const codePicksId = document.getElementById('codePicksId');
            const codePicksBitmask = document.getElementById('codePicksBitmask');
            const codePicksPreview = document.getElementById('codePicksPreview');
            
            if (codePicksId) {
                codePicksId.textContent = tileId || 'null (pure sand)';
            }
            if (codePicksBitmask) {
                codePicksBitmask.textContent = `Bitmask: ${bitmask} | Cardinals: T:${top?1:0} R:${right?1:0} B:${bottom?1:0} L:${left?1:0} | Diagonals: TL:${topLeft?1:0} TR:${topRight?1:0} BL:${bottomLeft?1:0} BR:${bottomRight?1:0}`;
            }
            
            // Update preview
            if (codePicksPreview) {
                if (tileId) {
                    codePicksPreview.src = getTileImageUrl(tileId);
                } else {
                    // Pure sand
                    codePicksPreview.src = getTileImageUrl('0x0016');
                }
            }
        };
        
        window.updateShouldBePreview = function() {
            const select = document.getElementById('shouldBeSelect');
            const preview = document.getElementById('shouldBePreview');
            if (!select || !preview) return;
            
            const tileId = select.value;
            if (tileId) {
                preview.src = getTileImageUrl(tileId);
            }
        };
        
        window.logCorrection = function() {
            const top = document.getElementById('nbr_t')?.checked || false;
            const right = document.getElementById('nbr_r')?.checked || false;
            const bottom = document.getElementById('nbr_b')?.checked || false;
            const left = document.getElementById('nbr_l')?.checked || false;
            const topLeft = document.getElementById('nbr_tl')?.checked || false;
            const topRight = document.getElementById('nbr_tr')?.checked || false;
            const bottomLeft = document.getElementById('nbr_bl')?.checked || false;
            const bottomRight = document.getElementById('nbr_br')?.checked || false;
            
            const codePicks = document.getElementById('codePicksId')?.textContent || '-';
            const shouldBe = document.getElementById('shouldBeSelect')?.value || '';
            
            if (!shouldBe) {
                alert('Please select what the tile SHOULD be!');
                return;
            }
            
            const neighbors = [];
            if (top) neighbors.push('T');
            if (right) neighbors.push('R');
            if (bottom) neighbors.push('B');
            if (left) neighbors.push('L');
            if (topLeft) neighbors.push('TL');
            if (topRight) neighbors.push('TR');
            if (bottomLeft) neighbors.push('BL');
            if (bottomRight) neighbors.push('BR');
            
            // Calculate bitmask
            let bitmask = 0;
            if (top) bitmask |= 1;
            if (right) bitmask |= 2;
            if (bottom) bitmask |= 4;
            if (left) bitmask |= 8;
            if (topLeft) bitmask |= 16;
            if (topRight) bitmask |= 32;
            if (bottomLeft) bitmask |= 64;
            if (bottomRight) bitmask |= 128;
            
            const log = document.getElementById('correctionLog');
            if (log) {
                const entry = `// Grass: [${neighbors.join(', ')}] (bitmask=${bitmask}) â†’ Code: ${codePicks}, Should: ${shouldBe}\n`;
                log.textContent += entry;
            }
        };
        
        window.clearNeighborTest = function() {
            ['nbr_t', 'nbr_r', 'nbr_b', 'nbr_l', 'nbr_tl', 'nbr_tr', 'nbr_bl', 'nbr_br'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.checked = false;
            });
            const select = document.getElementById('shouldBeSelect');
            if (select) select.value = '';
            updateNeighborTest();
        };
        
        window.renderNeighborTest = async function() {
            // Create a small test map showing the current neighbor config
            const width = 7;
            const height = 7;
            const map = [];
            
            const top = document.getElementById('nbr_t')?.checked || false;
            const right = document.getElementById('nbr_r')?.checked || false;
            const bottom = document.getElementById('nbr_b')?.checked || false;
            const left = document.getElementById('nbr_l')?.checked || false;
            const topLeft = document.getElementById('nbr_tl')?.checked || false;
            const topRight = document.getElementById('nbr_tr')?.checked || false;
            const bottomLeft = document.getElementById('nbr_bl')?.checked || false;
            const bottomRight = document.getElementById('nbr_br')?.checked || false;
            
            // Initialize all as sand
            for (let y = 0; y < height; y++) {
                map[y] = [];
                for (let x = 0; x < width; x++) {
                    map[y][x] = {
                        id: '0x0016',
                        biome: 'sand',
                        name: 'sand'
                    };
                }
            }
            
            // Center is the test tile (will be set by transition system)
            const cx = 3, cy = 3;
            
            // Set neighbors based on checkboxes - these become GRASS
            if (top) { map[cy-1][cx].biome = 'grass'; map[cy-1][cx].id = '0x0003'; }
            if (right) { map[cy][cx+1].biome = 'grass'; map[cy][cx+1].id = '0x0003'; }
            if (bottom) { map[cy+1][cx].biome = 'grass'; map[cy+1][cx].id = '0x0003'; }
            if (left) { map[cy][cx-1].biome = 'grass'; map[cy][cx-1].id = '0x0003'; }
            if (topLeft) { map[cy-1][cx-1].biome = 'grass'; map[cy-1][cx-1].id = '0x0003'; }
            if (topRight) { map[cy-1][cx+1].biome = 'grass'; map[cy-1][cx+1].id = '0x0003'; }
            if (bottomLeft) { map[cy+1][cx-1].biome = 'grass'; map[cy+1][cx-1].id = '0x0003'; }
            if (bottomRight) { map[cy+1][cx+1].biome = 'grass'; map[cy+1][cx+1].id = '0x0003'; }
            
            // Apply transitions using the actual transition system
            if (transitionModule) {
                transitionModule.apply8BitTransitions(map, width, height);
            }
            
            currentMap = map;
            await renderMap(map);
            document.getElementById('status').textContent = `Neighbor test rendered - Center tile shows transition`;
        };
        
        // Learning Mode Functions
        window.toggleLearningMode = function() {
            const panel = document.getElementById('learningMode');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        };
        
        // Store learning data
        let learningData = {
            tileTransitions: {},
            biomeDistribution: {},
            embankmentPatterns: {},
            staticPlacements: {},
            zHeightPatterns: {},
            regionsAnalyzed: 0
        };
        
        window.startLearningAnalysis = async function() {
            const output = document.getElementById('learningOutput');
            const regionX = parseInt(document.getElementById('learnRegionX').value) || 1400;
            const regionY = parseInt(document.getElementById('learnRegionY').value) || 1600;
            const width = parseInt(document.getElementById('learnWidth').value) || 100;
            const height = parseInt(document.getElementById('learnHeight').value) || 100;
            
            const analyzeTransitions = document.getElementById('learnTileTransitions').checked;
            const analyzeBiomes = document.getElementById('learnBiomeDistribution').checked;
            const analyzeEmbankments = document.getElementById('learnEmbankments').checked;
            const analyzeStatics = document.getElementById('learnStatics').checked;
            const analyzeZHeight = document.getElementById('learnZHeight').checked;
            
            updateProgress(0, 'ğŸ§  Starting learning analysis...');
            output.innerHTML = '<div style="color: #9C27B0;">ğŸ”„ Loading region...</div>';
            
            try {
                // Load the map region
                const loaded = await uoMapLoader.loadMap('./assets/mul/map0.mul', 7168, 4096);
                if (!loaded) {
                    throw new Error('Failed to load map0.mul');
                }
                
                updateProgress(20, 'ğŸ§  Extracting region...');
                const region = uoMapLoader.extractRegion(regionX, regionY, width, height);
                
                // Convert to our map format
                const map = [];
                for (let y = 0; y < height; y++) {
                    map[y] = [];
                    for (let x = 0; x < width; x++) {
                        const tile = region[y][x];
                        map[y][x] = {
                            id: tile.id,
                            biome: tile.biome || 'unknown',
                            z: tile.z || 0,
                            originalTileId: tile.originalTileId || tile.id
                        };
                    }
                }
                
                updateProgress(40, 'ğŸ§  Analyzing patterns...');
                let results = [];
                
                // Analyze tile transitions
                if (analyzeTransitions) {
                    const transitions = analyzeTileTransitions(map, width, height);
                    learningData.tileTransitions = { ...learningData.tileTransitions, ...transitions };
                    results.push(`âœ… Tile Transitions: Found ${Object.keys(transitions).length} unique transition patterns`);
                }
                
                // Analyze biome distribution
                if (analyzeBiomes) {
                    const biomes = analyzeBiomeDistribution(map, width, height);
                    learningData.biomeDistribution = mergeBiomeData(learningData.biomeDistribution, biomes);
                    results.push(`âœ… Biome Distribution: ${Object.keys(biomes).length} biomes analyzed`);
                }
                
                // Analyze embankment placement
                if (analyzeEmbankments) {
                    const embankments = analyzeEmbankmentPlacement(map, width, height);
                    learningData.embankmentPatterns = { ...learningData.embankmentPatterns, ...embankments };
                    results.push(`âœ… Embankments: Found ${Object.keys(embankments).length} embankment patterns`);
                }
                
                // Analyze static placements (if statics are loaded)
                if (analyzeStatics) {
                    try {
                        const staticLoader = new UOStaticLoader();
                        const staticsLoaded = await staticLoader.loadStatics(
                            './assets/mul/statics0.mul',
                            './assets/mul/staidx0.mul',
                            7168, 4096
                        );
                        if (staticsLoaded) {
                            const statics = staticLoader.getStaticsForRegion(regionX, regionY, width, height, 1000);
                            const staticAnalysis = analyzeStaticPlacement(map, statics, width, height);
                            learningData.staticPlacements = mergeStaticData(learningData.staticPlacements, staticAnalysis);
                            results.push(`âœ… Statics: Analyzed ${statics.length} static objects`);
                        } else {
                            results.push(`âš ï¸  Statics: Files not available`);
                        }
                    } catch (e) {
                        results.push(`âš ï¸  Statics: ${e.message}`);
                    }
                }
                
                // Analyze Z-height patterns
                if (analyzeZHeight) {
                    const zPatterns = analyzeZHeightPatterns(map, width, height);
                    learningData.zHeightPatterns = mergeZHeightData(learningData.zHeightPatterns, zPatterns);
                    results.push(`âœ… Z-Height: Analyzed elevation patterns`);
                }
                
                learningData.regionsAnalyzed++;
                
                updateProgress(100, 'âœ… Analysis complete!');
                output.innerHTML = results.map(r => `<div style="margin: 5px 0;">${r}</div>`).join('') +
                    `<div style="margin-top: 10px; color: #4CAF50; font-weight: bold;">Total regions analyzed: ${learningData.regionsAnalyzed}</div>`;
                
                // Also render the map so user can see what was analyzed
                currentMap = map;
                await renderMap(map);
                
            } catch (e) {
                output.innerHTML = `<div style="color: #f44336;">âŒ Error: ${e.message}</div>`;
                console.error('Learning analysis error:', e);
            }
        };
        
        // Analysis functions
        function analyzeTileTransitions(map, width, height) {
            const transitions = {};
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const center = map[y][x];
                    const neighbors = {
                        n: map[y-1][x],
                        s: map[y+1][x],
                        e: map[y][x+1],
                        w: map[y][x-1]
                    };
                    
                    // Create transition key
                    const key = `${center.biome}_${neighbors.n.biome}_${neighbors.s.biome}_${neighbors.e.biome}_${neighbors.w.biome}`;
                    if (!transitions[key]) {
                        transitions[key] = {
                            centerTile: center.id,
                            centerBiome: center.biome,
                            neighborBiomes: {
                                n: neighbors.n.biome,
                                s: neighbors.s.biome,
                                e: neighbors.e.biome,
                                w: neighbors.w.biome
                            },
                            count: 0
                        };
                    }
                    transitions[key].count++;
                }
            }
            return transitions;
        }
        
        function analyzeBiomeDistribution(map, width, height) {
            const biomes = {};
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const biome = map[y][x].biome;
                    if (!biomes[biome]) {
                        biomes[biome] = {
                            count: 0,
                            tiles: new Set(),
                            avgZ: 0,
                            zSum: 0
                        };
                    }
                    biomes[biome].count++;
                    biomes[biome].tiles.add(map[y][x].id);
                    biomes[biome].zSum += map[y][x].z || 0;
                }
            }
            
            // Calculate averages
            for (const biome in biomes) {
                biomes[biome].avgZ = biomes[biome].zSum / biomes[biome].count;
                biomes[biome].tiles = Array.from(biomes[biome].tiles);
            }
            
            return biomes;
        }
        
        function analyzeEmbankmentPlacement(map, width, height) {
            const embankments = {};
            const embankmentTileIds = new Set([
                '0x098C', '0x098D', '0x098E', '0x098F', '0x0990', '0x0991', '0x0992', '0x0993',
                '0x0994', '0x0995', '0x0996', '0x0997', '0x0998', '0x0999', '0x099A', '0x099B',
                '0x001C', '0x001D', '0x001E', '0x001F', '0x0020', '0x0021', '0x0022', '0x0023'
            ]);
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const tile = map[y][x];
                    if (embankmentTileIds.has(tile.id)) {
                        const neighbors = {
                            n: map[y-1][x],
                            s: map[y+1][x],
                            e: map[y][x+1],
                            w: map[y][x-1]
                        };
                        
                        const waterNeighbors = {
                            n: neighbors.n.biome === 'water',
                            s: neighbors.s.biome === 'water',
                            e: neighbors.e.biome === 'water',
                            w: neighbors.w.biome === 'water'
                        };
                        
                        const key = `${tile.id}_${waterNeighbors.n}_${waterNeighbors.s}_${waterNeighbors.e}_${waterNeighbors.w}`;
                        if (!embankments[key]) {
                            embankments[key] = {
                                tileId: tile.id,
                                waterNeighbors,
                                count: 0
                            };
                        }
                        embankments[key].count++;
                    }
                }
            }
            return embankments;
        }
        
        function analyzeStaticPlacement(map, statics, width, height) {
            const placement = {
                byBiome: {},
                byZHeight: {},
                density: {}
            };
            
            for (const staticObj of statics) {
                const biome = map[staticObj.relY]?.[staticObj.relX]?.biome || 'unknown';
                const z = map[staticObj.relY]?.[staticObj.relX]?.z || 0;
                
                if (!placement.byBiome[biome]) placement.byBiome[biome] = {};
                if (!placement.byBiome[biome][staticObj.hexId]) placement.byBiome[biome][staticObj.hexId] = 0;
                placement.byBiome[biome][staticObj.hexId]++;
                
                const zRange = Math.floor(z / 10) * 10;
                if (!placement.byZHeight[zRange]) placement.byZHeight[zRange] = {};
                if (!placement.byZHeight[zRange][staticObj.hexId]) placement.byZHeight[zRange][staticObj.hexId] = 0;
                placement.byZHeight[zRange][staticObj.hexId]++;
            }
            
            placement.density.total = statics.length;
            placement.density.perTile = statics.length / (width * height);
            
            return placement;
        }
        
        function analyzeZHeightPatterns(map, width, height) {
            const patterns = {
                ranges: {},
                transitions: []
            };
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const z = map[y][x].z || 0;
                    const zRange = Math.floor(z / 5) * 5;
                    if (!patterns.ranges[zRange]) patterns.ranges[zRange] = 0;
                    patterns.ranges[zRange]++;
                    
                    // Check for elevation changes
                    const neighbors = [
                        { z: map[y-1][x].z || 0, biome: map[y-1][x].biome },
                        { z: map[y+1][x].z || 0, biome: map[y+1][x].biome },
                        { z: map[y][x+1].z || 0, biome: map[y][x+1].biome },
                        { z: map[y][x-1].z || 0, biome: map[y][x-1].biome }
                    ];
                    
                    for (const neighbor of neighbors) {
                        const diff = Math.abs(z - neighbor.z);
                        if (diff > 2) {
                            patterns.transitions.push({
                                fromZ: z,
                                toZ: neighbor.z,
                                fromBiome: map[y][x].biome,
                                toBiome: neighbor.biome,
                                diff
                            });
                        }
                    }
                }
            }
            
            return patterns;
        }
        
        // Merge functions
        function mergeBiomeData(existing, newData) {
            const merged = { ...existing };
            for (const biome in newData) {
                if (!merged[biome]) {
                    merged[biome] = { ...newData[biome], tiles: new Set(newData[biome].tiles) };
                } else {
                    merged[biome].count += newData[biome].count;
                    merged[biome].zSum += newData[biome].zSum;
                    merged[biome].avgZ = merged[biome].zSum / merged[biome].count;
                    newData[biome].tiles.forEach(t => merged[biome].tiles.add(t));
                    merged[biome].tiles = Array.from(merged[biome].tiles);
                }
            }
            return merged;
        }
        
        function mergeStaticData(existing, newData) {
            return newData; // Simplified for now
        }
        
        function mergeZHeightData(existing, newData) {
            const merged = { ranges: { ...existing.ranges }, transitions: [...existing.transitions] };
            for (const range in newData.ranges) {
                merged.ranges[range] = (merged.ranges[range] || 0) + newData.ranges[range];
            }
            merged.transitions.push(...newData.transitions);
            return merged;
        }
        
        window.exportLearningData = function() {
            const dataStr = JSON.stringify(learningData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `uo_map_learning_data_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            document.getElementById('learningOutput').innerHTML += 
                '<div style="color: #4CAF50; margin-top: 10px;">âœ… Data exported!</div>';
        };
        
        window.clearLearningData = function() {
            learningData = {
                tileTransitions: {},
                biomeDistribution: {},
                embankmentPatterns: {},
                staticPlacements: {},
                zHeightPatterns: {},
                regionsAnalyzed: 0
            };
            document.getElementById('learningOutput').innerHTML = 
                '<div style="color: #9C27B0;">Data cleared. Ready for new analysis.</div>';
        };
        
        // Load Britain region (known good location with statics)
        window.loadBritainRegion = function() {
            loadRealUOMap(1400, 1600, 'Britain');
        };
        
        // Load coastline region (beach with sand/water transitions)
        window.loadLastRegion = function() {
            loadRealUOMap(3197, 18, 'Coastline');
        };
        
        // Load custom coordinates from input fields
        window.loadCustomCoords = function() {
            const x = parseInt(document.getElementById('customX').value) || 0;
            const y = parseInt(document.getElementById('customY').value) || 0;
            console.log(`[Custom] Loading coordinates: (${x}, ${y})`);
            loadRealUOMap(x, y, `Custom (${x},${y})`);
        };
        
        // ========================================
        // CHARACTER SYSTEM (Reuses PvP Character class!)
        // ========================================
        
        // Direction mappings - same as PvP system
        const DIRECTIONS = {
            n: { dx: 0, dy: -1, facing: 'north' },
            ne: { dx: 1, dy: -1, facing: 'northeast' },
            e: { dx: 1, dy: 0, facing: 'east' },
            se: { dx: 1, dy: 1, facing: 'southeast' },
            s: { dx: 0, dy: 1, facing: 'south' },
            sw: { dx: -1, dy: 1, facing: 'southwest' },
            w: { dx: -1, dy: 0, facing: 'west' },
            nw: { dx: -1, dy: -1, facing: 'northwest' }
        };
        
        // Load sprite with automatic background removal
        function tryLoadSprite(path) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    
                    // Get background color from top-left corner and make it transparent
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    const bgR = data[0], bgG = data[1], bgB = data[2];
                    
                    for (let i = 0; i < data.length; i += 4) {
                        // Make background color transparent (with tolerance)
                        if (Math.abs(data[i] - bgR) < 10 && 
                            Math.abs(data[i+1] - bgG) < 10 && 
                            Math.abs(data[i+2] - bgB) < 10) {
                            data[i+3] = 0;
                        }
                    }
                    ctx.putImageData(imageData, 0, 0);
                    resolve(canvas);
                };
                img.onerror = () => resolve(null);
                img.src = path;
            });
        }
        
        // Load all directional sprites INCLUDING walk animation frames
        async function loadAllCharacterSprites() {
            console.log('[Character] Loading character sprites with walk animations...');
            
            // Sprite folder fix: Each folder's sprites face one direction COUNTER-CLOCKWISE
            // from the folder name. To compensate, load from folder one step CLOCKWISE.
            // e.g., 's' folder has 'se'-facing sprites, so to get 's' sprites load from 'sw' folder
            const SPRITE_FOLDER_MAP = {
                'n': 'ne',    // n folder has nw sprites, ne folder has n sprites
                'ne': 'e',
                'e': 'se',
                'se': 's',
                's': 'sw',
                'sw': 'w',
                'w': 'nw',
                'nw': 'n'
            };
            
            for (const dir of Object.keys(DIRECTIONS)) {
                // Initialize sprite data structure
                characterSprites[dir] = {
                    idle: null,
                    walk: [],
                    run: []
                };
                
                // Get corrected folder to load from
                const folderDir = SPRITE_FOLDER_MAP[dir] || dir;
                
                // 1. Load idle sprite - try multiple paths
                const idlePaths = [
                    `assets/sprites/animations/idle-static_${folderDir}/Mob 400-0.bmp`,
                    `assets/sprites/animations/idle-static_${folderDir}/Mob 400.bmp`,
                    `assets/sprites/animations/walk_${folderDir}/Mob 400-0.bmp`,
                ];
                
                for (const path of idlePaths) {
                    const sprite = await tryLoadSprite(path);
                    if (sprite) {
                        characterSprites[dir].idle = sprite;
                        console.log(`[Character] Loaded ${dir} idle from: ${path} (folder: ${folderDir})`);
                        break;
                    }
                }
                
                // 2. Load walk animation frames (Mob 400-0.bmp through Mob 400-9.bmp)
                for (let frame = 0; frame < 10; frame++) {
                    const path = `assets/sprites/animations/walk_${folderDir}/Mob 400-${frame}.bmp`;
                    const sprite = await tryLoadSprite(path);
                    if (sprite) {
                        characterSprites[dir].walk.push(sprite);
                    }
                }
                
                // 3. Load run animation frames (if available)
                for (let frame = 0; frame < 10; frame++) {
                    const path = `assets/sprites/animations/run_${folderDir}/Mob 400-${frame}.bmp`;
                    const sprite = await tryLoadSprite(path);
                    if (sprite) {
                        characterSprites[dir].run.push(sprite);
                    }
                }
                
                console.log(`[Character] ${dir}: idle=${characterSprites[dir].idle ? 'âœ“' : 'âœ—'}, walk=${characterSprites[dir].walk.length} frames, run=${characterSprites[dir].run.length} frames`);
            }
            
            const loaded = Object.values(characterSprites).filter(s => s.idle).length;
            const totalWalkFrames = Object.values(characterSprites).reduce((sum, s) => sum + s.walk.length, 0);
            const totalRunFrames = Object.values(characterSprites).reduce((sum, s) => sum + s.run.length, 0);
            console.log(`[Character] Loaded ${loaded}/8 directions, ${totalWalkFrames} walk frames, ${totalRunFrames} run frames`);
            return loaded;
        }
        
        // Spawn character using the Character class from PvP
        window.spawnCharacter = async function() {
            if (!currentMap || !currentMap.length) {
                alert('Please generate or load a map first!');
                return;
            }
            
            document.getElementById('status').textContent = 'ğŸ­ Loading character sprites...';
            
            // Load sprites if not already loaded
            if (Object.keys(characterSprites).length === 0) {
                await loadAllCharacterSprites();
            }
            
            const mapHeight = currentMap.length;
            const mapWidth = currentMap[0].length;
            
            // Find a walkable spawn point using the proper isTileWalkable function
            let spawnX = Math.floor(mapWidth / 2);
            let spawnY = Math.floor(mapHeight / 2);
            let spawnZ = 0;
            let foundSpawn = false;
            
            // Search in expanding circles from center for a walkable spawn point
            for (let radius = 0; radius < Math.max(mapWidth, mapHeight) / 2 && !foundSpawn; radius++) {
                for (let dy = -radius; dy <= radius && !foundSpawn; dy++) {
                    for (let dx = -radius; dx <= radius && !foundSpawn; dx++) {
                        // Only check perimeter of the circle (optimization)
                        if (Math.abs(dx) !== radius && Math.abs(dy) !== radius) continue;
                        
                        const tx = Math.floor(mapWidth / 2) + dx;
                        const ty = Math.floor(mapHeight / 2) + dy;
                        
                        // Use the proper walkability check
                        if (isTileWalkable(tx, ty)) {
                            // Also check that we have walkable neighbors (not spawning on a single walkable tile)
                            let walkableNeighbors = 0;
                            for (const {dx: ndx, dy: ndy} of Object.values(DIRECTIONS)) {
                                if (isTileWalkable(tx + ndx, ty + ndy)) {
                                    walkableNeighbors++;
                                }
                            }
                            
                            if (walkableNeighbors >= 3) {
                                const tile = currentMap[ty]?.[tx];
                                spawnX = tx;
                                spawnY = ty;
                                spawnZ = tile?.z || 0;
                                foundSpawn = true;
                                console.log(`[Spawn] Found walkable spawn at (${tx}, ${ty}) with ${walkableNeighbors} walkable neighbors`);
                            }
                        }
                    }
                }
            }
            
            if (!foundSpawn) {
                console.warn('[Spawn] Could not find ideal spawn point, using map center');
                const centerTile = currentMap[spawnY]?.[spawnX];
                spawnZ = centerTile?.z || 0;
            }
            
            // Create character using the PvP Character class!
            playerCharacter = new Character(1, 'Player', spawnX, spawnY);
            playerCharacter.z = spawnZ;
            playerCharacter.direction = 's';
            // Use idle sprite from the new sprite structure
            playerCharacter.sprite = characterSprites['s']?.idle || characterSprites['s'];
            
            console.log(`[Character] Spawned at (${spawnX}, ${spawnY}, z=${spawnZ})`);
            console.log(`[Character] Sprite assigned:`, playerCharacter.sprite);
            console.log(`[Character] characterSprites['s']:`, characterSprites['s']);
            document.getElementById('status').textContent = `ğŸ§™ Character spawned! WASD/Arrows to move, Shift=run, Mouse wheel=zoom, Right-click+drag=move`;
            
            // Start game loop for smooth movement
            startGameLoop();
            
            // Render with Camera Follow (character centered)
            renderScene();
        };
        
        // ========================================
        // PVP-STYLE SMOOTH MOVEMENT SYSTEM
        // ========================================
        
        // Movement state (UO-authentic discrete tile-to-tile)
        let isMoving = false;
        let isRunning = false;
        let targetTileX = null;  // Final target tile (for pathfinding/continuous movement)
        let targetTileY = null;
        let nextTileX = null;    // Next immediate tile to move to (discrete step)
        let nextTileY = null;
        let movementProgress = 0; // 0-1 progress between current and next tile
        let movementStartX = 0;  // Starting position for current tile movement
        let movementStartY = 0;
        let movementStartZ = 0;
        let nextTileZ = 0;
        let animationFrame = 0;
        let animationTime = 0;   // Time-based animation tracking (ms)
        let lastFrameTime = performance.now();
        let gameLoopRunning = false;
        
        // UO movement constants (from ClassicUO source - authentic values)
        const TILE_SIZE = 1;  // We use tile coordinates, not pixels
        const WALK_MS_PER_TILE = 400;  // 400ms per tile walking (STEP_DELAY_WALK)
        const RUN_MS_PER_TILE = 200;   // 200ms per tile running (STEP_DELAY_RUN)
        const STOP_THRESHOLD = 0.05;   // Stop when within 5% of a tile
        
        // Animation timing - CONFIGURABLE via sidebar controls
        // Default to the smoother look: all frames, slower per-frame timing
        let WALK_ANIM_FRAME_DURATION = 110; // ms per frame (time-based or movement scaling)
        let RUN_ANIM_FRAME_DURATION = 70;   // ms per frame
        let FRAME_SELECTION_MODE = 'all';   // Play every exported frame (0-9)
        let ANIM_SYNC_MODE = 'time';        // Default to time-based for smoother pacing
        
        const RUN_DISTANCE_THRESHOLD = 100; // Pixels from character to trigger run (UO-style)
        
        // Animation control functions
        function updateAnimationMode() {
            const mode = document.getElementById('animModeSelect').value;
            switch(mode) {
                case 'classic':
                    WALK_ANIM_FRAME_DURATION = 80;
                    RUN_ANIM_FRAME_DURATION = 80;
                    FRAME_SELECTION_MODE = 'skip2';
                    ANIM_SYNC_MODE = 'movement';
                    break;
                case 'smooth':
                    WALK_ANIM_FRAME_DURATION = 110;
                    RUN_ANIM_FRAME_DURATION = 70;
                    FRAME_SELECTION_MODE = 'all'; // Use every exported frame
                    ANIM_SYNC_MODE = 'time'; // decoupled from tile travel for smoother legs
                    break;
                case 'fast':
                    WALK_ANIM_FRAME_DURATION = 60;
                    RUN_ANIM_FRAME_DURATION = 40;
                    FRAME_SELECTION_MODE = 'all';
                    ANIM_SYNC_MODE = 'time';
                    break;
                case 'custom':
                    // Keep current slider values
                    break;
            }
            // Update sliders to reflect new values
            document.getElementById('walkFrameSlider').value = WALK_ANIM_FRAME_DURATION;
            document.getElementById('walkFrameLabel').textContent = WALK_ANIM_FRAME_DURATION;
            document.getElementById('runFrameSlider').value = RUN_ANIM_FRAME_DURATION;
            document.getElementById('runFrameLabel').textContent = RUN_ANIM_FRAME_DURATION;
            document.getElementById('frameSkipSelect').value = FRAME_SELECTION_MODE;
            document.getElementById('animSyncSelect').value = ANIM_SYNC_MODE;
            console.log(`Animation mode: ${mode} - Walk: ${WALK_ANIM_FRAME_DURATION}ms, Run: ${RUN_ANIM_FRAME_DURATION}ms, Selection: ${FRAME_SELECTION_MODE}, Sync: ${ANIM_SYNC_MODE}`);
        }
        
        function updateWalkFrameDuration() {
            const slider = document.getElementById('walkFrameSlider');
            WALK_ANIM_FRAME_DURATION = parseInt(slider.value);
            document.getElementById('walkFrameLabel').textContent = WALK_ANIM_FRAME_DURATION;
            document.getElementById('animModeSelect').value = 'custom';
        }
        
        function updateRunFrameDuration() {
            const slider = document.getElementById('runFrameSlider');
            RUN_ANIM_FRAME_DURATION = parseInt(slider.value);
            document.getElementById('runFrameLabel').textContent = RUN_ANIM_FRAME_DURATION;
            document.getElementById('animModeSelect').value = 'custom';
        }
        
        function updateFrameSkip() {
            FRAME_SELECTION_MODE = document.getElementById('frameSkipSelect').value;
            document.getElementById('animModeSelect').value = 'custom';
            console.log(`Frame selection: ${FRAME_SELECTION_MODE}`);
        }
        
        function updateAnimSync() {
            ANIM_SYNC_MODE = document.getElementById('animSyncSelect').value;
            document.getElementById('animModeSelect').value = 'custom';
            console.log(`Animation sync: ${ANIM_SYNC_MODE}`);
        }
        
        // Helper: Get frame index based on selection mode
        function getAnimationFrameIndex(frames, logicalFrame) {
            if (!frames || frames.length === 0) return 0;
            
            switch (FRAME_SELECTION_MODE) {
                case 'all':
                    return logicalFrame % frames.length;
                case 'skip2':
                    // Use frames 0, 2, 4, 6, 8 (5 frames from 10)
                    const effectiveCount = Math.ceil(frames.length / 2);
                    return Math.min((logicalFrame % effectiveCount) * 2, frames.length - 1);
                case 'first5':
                    // Use only first 5 frames (0, 1, 2, 3, 4)
                    return logicalFrame % Math.min(5, frames.length);
                case 'last5':
                    // Use only last 5 frames (5, 6, 7, 8, 9)
                    const start = Math.max(0, frames.length - 5);
                    return start + (logicalFrame % Math.min(5, frames.length - start));
                default:
                    return logicalFrame % frames.length;
            }
        }
        
        // Helper: Get effective frame count based on selection mode
        function getEffectiveFrameCount(frames) {
            if (!frames || frames.length === 0) return 1;
            
            switch (FRAME_SELECTION_MODE) {
                case 'all': return frames.length;
                case 'skip2': return Math.ceil(frames.length / 2);
                case 'first5': return Math.min(5, frames.length);
                case 'last5': return Math.min(5, frames.length);
                default: return frames.length;
            }
        }
        
        // Get direction from screen pixel deltas (UO isometric style)
        // Character should face TOWARD the click position
        // In UO isometric: North is UP-RIGHT, East is DOWN-RIGHT, South is DOWN-LEFT, West is UP-LEFT
        function getDirectionFromScreenPixels(screenDx, screenDy) {
            // Calculate angle toward the click (0Â° = right, 90Â° = down, 180Â° = left, 270Â° = up)
            const angle = Math.atan2(screenDy, screenDx);
            const degrees = ((angle * 180 / Math.PI) + 360) % 360;
            
            // UO ISOMETRIC direction mapping (rotated 45Â° from screen)
            // The UO world is rotated 45Â° relative to screen coordinates:
            // - Screen RIGHT (0Â°) â†’ NE in game (tile X-, Y-)
            // - Screen DOWN-RIGHT (45Â°) â†’ E in game
            // - Screen DOWN (90Â°) â†’ SE in game (tile X-, Y+)
            // - Screen DOWN-LEFT (135Â°) â†’ S in game
            // - Screen LEFT (180Â°) â†’ SW in game (tile X+, Y+)
            // - Screen UP-LEFT (225Â°) â†’ W in game
            // - Screen UP (270Â°) â†’ NW in game (tile X+, Y-)
            // - Screen UP-RIGHT (315Â°) â†’ N in game
            if (degrees >= 337.5 || degrees < 22.5) return 'ne';   // Click right â†’ NE
            if (degrees >= 22.5 && degrees < 67.5) return 'e';     // Click down-right â†’ E
            if (degrees >= 67.5 && degrees < 112.5) return 'se';   // Click down â†’ SE
            if (degrees >= 112.5 && degrees < 157.5) return 's';   // Click down-left â†’ S
            if (degrees >= 157.5 && degrees < 202.5) return 'sw';  // Click left â†’ SW
            if (degrees >= 202.5 && degrees < 247.5) return 'w';   // Click up-left â†’ W
            if (degrees >= 247.5 && degrees < 292.5) return 'nw';  // Click up â†’ NW
            if (degrees >= 292.5 && degrees < 337.5) return 'n';   // Click up-right â†’ N
            return 'se'; // Default
        }
        
        // Get direction from tile deltas (used for keyboard discrete movement)
        function getDirectionFromTileDelta(tileDx, tileDy) {
            // Convert tile delta to approximate screen direction for consistent behavior
            // In UO: +X tile = SE screen, +Y tile = SW screen
            const screenDx = tileDx - tileDy;  // Maps to screen X direction
            const screenDy = tileDx + tileDy;  // Maps to screen Y direction
            return getDirectionFromScreenPixels(screenDx, screenDy);
        }
        
        // Get direction from discrete dx/dy (for keyboard) - uses tile delta conversion
        function getDirectionFromDelta(dx, dy) {
            return getDirectionFromTileDelta(dx, dy);
        }
        
        // Check if a tile is walkable
        let walkDebugCount = 0;
        function isTileWalkable(x, y) {
            if (!currentMap) return false;
            if (x < 0 || x >= currentMap[0].length || y < 0 || y >= currentMap.length) return false;
            
            const tileX = Math.floor(x);
            const tileY = Math.floor(y);
            const tile = currentMap[tileY]?.[tileX];
            if (!tile) return false;
            
            // Check LandData.csv flags
            const tileId = typeof tile.id === 'string' ? parseInt(tile.id, 16) : tile.id;
            if (landTileData && landTileData.size > 0) {
                const landData = landTileData.get(tileId);
                if (landData) {
                    // Check Impassible flag (handle both number 1 and string "1")
                    const isImpassible = landData.Impassible === 1 || landData.Impassible === '1';
                    if (isImpassible) {
                        if (walkDebugCount++ < 3) console.log(`[Walk] Blocked: Impassible tile ${tileId} at (${tileX},${tileY})`);
                        return false;
                    }
                    
                    // Check Wet flag for water tiles (UO uses both Impassible and Wet for water)
                    const isWet = landData.Wet === 1 || landData.Wet === '1';
                    if (isWet) {
                        if (walkDebugCount++ < 3) console.log(`[Walk] Blocked: Wet tile ${tileId} at (${tileX},${tileY})`);
                        return false;
                    }
                }
            }
            
            // Also check biome-based water (for procedurally generated maps)
            if (tile.isWater || tile.biome === 'water' || tile.biome === 'deep_water') {
                if (walkDebugCount++ < 3) console.log(`[Walk] Blocked: Water biome at (${tileX},${tileY})`);
                return false;
            }
            
            // TEMPORARILY DISABLE static blocking for testing movement
            // TODO: Re-enable with proper impassable static detection
            /*
            if (currentStatics && currentStatics.length > 0) {
                const blockingStatics = currentStatics.filter(s => {
                    let staticX, staticY;
                    if (s.relX !== undefined && s.relY !== undefined) {
                        staticX = Math.floor(s.relX);
                        staticY = Math.floor(s.relY);
                    } else if (s.x !== undefined && s.y !== undefined) {
                        staticX = Math.floor(s.x);
                        staticY = Math.floor(s.y);
                    } else {
                        return false;
                    }
                    return staticX === tileX && staticY === tileY;
                });
                
                if (blockingStatics.length > 0) {
                    if (walkDebugCount++ < 3) console.log(`[Walk] Blocked: Static at (${tileX},${tileY})`);
                    return false;
                }
            }
            */
            
            // Check Z-height difference (can't walk up/down cliffs) - be more lenient
            if (playerCharacter) {
                const currentTileX = Math.floor(playerCharacter.x);
                const currentTileY = Math.floor(playerCharacter.y);
                const currentTile = currentMap[currentTileY]?.[currentTileX];
                const currentZ = currentTile?.z || playerCharacter.z || 0;
                const targetZ = tile.z || 0;
                const zDiff = Math.abs(targetZ - currentZ);
                
                // Allow more Z movement (5 units instead of 2)
                if (zDiff > 5) {
                    if (walkDebugCount++ < 3) console.log(`[Walk] Blocked: Z diff ${zDiff} at (${tileX},${tileY})`);
                    return false;
                }
            }
            
            return true;
        }
        
        // Render the scene with Camera Follow (character always centered)
        function renderScene() {
            if (!webglRenderer || !currentCornerHeights || !currentMap) return;
            
            // If character exists, use Camera Follow mode (character centered)
            if (playerCharacter) {
                const cameraTarget = {
                    x: playerCharacter.x,
                    y: playerCharacter.y
                };
                
                // Render terrain centered on character
                webglRenderer.renderWithCamera(
                    currentMap, 
                    currentCornerHeights, 
                    cameraTarget, 
                    null,
                    cameraZoom,
                    currentStatics.length > 0 ? currentStatics : null
                );
                
                // Render character on 2D canvas overlay (more reliable than WebGL for debugging)
                renderCharacterOverlay();
            } else {
                // No character - render normally
                webglRenderer.render(currentMap, currentCornerHeights, null, currentStatics.length > 0 ? currentStatics : null);
            }
        }
        
        // Render character on 2D canvas overlay (simpler and more reliable)
        function renderCharacterOverlay() {
            if (!playerCharacter || !playerCharacter.sprite) return;
            
            let overlayCanvas = document.getElementById('character-overlay-canvas');
            const webglCanvasEl = document.getElementById('webgl-canvas');
            if (!webglCanvasEl) return;
            
            // Create overlay canvas if it doesn't exist
            if (!overlayCanvas) {
                overlayCanvas = document.createElement('canvas');
                overlayCanvas.id = 'character-overlay-canvas';
                overlayCanvas.style.position = 'absolute';
                overlayCanvas.style.top = '0';
                overlayCanvas.style.left = '0';
                overlayCanvas.style.pointerEvents = 'none';
                overlayCanvas.style.zIndex = '10';
                webglCanvasEl.parentElement.appendChild(overlayCanvas);
            }
            
            // Match WebGL canvas size
            overlayCanvas.width = webglCanvasEl.width;
            overlayCanvas.height = webglCanvasEl.height;
            
            const ctx = overlayCanvas.getContext('2d');
            ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            
            const sprite = playerCharacter.sprite;
            const zoom = cameraZoom;
            
            // Get sprite dimensions
            let spriteW = sprite.width || 64;
            let spriteH = sprite.height || 64;
            
            // Character is always centered in camera follow mode
            const viewWidth = overlayCanvas.width;
            const viewHeight = overlayCanvas.height;
            const zOffset = (playerCharacter.z || 0) * 4 * zoom; // 4 pixels per Z level

            // Feet should sit on the same line as the tile base (center + 22px, scaled by zoom)
            const feetY = (viewHeight / 2 + 22 * zoom) - zOffset;
            const screenX = (viewWidth / 2) - (spriteW * zoom / 2);
            const screenY = feetY - (spriteH * zoom);
            
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(sprite, screenX, screenY, spriteW * zoom, spriteH * zoom);
            
            // Debug: Draw red dot at character center
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(viewWidth / 2, feetY, 5, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw UO isometric compass in corner (helps understand direction mapping)
            const compassX = 80;
            const compassY = viewHeight - 100;
            const compassR = 50;
            
            // Draw compass circle
            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(compassX, compassY, compassR, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw compass directions (UO isometric - rotated 45Â° from screen)
            const compassDirs = {
                'N': [compassR * 0.7, -compassR * 0.7],   // Up-right
                'NE': [compassR, 0],                       // Right
                'E': [compassR * 0.7, compassR * 0.7],    // Down-right
                'SE': [0, compassR],                       // Down
                'S': [-compassR * 0.7, compassR * 0.7],   // Down-left
                'SW': [-compassR, 0],                      // Left
                'W': [-compassR * 0.7, -compassR * 0.7],  // Up-left
                'NW': [0, -compassR]                       // Up
            };
            
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            for (const [dir, [dx, dy]] of Object.entries(compassDirs)) {
                const isActive = playerCharacter.direction.toUpperCase() === dir.toLowerCase() || 
                                 playerCharacter.direction.toLowerCase() === dir.toLowerCase();
                ctx.fillStyle = isActive ? 'lime' : 'rgba(255,255,255,0.7)';
                ctx.fillText(dir, compassX + dx, compassY + dy);
            }
            
            // Compass center label
            ctx.fillStyle = 'white';
            ctx.font = '10px Arial';
            ctx.fillText('UO', compassX, compassY);
            
            // Debug: Draw direction arrow from character (UO isometric directions)
            // In UO isometric: N=up-right, E=down-right, S=down-left, W=up-left
            const dirArrows = {
                'n': [21, -21],   // North = up-right on screen
                'ne': [30, 0],   // Northeast = right on screen
                'e': [21, 21],   // East = down-right on screen
                'se': [0, 30],   // Southeast = down on screen
                's': [-21, 21],  // South = down-left on screen
                'sw': [-30, 0],  // Southwest = left on screen
                'w': [-21, -21], // West = up-left on screen
                'nw': [0, -30]   // Northwest = up on screen
            };
            const arrow = dirArrows[playerCharacter.direction] || [0, 0];
            ctx.strokeStyle = 'lime';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(viewWidth / 2, feetY);
            ctx.lineTo(viewWidth / 2 + arrow[0], feetY + arrow[1]);
            ctx.stroke();
            
            // Debug: Draw character position text
            ctx.fillStyle = 'yellow';
            ctx.font = '14px monospace';
            ctx.fillText(`Pos: (${playerCharacter.x.toFixed(1)}, ${playerCharacter.y.toFixed(1)}, z=${playerCharacter.z || 0})`, 10, 20);
            ctx.fillText(`Dir: ${playerCharacter.direction} | Running: ${isRunning} | Moving: ${isMoving}`, 10, 40);
            
            // Animation Debug Panel (bottom-right corner)
            const debugX = viewWidth - 280;
            const debugY = 20;
            
            // Draw debug panel background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(debugX - 10, debugY - 15, 280, 175);
            ctx.strokeStyle = 'cyan';
            ctx.lineWidth = 2;
            ctx.strokeRect(debugX - 10, debugY - 15, 280, 180);
            
            ctx.fillStyle = 'cyan';
            ctx.font = 'bold 14px monospace';
            ctx.fillText('ANIMATION DEBUG', debugX, debugY);
            
            ctx.fillStyle = 'white';
            ctx.font = '12px monospace';
            
            // Get current animation data
            const dirSprites = characterSprites[playerCharacter.direction];
            const frames = isRunning ? (dirSprites?.run || dirSprites?.walk || []) : (dirSprites?.walk || []);
            const effectiveFrameCount = getEffectiveFrameCount(frames);
            const currentFrameDuration = isRunning ? RUN_ANIM_FRAME_DURATION : WALK_ANIM_FRAME_DURATION;
            
            let logicalFrame;
            if (ANIM_SYNC_MODE === 'movement') {
                logicalFrame = Math.floor(movementProgress * effectiveFrameCount);
                logicalFrame = Math.min(logicalFrame, effectiveFrameCount - 1);
            } else {
                logicalFrame = Math.floor(animationTime / currentFrameDuration) % effectiveFrameCount;
            }
            const actualFrameIndex = getAnimationFrameIndex(frames, logicalFrame);
            const fps = 1000 / currentFrameDuration;
            const cycleTime = effectiveFrameCount * currentFrameDuration;
            
            ctx.fillText(`Mode: ${FRAME_SELECTION_MODE} | Sync: ${ANIM_SYNC_MODE}`, debugX, debugY + 20);
            ctx.fillText(`Frame Duration: ${currentFrameDuration}ms`, debugX, debugY + 35);
            ctx.fillText(`Total: ${frames.length} | Effective: ${effectiveFrameCount}`, debugX, debugY + 50);
            ctx.fillText(`Logical: ${logicalFrame} â†’ Actual: ${actualFrameIndex}`, debugX, debugY + 65);
            ctx.fillText(`Anim Time: ${animationTime.toFixed(0)}ms`, debugX, debugY + 80);
            ctx.fillText(`Movement: ${(movementProgress * 100).toFixed(0)}%`, debugX, debugY + 95);
            ctx.fillText(`Cycle: ${cycleTime}ms | FPS: ${fps.toFixed(1)}`, debugX, debugY + 110);
            ctx.fillText(`Running: ${isRunning} | Moving: ${isMoving}`, debugX, debugY + 125);
            
            // Visual frame indicator (boxes showing which frames are used)
            const frameBoxY = debugY + 140;
            const frameBoxSize = 15;
            for (let i = 0; i < Math.min(frames.length, 15); i++) {
                // Determine if this frame index is used based on current selection mode
                let isUsed = false;
                switch (FRAME_SELECTION_MODE) {
                    case 'all': isUsed = true; break;
                    case 'skip2': isUsed = (i % 2 === 0); break; // 0, 2, 4, 6, 8
                    case 'first5': isUsed = (i < 5); break; // 0, 1, 2, 3, 4
                    case 'last5': isUsed = (i >= frames.length - 5); break; // 5, 6, 7, 8, 9
                    default: isUsed = true;
                }
                const isCurrent = (i === actualFrameIndex);
                
                ctx.fillStyle = isCurrent ? 'lime' : (isUsed ? 'cyan' : 'gray');
                ctx.fillRect(debugX + i * (frameBoxSize + 2), frameBoxY, frameBoxSize, frameBoxSize);
                
                ctx.fillStyle = 'black';
                ctx.font = '8px monospace';
                ctx.fillText(i.toString(), debugX + i * (frameBoxSize + 2) + 3, frameBoxY + 11);
            }
        }
        
        // UO-authentic discrete tile-to-tile movement update (called every frame)
        function updateCharacterMovement(deltaTime) {
            if (!playerCharacter || !currentMap) return;
            
            // If we don't have a next tile yet, calculate one from the target
            if (nextTileX === null || nextTileY === null) {
                if (targetTileX === null || targetTileY === null) {
                    return; // No movement target
                }
                
                // Calculate direction to target
                const dx = targetTileX - Math.round(playerCharacter.x);
                const dy = targetTileY - Math.round(playerCharacter.y);
                
                if (dx === 0 && dy === 0) {
                    // Already at target - stop
                    targetTileX = null;
                    targetTileY = null;
                    isMoving = false;
                    animationTime = 0;  // Reset animation
                    const dirSprites = characterSprites[playerCharacter.direction];
                    playerCharacter.sprite = dirSprites?.idle || dirSprites;
                    return;
                }
                
                // Use the FACING DIRECTION to determine movement step
                // This ensures movement matches the visual direction indicator
                // DIRECTIONS maps direction name to tile delta (dx, dy)
                const dirDelta = DIRECTIONS[playerCharacter.direction];
                let stepX = dirDelta ? dirDelta.dx : 0;
                let stepY = dirDelta ? dirDelta.dy : 0;
                
                // Fallback to raw delta if no direction set
                if (stepX === 0 && stepY === 0) {
                    stepX = dx === 0 ? 0 : (dx > 0 ? 1 : -1);
                    stepY = dy === 0 ? 0 : (dy > 0 ? 1 : -1);
                }
                
                const checkX = Math.round(playerCharacter.x) + stepX;
                const checkY = Math.round(playerCharacter.y) + stepY;
                
                if (!isTileWalkable(checkX, checkY)) {
                    // Try cardinal direction if diagonal is blocked
                    if (stepX !== 0 && stepY !== 0) {
                        // Try horizontal first
                        if (isTileWalkable(Math.round(playerCharacter.x) + stepX, Math.round(playerCharacter.y))) {
                            nextTileX = Math.round(playerCharacter.x) + stepX;
                            nextTileY = Math.round(playerCharacter.y);
                        } else if (isTileWalkable(Math.round(playerCharacter.x), Math.round(playerCharacter.y) + stepY)) {
                            nextTileX = Math.round(playerCharacter.x);
                            nextTileY = Math.round(playerCharacter.y) + stepY;
                        } else {
                            // Blocked - stop
                            targetTileX = null;
                            targetTileY = null;
                            isMoving = false;
                            console.log(`[Movement] Blocked at (${checkX}, ${checkY})`);
                            return;
                        }
                    } else {
                        // Blocked - stop
                        targetTileX = null;
                        targetTileY = null;
                        isMoving = false;
                        console.log(`[Movement] Blocked at (${checkX}, ${checkY})`);
                        return;
                    }
                } else {
                    nextTileX = checkX;
                    nextTileY = checkY;
                }
                
                // Start new tile movement
                movementStartX = Math.round(playerCharacter.x);
                movementStartY = Math.round(playerCharacter.y);
                movementStartZ = currentMap[movementStartY]?.[movementStartX]?.z || playerCharacter.z || 0;
                const upcomingTile = currentMap[nextTileY]?.[nextTileX];
                nextTileZ = upcomingTile?.z ?? movementStartZ;
                movementProgress = 0;
                
                // Set direction based on ACTUAL movement (tile delta)
                // This ensures the character faces the direction they're actually moving
                // regardless of whether input is mouse or keyboard
                playerCharacter.direction = getDirectionFromDelta(nextTileX - movementStartX, nextTileY - movementStartY);
                isMoving = true;
            }
            
            // Update movement progress (UO-authentic timing)
            const msPerTile = isRunning ? RUN_MS_PER_TILE : WALK_MS_PER_TILE;
            movementProgress += deltaTime / msPerTile;
            
            // Interpolate position between tiles (smooth visual, but discrete tile snapping)
            if (movementProgress >= 1.0) {
                // Arrived at next tile - snap to it
                playerCharacter.x = nextTileX;
                playerCharacter.y = nextTileY;
                
                // Update Z from new tile
                const newTile = currentMap[nextTileY]?.[nextTileX];
                if (newTile) {
                    playerCharacter.z = newTile.z || 0;
                } else {
                    playerCharacter.z = nextTileZ;
                }
                movementStartZ = playerCharacter.z;
                
                // Reset for next tile movement
                nextTileX = null;
                nextTileY = null;
                movementProgress = 0;
                animationFrame = 0; // Reset logical progress, but keep time running so frames continue
                
                // Check if we've reached the final target
                if (targetTileX !== null && targetTileY !== null) {
                    const distToTarget = Math.abs(targetTileX - playerCharacter.x) + Math.abs(targetTileY - playerCharacter.y);
                    if (distToTarget < 0.5) {
                        // Reached target - stop
                        targetTileX = null;
                        targetTileY = null;
                        isMoving = false;
                        animationTime = 0;  // Reset animation
                        const dirSprites = characterSprites[playerCharacter.direction];
                        playerCharacter.sprite = dirSprites?.idle || dirSprites;
                    }
                }
            } else {
                // Interpolate position for smooth visual
                playerCharacter.x = movementStartX + (nextTileX - movementStartX) * movementProgress;
                playerCharacter.y = movementStartY + (nextTileY - movementStartY) * movementProgress;
                playerCharacter.z = movementStartZ + (nextTileZ - movementStartZ) * movementProgress;
                
                // Update animation frame
                // Supports two modes: time-based (independent) or movement-synced (UO style)
                animationTime += deltaTime;
                
                const dirSprites = characterSprites[playerCharacter.direction];
                const frames = isRunning ? (dirSprites?.run || dirSprites?.walk || []) : (dirSprites?.walk || []);
                
                if (frames.length > 0) {
                    const effectiveFrameCount = getEffectiveFrameCount(frames);
                    let logicalFrame;
                    
                    if (ANIM_SYNC_MODE === 'movement') {
                        // Movement-synced: Animation progress matches movement progress
                        // This ensures animation completes exactly when reaching next tile
                        logicalFrame = Math.floor(movementProgress * effectiveFrameCount);
                        // Clamp to prevent overflow at progress=1.0
                        logicalFrame = Math.min(logicalFrame, effectiveFrameCount - 1);
                    } else {
                        // Time-based: Animation runs independently
                        const frameDuration = isRunning ? RUN_ANIM_FRAME_DURATION : WALK_ANIM_FRAME_DURATION;
                        logicalFrame = Math.floor(animationTime / frameDuration) % effectiveFrameCount;
                    }
                    
                    const actualFrameIndex = getAnimationFrameIndex(frames, logicalFrame);
                    
                    // Debug: Log frame sequence every 200ms
                    if (!window.lastFrameLog || Date.now() - window.lastFrameLog > 200) {
                        console.log(`[Anim] Time: ${animationTime.toFixed(0)}ms, Logical: ${logicalFrame}, Actual: ${actualFrameIndex}, Mode: ${FRAME_SELECTION_MODE}, Frames: ${frames.length}`);
                        window.lastFrameLog = Date.now();
                    }
                    
                    playerCharacter.sprite = frames[actualFrameIndex];
                }
            }
        }
        
        // Game loop (UO-authentic - continuous updates at 60fps)
        function gameLoop() {
            if (!gameLoopRunning) return;
            
            const now = performance.now();
            const deltaTime = now - lastFrameTime;
            lastFrameTime = now;
            
            // Update continuous movement if right-click is held (UO-style)
            if (rightMouseHeld) {
                updateContinuousMovement();
            }
            
            // Update character movement
            if (playerCharacter) {
                if (targetTileX !== null || isMoving) {
                    updateCharacterMovement(deltaTime);
                }
                // ALWAYS render when character exists (camera follow mode)
                renderScene();
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Start the game loop
        function startGameLoop() {
            if (!gameLoopRunning) {
                gameLoopRunning = true;
                lastFrameTime = performance.now();
                gameLoop();
                console.log('[GameLoop] Started PvP-style movement loop');
            }
        }
        
        // Move character to a target tile (smooth movement)
        function moveToTile(tileX, tileY) {
            if (!playerCharacter || !currentMap) return;
            
            // Bounds check
            if (tileX < 0 || tileX >= currentMap[0].length || tileY < 0 || tileY >= currentMap.length) {
                return;
            }
            
            // Check if destination is walkable
            if (!isTileWalkable(tileX, tileY)) {
                console.log(`[Movement] Target (${tileX}, ${tileY}) is not walkable`);
                return;
            }
            
            targetTileX = tileX;
            targetTileY = tileY;
            isMoving = true;
            startGameLoop();
        }
        
        // Handle right-mouse drag movement (UO-authentic - follow cursor)
        // rightMouseHeld tracks continuous right-click hold
        let rightMouseHeld = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        function handleMouseMove(mouseX, mouseY) {
            if (!playerCharacter || !currentMap) return;
            
            lastMouseX = mouseX;
            lastMouseY = mouseY;
            
            // Only process if right mouse is held down (UO-style continuous movement)
            if (!rightMouseDown && !rightMouseHeld) return;
            
            const tile = screenToTile(mouseX, mouseY);
            if (!tile) return;
            
            // Get character screen position (center of viewport in camera follow mode)
            const webglCanvasEl = document.getElementById('webgl-canvas');
            const charScreenX = (webglCanvasEl?.width || 800) / 2;
            const charScreenY = (webglCanvasEl?.height || 600) / 2;
            
            // Calculate PIXEL distance from character to cursor (UO-authentic)
            const pixelDx = mouseX - charScreenX;
            const pixelDy = mouseY - charScreenY;
            const pixelDistance = Math.sqrt(pixelDx * pixelDx + pixelDy * pixelDy);
            
            const zoom = cameraZoom || 1;
            const spacing = 22;
            const normDx = pixelDx / zoom;
            const normDy = pixelDy / zoom;
            const tileOffsetX = (normDx + normDy) / (2 * spacing);
            const tileOffsetY = (normDy - normDx) / (2 * spacing);
            const tileDistancePrecise = Math.sqrt(tileOffsetX * tileOffsetX + tileOffsetY * tileOffsetY);
            
            // Calculate tile distance for movement threshold
            const dx = tile.x - playerCharacter.x;
            const dy = tile.y - playerCharacter.y;
            const tileDistance = Math.sqrt(dx * dx + dy * dy);
            
            // UO-authentic: ALWAYS update direction when clicking (character turns to face)
            // Only update direction if cursor is far enough to determine a clear direction
            if (pixelDistance > 15) {
                const clickDir = getDirectionFromScreenPixels(pixelDx, pixelDy);
                console.log(`[Click Debug] Screen delta: (${pixelDx.toFixed(0)}, ${pixelDy.toFixed(0)}), Target tile: (${tile.x}, ${tile.y}), Tile delta: (${dx.toFixed(1)}, ${dy.toFixed(1)}), Direction: ${clickDir}`);
                playerCharacter.direction = clickDir;
            }
            
            // Movement threshold: Only move if click is far enough away
            // In UO, clicking very close just turns you, doesn't make you walk
        const MOVE_PIXEL_THRESHOLD = 60;  // Pixels from character before moving (at 1x zoom)
        const TURN_TILE_THRESHOLD = 0.95; // Fractional tile distance before walking
        const RUN_TILE_THRESHOLD = 2.5;   // Tiles away to trigger running (zoom-independent)
            
            const movePixelThreshold = MOVE_PIXEL_THRESHOLD * zoom;
            if (pixelDistance > movePixelThreshold && tileDistancePrecise > TURN_TILE_THRESHOLD) {
                // Set walk/run based on TILE distance (consistent across zoom levels)
                // Close = walk, far = run (UO-authentic behavior)
                isRunning = tileDistancePrecise >= RUN_TILE_THRESHOLD;
                
                targetTileX = tile.x;
                targetTileY = tile.y;
                isMoving = true;
                startGameLoop();
            } else if (tileDistancePrecise <= TURN_TILE_THRESHOLD) {
                // Close click - just turn, don't move
                isMoving = false;
                isRunning = false;  // Not moving = not running
                targetTileX = null;
                targetTileY = null;
                animationTime = 0;  // Reset animation
                
                // Update sprite to idle in the new direction
                const dirSprites = characterSprites[playerCharacter.direction];
                if (dirSprites?.idle) {
                    playerCharacter.sprite = dirSprites.idle;
                }
                
                // Re-render to show the turn
                renderScene();
            }
        }
        
        // Continuous movement update for held right-click (UO-authentic)
        function updateContinuousMovement() {
            if (rightMouseHeld && playerCharacter) {
                handleMouseMove(lastMouseX, lastMouseY);
            }
        }
        
        // Move one tile in a direction (for keyboard)
        function moveOneStep(direction) {
            if (!playerCharacter || !currentMap) return;
            
            const dir = DIRECTIONS[direction];
            if (!dir) return;
            
            const newX = Math.round(playerCharacter.x) + dir.dx;
            const newY = Math.round(playerCharacter.y) + dir.dy;
            
            moveToTile(newX, newY);
        }
        
        // Convert screen coordinates to tile coordinates (Camera Follow aware)
        function screenToTile(screenX, screenY) {
            if (!webglRenderer || !playerCharacter) return null;
            
            const spacing = 22;
            const zoom = cameraZoom;
            
            // In Camera Follow mode, the character is at the center of the screen
            // We need to calculate what tile the click position corresponds to
            
            // Get the center of the viewport (where the character is)
            const webglCanvas = document.getElementById('webgl-canvas');
            const viewWidth = webglCanvas?.width || 800;
            const viewHeight = webglCanvas?.height || 600;
            const centerX = viewWidth / 2;
            const centerY = viewHeight / 2;
            
            // Calculate offset from center (in pixels, accounting for zoom)
            const deltaX = (screenX - centerX) / zoom;
            const deltaY = (screenY - centerY) / zoom;
            
            // Convert pixel offset to tile offset using inverse isometric
            // The rendering formula is:
            //   screenX = (tileX - tileY) * spacing * zoom + offset
            //   screenY = (tileX + tileY) * spacing * zoom + offset
            // Inverse (for delta from center):
            //   tileOffsetX = (deltaX + deltaY) / (2 * spacing)
            //   tileOffsetY = (deltaY - deltaX) / (2 * spacing)
            
            const tileOffsetX = (deltaX + deltaY) / (2 * spacing);
            const tileOffsetY = (deltaY - deltaX) / (2 * spacing);
            
            // Add to character position
            const tileX = Math.round(playerCharacter.x + tileOffsetX);
            const tileY = Math.round(playerCharacter.y + tileOffsetY);
            
            // Debug logging (remove after fixing)
            console.log(`[screenToTile] Click: (${screenX.toFixed(0)}, ${screenY.toFixed(0)}), Center: (${centerX.toFixed(0)}, ${centerY.toFixed(0)}), Delta: (${deltaX.toFixed(1)}, ${deltaY.toFixed(1)}), TileOffset: (${tileOffsetX.toFixed(2)}, ${tileOffsetY.toFixed(2)}), Result: (${tileX}, ${tileY})`);
            
            return { x: tileX, y: tileY };
        }
        
        
        // Keyboard controls - UO-style SCREEN-BASED movement
        // In UO isometric, arrow keys move in SCREEN directions:
        // - Up arrow = move toward top of screen (Northwest in game)
        // - Down arrow = move toward bottom of screen (Southeast in game)
        // - Left arrow = move toward left of screen (Southwest in game)
        // - Right arrow = move toward right of screen (Northeast in game)
        document.addEventListener('keydown', (e) => {
            if (!playerCharacter) return;
            
            let direction = null;
            
            // Screen-based movement (classic UO style)
            const keyMap = {
                'ArrowUp': 'nw', 'KeyW': 'nw',      // Screen up = Northwest
                'ArrowDown': 'se', 'KeyS': 'se',    // Screen down = Southeast
                'ArrowLeft': 'sw', 'KeyA': 'sw',    // Screen left = Southwest
                'ArrowRight': 'ne', 'KeyD': 'ne',   // Screen right = Northeast
            };
            
            direction = keyMap[e.code];
            
            // Game-direction diagonals with Q/E/Z/C (for 8-direction movement)
            if (e.code === 'KeyQ') direction = 'w';   // Q = West (up-left on screen)
            if (e.code === 'KeyE' && !e.shiftKey) direction = 'n';  // E = North (up-right)
            if (e.code === 'KeyZ') direction = 's';   // Z = South (down-left on screen)
            if (e.code === 'KeyC') direction = 'e';   // C = East (down-right on screen)
            
            // Shift = run (PvP style)
            isRunning = e.shiftKey;
            
            if (direction) {
                e.preventDefault();
                // Use smooth movement to next tile
                moveOneStep(direction);
            }
        });
        
        // ========================================
        // MOUSE CONTROLS: Camera Follow + PvP-Style Movement
        // ========================================
        // - LEFT CLICK: Click-to-move (walk)
        // - LEFT DOUBLE-CLICK: Click-to-move (run)  
        // - RIGHT HOLD + DRAG: Character follows cursor (PvP style!)
        // - MOUSE WHEEL: Zoom in/out
        // ========================================
        
        function setupMouseControls() {
            const container = document.getElementById('canvasContainer');
            if (!container) return;
            
            const webglCanvasEl = document.getElementById('webgl-canvas');
            
            // Prevent right-click context menu on container AND canvas
            container.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
                return false;
            });
            
            if (webglCanvasEl) {
                webglCanvasEl.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                });
            }
            
            // Disable default drag behavior on container
            container.style.userSelect = 'none';
            container.style.webkitUserSelect = 'none';
            container.draggable = false;
            
            // Mouse wheel - zoom in/out
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                
                if (e.deltaY < 0) {
                    // Scroll up - zoom in
                    cameraZoom = Math.min(MAX_ZOOM, cameraZoom + ZOOM_STEP);
                } else {
                    // Scroll down - zoom out
                    cameraZoom = Math.max(MIN_ZOOM, cameraZoom - ZOOM_STEP);
                }
                
                console.log(`[Camera] Zoom: ${cameraZoom.toFixed(1)}x`);
                
                // Re-render with new zoom
                if (playerCharacter) {
                    renderScene();
                }
            }, { passive: false });
            
            // Left mouse down - start click
            container.addEventListener('mousedown', (e) => {
                if (e.button === 0) {
                    // Left button - click to move
                    clickStartX = e.clientX;
                    clickStartY = e.clientY;
                    isDragging = false;
                } else if (e.button === 2) {
                    // Right button - UO-authentic movement (character follows cursor while held)
                    e.preventDefault();
                    e.stopPropagation();
                    
                    rightMouseDown = true;
                    rightMouseHeld = true;  // Track continuous hold
                    isRunning = false; // Start with walk, distance determines run
                    
                    // FIRST: Update mouse position BEFORE starting game loop
                    // This prevents the race condition where gameLoop uses stale (0,0) coordinates
                    // Note: We must get the canvas FRESH here (not use the const from setup time)
                    const canvas = document.getElementById('webgl-canvas');
                    if (canvas && playerCharacter) {
                        const rect = canvas.getBoundingClientRect();
                        const canvasX = e.clientX - rect.left;
                        const canvasY = e.clientY - rect.top;
                        lastMouseX = canvasX;  // Set coordinates first!
                        lastMouseY = canvasY;
                        console.log(`[Mouse] mousedown at canvas: (${canvasX.toFixed(0)}, ${canvasY.toFixed(0)})`);
                        handleMouseMove(canvasX, canvasY);
                    } else {
                        console.warn('[Mouse] Canvas not found or no character!', { canvas: !!canvas, playerCharacter: !!playerCharacter });
                    }
                    
                    // THEN start game loop for continuous movement updates
                    startGameLoop();
                    
                    console.log('[Mouse] Right-click hold: Character follows cursor');
                }
            });
            
            // Mouse move - move character (Camera Follow mode)
            container.addEventListener('mousemove', (e) => {
                // Get canvas fresh each time (not the stale const from setup)
                const canvas = document.getElementById('webgl-canvas');
                if (!canvas) return;
                
                // Right mouse held - PvP style: character follows cursor
                if (rightMouseDown && playerCharacter) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const rect = canvas.getBoundingClientRect();
                    const canvasX = e.clientX - rect.left;
                    const canvasY = e.clientY - rect.top;
                    lastMouseX = canvasX;  // Update stored position
                    lastMouseY = canvasY;
                    handleMouseMove(canvasX, canvasY);
                }
            });
            
            // Mouse up
            container.addEventListener('mouseup', (e) => {
                if (e.button === 2) {
                    // Right button released - stop following cursor (UO-authentic)
                    rightMouseDown = false;
                    rightMouseHeld = false;

                    if (playerCharacter) {
                        // Let the character finish the tile they're heading toward
                        if (nextTileX !== null && nextTileY !== null) {
                            targetTileX = nextTileX;
                            targetTileY = nextTileY;
                        } else {
                            targetTileX = null;
                            targetTileY = null;
                            isMoving = false;
                            animationTime = 0;
                            const dirSprites = characterSprites[playerCharacter.direction];
                            playerCharacter.sprite = dirSprites?.idle || dirSprites;
                        }
                    }
                    console.log('[Mouse] Right-click released - stopping after current step');
                    return;
                }
                
                if (e.button === 0) {
                    // Left button - check for click-to-move
                    const dx = Math.abs(e.clientX - clickStartX);
                    const dy = Math.abs(e.clientY - clickStartY);
                    const wasClick = dx < 5 && dy < 5;
                    
                    container.style.cursor = 'crosshair';
                    
                    if (wasClick && playerCharacter) {
                        // Double-click detection for running
                        const now = Date.now();
                        if (now - lastClickTime < 300) {
                            isRunning = true;
                        } else {
                            isRunning = false;
                        }
                        lastClickTime = now;
                        
                        // Get click position and move there (Camera Follow aware)
                        const webglCanvasEl = document.getElementById('webgl-canvas');
                        if (webglCanvasEl) {
                            const rect = webglCanvasEl.getBoundingClientRect();
                            const canvasX = e.clientX - rect.left;
                            const canvasY = e.clientY - rect.top;
                            
                            const tile = screenToTile(canvasX, canvasY);
                            
                            if (tile && currentMap) {
                                const mapWidth = currentMap[0].length;
                                const mapHeight = currentMap.length;
                                
                                if (tile.x >= 0 && tile.x < mapWidth && tile.y >= 0 && tile.y < mapHeight) {
                                    if (isTileWalkable(tile.x, tile.y)) {
                                        console.log(`[Mouse] Click-to-move to (${tile.x}, ${tile.y}) ${isRunning ? '(running)' : ''}`);
                                        moveToTile(tile.x, tile.y);
                                    } else {
                                        console.log(`[Mouse] Can't walk to (${tile.x}, ${tile.y})`);
                                    }
                                }
                            }
                        }
                    }
                    
                    isDragging = false;
                }
            });
            
            // Mouse leave - stop right-click movement (UO-authentic)
            container.addEventListener('mouseleave', () => {
                rightMouseDown = false;
                rightMouseHeld = false;
                
                // Stop movement when mouse leaves (UO-style)
                if (playerCharacter && isMoving) {
                    targetTileX = null;
                    targetTileY = null;
                    nextTileX = null;
                    nextTileY = null;
                    movementProgress = 0;
                    isMoving = false;
                    animationTime = 0;  // Reset animation
                    // Snap to nearest tile
                    playerCharacter.x = Math.round(playerCharacter.x);
                    playerCharacter.y = Math.round(playerCharacter.y);
                    const dirSprites = characterSprites[playerCharacter.direction];
                    playerCharacter.sprite = dirSprites?.idle || dirSprites;
                }
                container.style.cursor = 'crosshair';
            });
            
            container.style.cursor = 'crosshair';
            
            console.log('[Mouse] Camera Follow + PvP controls initialized:');
            console.log('  - LEFT CLICK: Walk to tile');
            console.log('  - LEFT DOUBLE-CLICK: Run to tile');
            console.log('  - MOUSE WHEEL: Zoom in/out');
            console.log('  - RIGHT HOLD + MOVE: Character follows cursor (PvP style)');
            console.log('  - Character stays centered (Camera Follow mode)');
        }
        
        // Initialize mouse controls when DOM is ready
        setTimeout(setupMouseControls, 100);
        
        // ========================================
        // PROCEDURAL STATICS TEST
        // ========================================
        
        window.testProceduralStatics = async function() {
            const statusEl = document.getElementById('status');
            statusEl.textContent = 'ğŸŒ² Generating procedural terrain...';
            
            try {
                const width = 40, height = 40;
                const seed = Math.floor(Math.random() * 100000);
                console.log(`[ProceduralTest] Using seed: ${seed}`);
                
                // Generate terrain using V2 generator
                const generator = new TerrainGeneratorV2(seed);
                statusEl.textContent = 'ğŸŒ² Generating terrain with TerrainGeneratorV2...';
                const map = generator.generateMap(width, height);
                
                // Calculate Z range
                let minZ = Infinity, maxZ = -Infinity;
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const tile = map[y][x];
                        tile.name = tile.biome;
                        tile.x = x;
                        tile.y = y;
                        tile.isWater = tile.biome === 'water';
                        
                        // Calculate Z from elevation
                        if (tile.elevation !== undefined) {
                            if (tile.biome === 'water') {
                                tile.z = Math.floor(tile.elevation * 10);
                            } else if (tile.biome === 'sand') {
                                tile.z = 3 + Math.floor((tile.elevation - 0.35) * 30);
                            } else if (tile.biome === 'rock') {
                                tile.z = 25 + Math.floor((tile.elevation - 0.7) * 80);
                            } else {
                                tile.z = 6 + Math.floor((tile.elevation - 0.4) * 50);
                            }
                        }
                        
                        if (tile.z < minZ) minZ = tile.z;
                        if (tile.z > maxZ) maxZ = tile.z;
                    }
                }
                
                // Generate corner heights
                statusEl.textContent = 'ğŸŒ² Calculating 3D corner heights...';
                const cornerHeights = [];
                const zRange = maxZ - minZ || 1;
                for (let cy = 0; cy <= height; cy++) {
                    cornerHeights[cy] = [];
                    for (let cx = 0; cx <= width; cx++) {
                        const tiles = [];
                        if (cy > 0 && cx > 0) tiles.push(map[cy-1][cx-1]);
                        if (cy > 0 && cx < width) tiles.push(map[cy-1][cx]);
                        if (cy < height && cx > 0) tiles.push(map[cy][cx-1]);
                        if (cy < height && cx < width) tiles.push(map[cy][cx]);
                        
                        const avgZ = tiles.length > 0 
                            ? tiles.reduce((sum, t) => sum + (t.z || 0), 0) / tiles.length 
                            : 0;
                        cornerHeights[cy][cx] = Math.max(0, Math.min(50, Math.round((avgZ - minZ) / zRange * 50)));
                    }
                }
                
                // Place statics based on biomes
                statusEl.textContent = 'ğŸŒ² Placing biome-appropriate statics...';
                const biomePlacer = new BiomeStaticPlacer();
                const placedStatics = biomePlacer.placeStatics(map, {
                    seed: seed,
                    densityMultiplier: 1.5,
                    enableClustering: true
                });
                console.log(`[ProceduralTest] Generated ${placedStatics.length} statics`);
                
                // Normalize tile IDs to integers
                for (const row of map) {
                    for (const tile of row) {
                        if (tile.id) {
                            tile.id = typeof tile.id === 'string' ? parseInt(tile.id, 16) : tile.id;
                        }
                    }
                }
                
                // Setup WebGL canvas
                statusEl.textContent = 'ğŸŒ² Initializing WebGL renderer...';
                const canvasContainer = document.getElementById('canvas').parentElement;
                const originalCanvas = document.getElementById('canvas');
                
                // Remove old WebGL canvas
                let webglCanvasEl = document.getElementById('webgl-canvas');
                if (webglCanvasEl && webglCanvasEl.parentElement) {
                    webglCanvasEl.parentElement.removeChild(webglCanvasEl);
                }
                
                // Create new WebGL canvas
                webglCanvasEl = document.createElement('canvas');
                webglCanvasEl.id = 'webgl-canvas';
                webglCanvasEl.style.display = 'block';
                webglCanvasEl.style.border = 'none';
                webglCanvasEl.style.background = '#1a1a2e';
                
                originalCanvas.style.display = 'none';
                canvasContainer.style.overflow = 'hidden';  // Prevent scrollbar jitter
                canvasContainer.appendChild(webglCanvasEl);
                canvasContainer.style.maxHeight = 'none';  // Don't limit height
                
                // Create WebGL renderer
                try {
                    webglRenderer = new WebGLTerrainRenderer(webglCanvasEl);
                    console.log('[ProceduralTest] WebGL renderer initialized');
                } catch (e) {
                    statusEl.textContent = `âŒ WebGL not supported: ${e.message}`;
                    return;
                }
                
                // Load tile textures
                statusEl.textContent = 'ğŸŒ² Loading tile textures...';
                const uniqueTileIds = new Set();
                for (const row of map) {
                    for (const tile of row) {
                        if (tile.id !== undefined) uniqueTileIds.add(tile.id);
                    }
                }
                
                let loadedTileCount = 0;
                for (const tileId of uniqueTileIds) {
                    const processedImage = await loadTileImage(tileId);
                    if (processedImage) {
                        webglRenderer.loadTexture(tileId, processedImage);
                        loadedTileCount++;
                    }
                }
                console.log(`[ProceduralTest] Loaded ${loadedTileCount}/${uniqueTileIds.size} tile textures`);
                
                // Load static art textures
                statusEl.textContent = 'ğŸŒ² Loading static object graphics...';
                if (!itemLoader) itemLoader = new UOItemLoader();
                const artTextures = {};
                
                const uniqueGraphics = [...new Set(placedStatics.map(s => s.graphic))];
                let loadedArtCount = 0;
                for (const graphicId of uniqueGraphics) {
                    try {
                        const texture = await itemLoader.getTexture(graphicId);
                        if (texture) {
                            artTextures[graphicId] = texture;
                            loadedArtCount++;
                        }
                    } catch (e) {}
                }
                console.log(`[ProceduralTest] Loaded ${loadedArtCount}/${uniqueGraphics.length} static art textures`);
                
                // Prepare statics for rendering
                const regionStatics = placedStatics.map(s => ({
                    ...s,
                    relX: s.x,
                    relY: s.y,
                    worldX: s.x,
                    worldY: s.y,
                    artTexture: artTextures[s.graphic] || null
                }));
                
                // Render!
                statusEl.textContent = 'ğŸŒ² Rendering 3D terrain with WebGL...';
                webglRenderer.render(map, cornerHeights, null, regionStatics);
                
                // Save state for character rendering
                currentMap = map;
                currentCornerHeights = cornerHeights;
                currentStatics = regionStatics;
                
                // Reset character if spawned
                playerCharacter = null;
                
                // Count biomes
                const biomeCounts = {};
                for (const row of map) {
                    for (const tile of row) {
                        biomeCounts[tile.biome] = (biomeCounts[tile.biome] || 0) + 1;
                    }
                }
                
                const biomeStr = Object.entries(biomeCounts).map(([b, c]) => `${b}: ${c}`).join(', ');
                statusEl.textContent = `âœ… Procedural 3D map: ${width}Ã—${height} | Z: ${minZ}-${maxZ} | ${placedStatics.length} statics | ${biomeStr}`;
                statusEl.style.color = '#4CAF50';
                
            } catch (error) {
                console.error('[ProceduralTest] Error:', error);
                document.getElementById('status').textContent = `âŒ Error: ${error.message}`;
            }
        };
        
        // Load on startup
        loadLandTiles();
    </script>
</body>
</html>

