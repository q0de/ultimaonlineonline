<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UO Terrain Generator Demo</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
        }
        .main-layout {
            display: flex;
            height: 100vh;
            width: 100vw;
        }
        .sidebar {
            width: 320px;
            background: #2a2a2a;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 15px;
            border-right: 2px solid #444;
            flex-shrink: 0;
        }
        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #444;
        }
        .sidebar-toggle {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
        }
        .sidebar.collapsed {
            width: 0;
            padding: 0;
            border: none;
            overflow: hidden;
        }
        .map-area {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #000;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 {
            color: #4CAF50;
            text-align: center;
            font-size: 20px;
            margin: 0;
        }
        .controls {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: inline-block;
            width: 150px;
            color: #b0b0b0;
        }
        input, select, button {
            padding: 8px 12px;
            margin: 5px;
            border: 1px solid #444;
            border-radius: 4px;
            background: #333;
            color: #e0e0e0;
        }
        button {
            background: #4CAF50;
            color: white;
            cursor: pointer;
            font-weight: bold;
        }
        button:hover {
            background: #45a049;
        }
        #canvasContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            overflow: hidden;
            cursor: grab;
            background: #000;
        }
        #canvasContainer:active {
            cursor: grabbing;
        }
        #canvas {
            position: absolute;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            transform-origin: 0 0;
        }
        .viewport-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }
        .viewport-controls button {
            padding: 5px 15px;
            font-size: 18px;
        }
        .viewport-controls span {
            min-width: 80px;
            text-align: center;
        }
        .info {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }
        .biome-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        .biome-item {
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
        }
        .grass { background: #228b22; }
        .sand { background: #daa520; color: #000; }
        .dirt { background: #8b4513; }
        .water { background: #1e90ff; }
        .forest { background: #2d5016; }
        .jungle { background: #1b4d1b; }
        .furrows { background: #654321; }
        
        /* ========== COLLAPSIBLE SECTIONS ========== */
        .section {
            background: #252525;
            border-radius: 6px;
            margin-bottom: 8px;
            border: 1px solid #3a3a3a;
            overflow: hidden;
        }
        .section-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            background: linear-gradient(to bottom, #353535, #2a2a2a);
            cursor: pointer;
            user-select: none;
            border-bottom: 1px solid transparent;
            transition: all 0.2s ease;
        }
        .section-header:hover {
            background: linear-gradient(to bottom, #404040, #353535);
        }
        .section.open .section-header {
            border-bottom-color: #3a3a3a;
        }
        .section-icon {
            font-size: 14px;
            width: 20px;
            text-align: center;
        }
        .section-title {
            font-size: 12px;
            font-weight: 600;
            color: #e0e0e0;
            flex: 1;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .section-chevron {
            font-size: 10px;
            color: #888;
            transition: transform 0.2s ease;
        }
        .section.open .section-chevron {
            transform: rotate(180deg);
        }
        .section-content {
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }
        .section.open .section-content {
            padding: 10px;
            max-height: 500px;
        }
        .section-content button {
            display: flex;
            align-items: center;
            gap: 6px;
            width: 100%;
            margin: 4px 0;
            padding: 8px 12px;
            font-size: 12px;
            text-align: left;
            border-radius: 4px;
            justify-content: flex-start;
        }
        .section-content button .btn-icon {
            font-size: 14px;
            width: 18px;
            flex-shrink: 0;
        }
        .section-content button .btn-text {
            flex: 1;
        }
        .btn-row {
            display: flex;
            gap: 6px;
        }
        .btn-row button {
            flex: 1;
        }
        .input-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 6px 0;
            padding: 6px 8px;
            background: #1a1a1a;
            border-radius: 4px;
        }
        .input-row label {
            font-size: 11px;
            color: #aaa;
            width: auto;
            min-width: 20px;
        }
        .input-row input[type="number"] {
            width: 55px;
            padding: 4px 6px;
            font-size: 11px;
            margin: 0;
        }
        .input-row button {
            flex: 0;
            width: auto;
            padding: 4px 10px;
            margin: 0;
        }
        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            background: #1a1a1a;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s ease;
        }
        .checkbox-item:hover {
            background: #252525;
        }
        .checkbox-item input[type="checkbox"] {
            margin: 0;
            width: 16px;
            height: 16px;
            accent-color: #4CAF50;
        }
        .checkbox-item .cb-icon {
            font-size: 14px;
        }
        .checkbox-item .cb-label {
            font-size: 12px;
            color: #ccc;
        }
        
        /* Button color themes */
        .btn-generate { background: linear-gradient(135deg, #4CAF50, #388E3C) !important; }
        .btn-generate:hover { background: linear-gradient(135deg, #66BB6A, #43A047) !important; }
        .btn-blue { background: linear-gradient(135deg, #2196F3, #1976D2) !important; }
        .btn-blue:hover { background: linear-gradient(135deg, #42A5F5, #1E88E5) !important; }
        .btn-orange { background: linear-gradient(135deg, #FF5722, #E64A19) !important; }
        .btn-orange:hover { background: linear-gradient(135deg, #FF7043, #F4511E) !important; }
        .btn-deep-orange { background: linear-gradient(135deg, #E65100, #BF360C) !important; }
        .btn-teal { background: linear-gradient(135deg, #00897B, #00695C) !important; }
        .btn-teal:hover { background: linear-gradient(135deg, #26A69A, #00897B) !important; }
        .btn-teal.active { background: linear-gradient(135deg, #4DB6AC, #26A69A) !important; box-shadow: 0 0 10px #4DB6AC; }
        .btn-purple { background: linear-gradient(135deg, #9C27B0, #7B1FA2) !important; }
        .btn-purple:hover { background: linear-gradient(135deg, #AB47BC, #8E24AA) !important; }
        .btn-gray { background: linear-gradient(135deg, #607D8B, #455A64) !important; }
        .btn-gray:hover { background: linear-gradient(135deg, #78909C, #546E7A) !important; }
        .btn-brown { background: linear-gradient(135deg, #795548, #5D4037) !important; }
        .btn-cyan { background: linear-gradient(135deg, #00BCD4, #0097A7) !important; }
        .btn-pink { background: linear-gradient(135deg, #E91E63, #C2185B) !important; }
        .btn-gradient-fire { background: linear-gradient(135deg, #FF6B35, #F7931E) !important; }
        .btn-gradient-magic { background: linear-gradient(135deg, #E040FB, #7C4DFF) !important; }
        .btn-gradient-earth { background: linear-gradient(135deg, #2b8a3e, #a6c34c) !important; }
        .btn-small { 
            padding: 4px 8px !important; 
            font-size: 11px !important; 
            background: #444 !important;
            border: 1px solid #666 !important;
        }
        .btn-small:hover { background: #555 !important; }
        
        /* Tile Palette Styles */
        #tilePalette {
            position: fixed;
            right: 20px;
            top: 20px;
            width: 500px;
            max-height: 90vh;
            background: #2a2a2a;
            border: 2px solid #4CAF50;
            border-radius: 8px;
            padding: 15px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        #tilePalette.visible {
            display: block;
        }
        #tilePalette h3 {
            margin: 0 0 10px 0;
            color: #4CAF50;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 18px;
        }
        #tilePalette .close-btn {
            background: #f44336;
            border: none;
            color: white;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .palette-category {
            margin-bottom: 10px;
        }
        .palette-category-header {
            background: #333;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 4px;
            margin-bottom: 5px;
        }
        .palette-category-header:hover {
            background: #444;
        }
        .palette-tiles {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 6px;
            max-height: 400px;
            overflow-y: auto;
            padding: 5px;
            background: #1a1a1a;
            border-radius: 4px;
        }
        .palette-tile {
            width: 70px;
            height: 70px;
            border: 2px solid #444;
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            background: #000;
        }
        .palette-tile:hover {
            border-color: #4CAF50;
            transform: scale(1.05);
        }
        .palette-tile.selected {
            border-color: #ff9800;
            box-shadow: 0 0 10px #ff9800;
        }
        .palette-tile img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
        }
        .palette-tile .tile-id {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.85);
            font-size: 9px;
            text-align: center;
            color: #aaa;
            padding: 1px 0;
        }
        #selectedTileInfo {
            background: #333;
            padding: 10px;
            margin-top: 10px;
            border-radius: 4px;
            text-align: center;
        }
        #selectedTileInfo img {
            width: 88px;
            height: 88px;
            image-rendering: pixelated;
        }
        .paint-mode-indicator {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: #ff9800;
            color: #000;
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            z-index: 999;
            display: none;
        }
        .paint-mode-indicator.visible {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Paint Mode Indicator -->
    <div class="paint-mode-indicator" id="paintModeIndicator">
        üé® PAINT MODE - Click on map to place tile | ESC to exit
    </div>

    <!-- Tile Palette -->
    <div id="tilePalette">
        <h3>
            üé® Tile Palette
            <button class="close-btn" onclick="togglePalette()">‚úï</button>
        </h3>
        <div id="paletteCategories"></div>
        <div id="selectedTileInfo">
            <p>Click a tile to select it</p>
        </div>
    </div>

    <div class="main-layout">
        <!-- SIDEBAR -->
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <h1>üåç UO Terrain Generator</h1>
                <button class="sidebar-toggle" onclick="toggleSidebar()">‚ò∞</button>
            </div>

            <div class="controls">
        <h1>üåç UO Terrain Generator</h1>
        
            <div class="control-group">
                <label>Map Width:</label>
                <input type="number" id="width" value="50" min="10" max="200">
            </div>
            <div class="control-group">
                <label>Map Height:</label>
                <input type="number" id="height" value="50" min="10" max="200">
            </div>
            <div class="control-group">
                <label>Generation Type:</label>
                <select id="genType">
                    <option value="basic">Basic Terrain</option>
                    <option value="water">With Water Bodies</option>
                </select>
            </div>
            <div class="control-group">
                <label style="margin-left: 20px;">
                    <input type="checkbox" id="showStatics" checked> Show Statics (Height Objects)
                </label>
            </div>
            <div class="control-group">
                <label>Seed (optional):</label>
                <input type="number" id="seed" placeholder="Leave empty for random">
            </div>
            <!-- ========== GENERATE SECTION ========== -->
            <div class="section open" onclick="toggleSection(this, event)">
                <div class="section-header">
                    <span class="section-icon">üé≤</span>
                    <span class="section-title">Generate</span>
                    <span class="section-chevron">‚ñº</span>
                </div>
                <div class="section-content" onclick="event.stopPropagation()">
                    <button onclick="generateTerrain()" class="btn-generate">
                        <span class="btn-icon">üé≤</span>
                        <span class="btn-text">Generate (Old)</span>
                    </button>
                    <button onclick="generateTerrainV2()" class="btn-blue">
                        <span class="btn-icon">‚ú®</span>
                        <span class="btn-text">Generate V2 (Proper Tiles)</span>
                    </button>
                </div>
            </div>

            <!-- ========== LOAD MAP SECTION ========== -->
            <div class="section open" onclick="toggleSection(this, event)">
                <div class="section-header">
                    <span class="section-icon">üó∫Ô∏è</span>
                    <span class="section-title">Load Map</span>
                    <span class="section-chevron">‚ñº</span>
                </div>
                <div class="section-content" onclick="event.stopPropagation()">
                    <button onclick="loadRealUOMap()" class="btn-orange">
                        <span class="btn-icon">üé≤</span>
                        <span class="btn-text">Random Region</span>
                    </button>
                    <button onclick="loadBritainRegion()" class="btn-deep-orange">
                        <span class="btn-icon">üè∞</span>
                        <span class="btn-text">Britain</span>
                    </button>
                    <button onclick="loadLastRegion()" class="btn-teal">
                        <span class="btn-icon">üèñÔ∏è</span>
                        <span class="btn-text">Coastline (3197,18)</span>
                    </button>
                    <div class="input-row">
                        <label>X:</label>
                        <input type="number" id="customX" value="1400">
                        <label>Y:</label>
                        <input type="number" id="customY" value="1600">
                        <button onclick="loadCustomCoords()" class="btn-purple">üìç Load</button>
                    </div>
                </div>
            </div>

            <!-- ========== TOOLS SECTION ========== -->
            <div class="section" onclick="toggleSection(this, event)">
                <div class="section-header">
                    <span class="section-icon">üõ†Ô∏è</span>
                    <span class="section-title">Tools</span>
                    <span class="section-chevron">‚ñº</span>
                </div>
                <div class="section-content" onclick="event.stopPropagation()">
                    <button onclick="openTileViewer()" class="btn-purple">
                        <span class="btn-icon">üé®</span>
                        <span class="btn-text">Tile Viewer</span>
                    </button>
                    <button onclick="togglePalette()" class="btn-orange">
                        <span class="btn-icon">üñåÔ∏è</span>
                        <span class="btn-text">Paint Mode</span>
                    </button>
                    <button onclick="togglePatternDesigner()" class="btn-brown">
                        <span class="btn-icon">üß±</span>
                        <span class="btn-text">Stitch Designer</span>
                    </button>
                    <button id="toggleLabelsBtn" onclick="togglePatternLabels()" class="btn-teal">
                        <span class="btn-icon">üè∑Ô∏è</span>
                        <span class="btn-text">Show Labels</span>
                    </button>
                    <a href="biome_edge_configurator.html" target="_blank" class="btn-link" style="display: inline-block; margin-top: 8px; color: #4CAF50; text-decoration: none; font-size: 12px;">
                        üîß Open Edge Configurator ‚Üí
                    </a>
                </div>
            </div>

            <!-- ========== ADVANCED SECTION ========== -->
            <div class="section open" onclick="toggleSection(this, event)">
                <div class="section-header">
                    <span class="section-icon">‚ö°</span>
                    <span class="section-title">Advanced</span>
                    <span class="section-chevron">‚ñº</span>
                </div>
                <div class="section-content" onclick="event.stopPropagation()">
                    <button onclick="testProceduralStatics()" class="btn-gradient-fire">
                        <span class="btn-icon">üå≤</span>
                        <span class="btn-text">Procedural Statics</span>
                    </button>
                    <button onclick="testProceduralEnhanced()" class="btn-gradient-magic">
                        <span class="btn-icon">‚ú®</span>
                        <span class="btn-text">Procedural Enhanced</span>
                    </button>
                    <button onclick="loadHybridRegion()" class="btn-gradient-earth">
                        <span class="btn-icon">üåÄ</span>
                        <span class="btn-text">Hybrid Real + Procedural</span>
                    </button>
                    <button onclick="loadMountainMiningScenario()" class="btn-gradient-fire">
                        <span class="btn-icon">‚õèÔ∏è</span>
                        <span class="btn-text">Mountain Mining Defense</span>
                    </button>
                    <button onclick="spawnCharacter()" class="btn-gradient-magic">
                        <span class="btn-icon">üßô</span>
                        <span class="btn-text">Spawn Character</span>
                    </button>
                    <button onclick="spawnOrc()" class="btn-gradient-fire">
                        <span class="btn-icon">üëπ</span>
                        <span class="btn-text">Spawn Orc</span>
                    </button>
                    <button onclick="spawnOrcs(5)" class="btn-gradient-fire">
                        <span class="btn-icon">üëπüëπ</span>
                        <span class="btn-text">Spawn 5 Orcs</span>
                    </button>
                    <button onclick="toggleLearningMode()" class="btn-purple">
                        <span class="btn-icon">üß†</span>
                        <span class="btn-text">Learning Mode</span>
                    </button>
                </div>
            </div>

            <!-- ========== EXPORT/DATA SECTION ========== -->
            <div class="section" onclick="toggleSection(this, event)">
                <div class="section-header">
                    <span class="section-icon">üíæ</span>
                    <span class="section-title">Export / Data</span>
                    <span class="section-chevron">‚ñº</span>
                </div>
                <div class="section-content" onclick="event.stopPropagation()">
                    <button onclick="exportMap()" class="btn-generate">
                        <span class="btn-icon">üíæ</span>
                        <span class="btn-text">Export Map Data</span>
                    </button>
                    <button onclick="exportForLearning()" class="btn-pink">
                        <span class="btn-icon">üìö</span>
                        <span class="btn-text">Export for AI Learning</span>
                    </button>
                    <button onclick="loadLandTiles()" class="btn-gray">
                        <span class="btn-icon">üîÑ</span>
                        <span class="btn-text">Reload Tile Data</span>
                    </button>
                </div>
            </div>
            
            </div>
        
        <!-- LEARNING MODE PANEL -->
        <div id="learningMode" style="display: none; background: #1a1a2e; border: 2px solid #9C27B0; border-radius: 8px; padding: 15px; margin: 10px 0;">
            <h3 style="color: #9C27B0; margin-top: 0;">üß† Learning Mode - Analyze Real UO Maps</h3>
            <p style="color: #ccc; font-size: 12px; margin-bottom: 15px;">
                Load larger regions to learn patterns: tile transitions, biome distributions, embankment placement, static object locations.
                This data will improve V2 terrain generation accuracy.
            </p>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                <div>
                    <label style="color: #fff; display: block; margin-bottom: 5px;">Region X:</label>
                    <input type="number" id="learnRegionX" value="1400" style="width: 100%; padding: 5px;">
                </div>
                <div>
                    <label style="color: #fff; display: block; margin-bottom: 5px;">Region Y:</label>
                    <input type="number" id="learnRegionY" value="1600" style="width: 100%; padding: 5px;">
                </div>
                <div>
                    <label style="color: #fff; display: block; margin-bottom: 5px;">Width:</label>
                    <input type="number" id="learnWidth" value="100" style="width: 100%; padding: 5px;">
                </div>
                <div>
                    <label style="color: #fff; display: block; margin-bottom: 5px;">Height:</label>
                    <input type="number" id="learnHeight" value="100" style="width: 100%; padding: 5px;">
                </div>
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="color: #fff; display: block; margin-bottom: 5px;">Analysis Options:</label>
                <label style="color: #ccc; display: block; margin: 5px 0;">
                    <input type="checkbox" id="learnTileTransitions" checked> Analyze Tile Transitions
                </label>
                <label style="color: #ccc; display: block; margin: 5px 0;">
                    <input type="checkbox" id="learnBiomeDistribution" checked> Analyze Biome Distribution
                </label>
                <label style="color: #ccc; display: block; margin: 5px 0;">
                    <input type="checkbox" id="learnEmbankments" checked> Analyze Embankment Placement
                </label>
                <label style="color: #ccc; display: block; margin: 5px 0;">
                    <input type="checkbox" id="learnStatics" checked> Analyze Static Object Placement
                </label>
                <label style="color: #ccc; display: block; margin: 5px 0;">
                    <input type="checkbox" id="learnZHeight" checked> Analyze Z-Height Patterns
                </label>
            </div>
            
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                <button onclick="startLearningAnalysis()" style="background: #9C27B0; padding: 10px 20px; border: none; border-radius: 5px; color: white; cursor: pointer;">
                    üîç Start Analysis
                </button>
                <button onclick="exportLearningData()" style="background: #4CAF50; padding: 10px 20px; border: none; border-radius: 5px; color: white; cursor: pointer;">
                    üíæ Export Findings
                </button>
                <button onclick="clearLearningData()" style="background: #f44336; padding: 10px 20px; border: none; border-radius: 5px; color: white; cursor: pointer;">
                    üóëÔ∏è Clear Data
                </button>
            </div>
            
            <div id="learningResults" style="background: #252545; padding: 10px; border-radius: 5px; max-height: 300px; overflow-y: auto; font-family: monospace; font-size: 11px; color: #ccc;">
                <div style="color: #9C27B0; font-weight: bold; margin-bottom: 10px;">Analysis Results:</div>
                <div id="learningOutput">No analysis run yet. Click "Start Analysis" to begin.</div>
            </div>
        </div>

        <!-- PATTERN DESIGNER PANEL -->
        <div id="patternDesigner" style="display: none; background: #2e1a1a; border: 2px solid #795548; border-radius: 8px; padding: 15px; margin: 10px 0;">
            <h3 style="color: #bcaaa4; margin-top: 0;">üß± Blob Pattern Configurator</h3>
            <p style="color: #ccc; font-size: 13px;">Define 4x4 tessellation patterns for biome interiors. 
            Select a biome, paint tiles, then save. Patterns will tile across blob interiors during generation.</p>
            
            <!-- Biome Selector -->
            <div style="margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                <label style="color: #aaa;">Biome:</label>
                <select id="blobPatternBiome" onchange="onBlobBiomeChange()" style="padding: 5px 10px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px;">
                    <option value="rock">Rock</option>
                    <option value="grass">Grass</option>
                    <option value="dirt">Dirt</option>
                    <option value="sand">Sand</option>
                    <option value="forest">Forest</option>
                </select>
                <span id="savedPatternIndicator" style="color: #4CAF50; font-size: 12px; display: none;">‚úì Pattern Saved</span>
            </div>
            
            <div style="display: flex; flex-direction: column; gap: 15px; margin-top: 15px;">
                <!-- The Grid -->
                <div style="background: #1a0e0e; padding: 10px; border-radius: 6px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h4 style="margin: 0; color: #ccc;">Pattern Grid (4x4)</h4>
                        <button onclick="useDefaultPattern()" style="padding: 3px 8px; font-size: 11px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;">Use Default</button>
                    </div>
                    <div id="stitchGrid" style="display: grid; grid-template-columns: repeat(4, 56px); gap: 2px; background: #000; padding: 2px; border: 1px solid #555;">
                        <!-- 16 cells generated by JS -->
                    </div>
                    <div style="text-align: center; margin-top: 5px; color: #777; font-size: 11px;">Click grid cell to paint selected tile</div>
                </div>
                
                <!-- Preview (tiled 3x3) -->
                <div style="background: #1a0e0e; padding: 10px; border-radius: 6px;">
                    <h4 style="margin: 0 0 10px 0; color: #ccc;">Preview (Tiled 3x3)</h4>
                    <div id="patternPreview" style="display: grid; grid-template-columns: repeat(12, 18px); gap: 0px; background: #000; padding: 2px; border: 1px solid #555; width: fit-content;">
                        <!-- 144 cells (12x12) showing 3x3 tiling of 4x4 pattern -->
                    </div>
                    <div style="text-align: center; margin-top: 5px; color: #777; font-size: 11px;">Shows how pattern tiles across terrain</div>
                </div>
                
                <!-- The Palette -->
                <div style="background: #1a0e0e; padding: 10px; border-radius: 6px;">
                    <h4 id="paletteTitle" style="margin: 0 0 10px 0; color: #ccc;">Tiles (Palette)</h4>
                    <div id="stitchPalette" style="display: grid; grid-template-columns: repeat(5, 40px); gap: 4px; max-height: 200px; overflow-y: auto;">
                        <!-- Tiles generated by JS based on selected biome -->
                    </div>
                    <div style="margin-top: 10px; padding: 5px; background: #333; border-radius: 4px; text-align: center;">
                        <span style="color: #aaa; font-size: 12px;">Selected:</span>
                        <span id="currentStitchTileDisplay" style="color: #fff; font-weight: bold;">None</span>
                    </div>
                </div>
            </div>
            
            <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                <button onclick="applyStitchPattern()" style="background: #4CAF50; padding: 8px 15px;">‚ñ∂Ô∏è Test Pattern</button>
                <button onclick="togglePatternDesigner()" style="background: #f44336;">‚ùå Close</button>
            </div>
        </div>
        
            <div class="controls viewport-controls">
                <label>Viewport:</label>
                <button onclick="zoomIn()">‚ûï Zoom In</button>
                <button onclick="zoomOut()">‚ûñ Zoom Out</button>
                <span id="zoomLevel">100%</span>
                <button onclick="resetView()">üîÑ Reset View</button>
                <button onclick="centerOnTerrain()">üéØ Center</button>
                <button onclick="fitToView()">üìê Fit All</button>
            </div>
            
            <div class="info">
                <h3>Biome Legend:</h3>
                <div class="biome-legend">
                    <span class="biome-item grass">üå± Grass</span>
                    <span class="biome-item sand">üèñÔ∏è Sand</span>
                    <span class="biome-item dirt">üü§ Dirt</span>
                    <span class="biome-item water">üíß Water</span>
                    <span class="biome-item forest">üå≤ Forest</span>
                    <span class="biome-item jungle">üå¥ Jungle</span>
                    <span class="biome-item furrows">üåæ Furrows</span>
                </div>
                <div id="statusContainer" style="background: #1a1a2e; padding: 10px; border-radius: 5px; margin: 10px 0; border: 2px solid #4CAF50;">
                    <p id="status" style="margin: 0; font-size: 14px; font-weight: bold; color: #4CAF50;">Ready</p>
                    <div id="progressBar" style="width: 0%; height: 4px; background: #4CAF50; margin-top: 5px; border-radius: 2px; transition: width 0.3s;"></div>
                </div>
            </div>
        
        <!-- Removed tile tester sections for cleaner UI -->
        <div style="display: none;">
            <!-- Legacy tile tester content removed -->
        </div>
        
        <!-- Hidden duplicate elements removed - canvas/viewport/legend now at top -->
        <div class="info" style="display: none;">
            <div class="biome-legend">
                <span class="biome-item grass">üå± Grass</span>
                <span class="biome-item sand">üèñÔ∏è Sand</span>
                <span class="biome-item dirt">üü§ Dirt</span>
                <span class="biome-item water">üíß Water</span>
                <span class="biome-item forest">üå≤ Forest</span>
                <span class="biome-item jungle">üå¥ Jungle</span>
                <span class="biome-item furrows">üåæ Furrows</span>
            </div>
            <p id="status">Click "Generate Terrain" to start!</p>
        </div>
        </div>
        <!-- END SIDEBAR -->

        <!-- MAP AREA -->
        <div class="map-area">
            <div id="canvasContainer">
                <canvas id="canvas" width="500" height="500"></canvas>
            </div>
        </div>
        <!-- END MAP AREA -->
    </div>
    <!-- END MAIN LAYOUT -->

    <script type="module">
        import { LandTileLoader } from './js/modules/landTileLoader.js';
        import { TerrainGenerator } from './js/modules/terrainGenerator.js';
        import { TerrainGeneratorV2 } from './js/modules/terrainGeneratorV2.js?v=single_rock'; // Force reload - single rock pattern
        import { WebGLTerrainRenderer } from './js/modules/webglTerrainRenderer.js?v=camerafollow1';
        import { initializeDynamicSets } from './js/data/uoTileSetsClean.js';
        import { UOMapLoader } from './js/modules/uoMapLoader.js';
        import { UOStaticLoader } from './js/modules/uoStaticLoader.js';
        import { UOArtLoader } from './js/modules/uoArtLoader.js';
        import { Character } from './js/modules/character.js';
        import { BiomeStaticPlacer } from './js/modules/biomeStaticPlacer.js';
        import { prefabLoader } from './js/modules/prefabLoader.js';
        import { UOItemLoader } from './js/modules/uoItemLoader.js';
        import { annotateMapWithSurfaces } from './js/data/landSurfaceClassifier.js';

        console.log('[OK] Modules imported successfully');
        
        // Global art loader for static graphics
        let artLoader = null;
        const ENABLE_UOP_STATIC_ART = false; // UOP decoding still unstable - default to exported BMP sprites
        
        // WebGL renderer instance (created on first use)
        let webglRenderer = null;
        console.log('LandTileLoader:', typeof LandTileLoader);
        console.log('TerrainGenerator:', typeof TerrainGenerator);
        console.log('TerrainGeneratorV2:', typeof TerrainGeneratorV2);
        
        // V2 generator (uses proper tile sets)
        let terrainGeneratorV2 = new TerrainGeneratorV2();
        
        // UO Map Loader for real map data
        let uoMapLoader = new UOMapLoader();

        let terrainGenerator = null;
        
        // Global storage for collision detection
        let landTileData = new Map(); // tileId (number) -> tile properties from LandData.csv
        let currentStatics = []; // Array of static objects (from map or procedural)
        let currentMap = null;
        let currentCornerHeights = null; // Store corner heights for re-rendering
        function updateCurrentMapReference(map) {
            currentMap = map;
            currentMapIsUORegion = !!(map && map.__isUORegion);
        }

        const SCENARIO_PRESETS = {
            mountain_mining: {
                key: 'mountain_mining',
                name: 'Mountain Mining Defense',
                description: 'Secure a valorite mining site high in the mountains. Keep the supply crates intact while miners work.',
                region: { x: 2450, y: 460 },
                objective: 'Protect the miners and defend the ore stockpile.'
            }
        };
        let currentScenario = null;
        
        // Player character (reuses PvP Character class!)
        let playerCharacter = null;
        let characterSprites = {}; // { direction: canvas }
        let orcSprites = {}; // { direction: { idle, walk } } for orcs
        let spawnedOrcs = []; // Array of spawned orc objects
        let itemLoader = null; // For loading static BMP graphics
        
        let tileImages = {}; // Cache for processed tile images (with transparent corners)
        let showTileIds = false; // Toggle for showing tile IDs on map
        let enableZHeight = false; // Toggle for UO-style Z-height rendering (3D effect) - disabled by default because proper UO rendering requires texture stretching over triangles
        
        const AUTO_REGION_EDGE_BUFFER = 4; // tiles from border to trigger streaming
        const REGION_OVERLAP_TILES = 8; // keep a small overlap to avoid seams
        const UO_MAP_WIDTH = 7168;
        const UO_MAP_HEIGHT = 4096;
        const clampValue = (value, min, max) => Math.min(max, Math.max(min, value));
        
        let currentRegionOrigin = { x: 0, y: 0 };
        let currentRegionSize = { width: 0, height: 0 };
        let currentRegionBlendProcedural = false;
        let currentMapIsUORegion = false;
        let mapLoadInProgress = false;
        let pendingWorldPosition = null;

        function getScenarioPreset(key) {
            return key ? SCENARIO_PRESETS[key] || null : null;
        }
        function updatePendingWorldFollow() {
            if (
                !pendingWorldPosition ||
                !pendingWorldPosition.followPlayer ||
                !playerCharacter ||
                !mapLoadInProgress
            ) {
                return;
            }
            pendingWorldPosition.worldX = currentRegionOrigin.x + playerCharacter.x;
            pendingWorldPosition.worldY = currentRegionOrigin.y + playerCharacter.y;
        }
        
        // Viewport state
        let viewportZoom = 1.0; // Default zoom level
        let viewportX = 0;
        let viewportY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let terrainBounds = { minX: 0, minY: 0, maxX: 0, maxY: 0 };
        
        // Camera Follow state
        let cameraZoom = 0.7;  // Start zoomed out for wider view (classic UO style)
        const MIN_ZOOM = 0.5;
        const MAX_ZOOM = 3.0;
        const ZOOM_STEP = 0.1;
        
        // Mouse interaction state
        let scrollStartX = 0;
        let scrollStartY = 0;
        let lastClickTime = 0;
        let clickStartX = 0;
        let clickStartY = 0;
        let rightMouseDown = false;

        // Biome colors for visualization (fallback if images fail to load)
        const biomeColors = {
            grass: '#228b22',
            sand: '#daa520',
            dirt: '#8b4513',
            water: '#1e90ff',
            forest: '#2d5016',
            jungle: '#1b4d1b',
            furrows: '#654321'
        };

        // DEBUG: Check corner pixel values to diagnose tessellation issues
        function debugTileCorners(tileId) {
            const img = new Image();
            img.onload = function() {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                
                const imageData = ctx.getImageData(0, 0, img.width, img.height);
                const data = imageData.data;
                const w = img.width, h = img.height;
                
                // Check the 4 corner pixels and edge centers
                const corners = [
                    { name: 'Top-Left (0,0)', x: 0, y: 0 },
                    { name: 'Top-Right', x: w - 1, y: 0 },
                    { name: 'Bottom-Left', x: 0, y: h - 1 },
                    { name: 'Bottom-Right', x: w - 1, y: h - 1 },
                    { name: 'Top-Center', x: Math.floor(w / 2), y: 0 },
                    { name: 'Left-Center', x: 0, y: Math.floor(h / 2) }
                ];
                
                console.log(`%c=== CORNER PIXELS FOR ${tileId} ===`, 'color: yellow; font-weight: bold');
                console.log(`Image size: ${w}x${h}`);
                for (const corner of corners) {
                    const i = (corner.y * w + corner.x) * 4;
                    const r = data[i], g = data[i + 1], b = data[i + 2], a = data[i + 3];
                    const isBlack = r < 20 && g < 20 && b < 20;
                    console.log(`${corner.name}: R=${r}, G=${g}, B=${b}, A=${a} - ${isBlack ? '‚úÖ BLACK' : '‚ùå NOT BLACK (threshold 20)'}`);
                }
            };
            img.onerror = () => console.error(`Failed to load ${tileId}`);
            img.src = `./assets/tiles/${tileId}.bmp`;
        }

        // Process tile image to make black corners transparent
        // UO tiles have black (0,0,0) in the corners OUTSIDE the diamond shape
        // Only make transparent if: 1) pixel is black AND 2) outside diamond
        function processBlackToTransparent(img) {
            const canvas = document.createElement('canvas');
            const w = img.width || 44;
            const h = img.height || 44;
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d');
            
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, w, h);
            const data = imageData.data;
            
            // Diamond test: only make black pixels transparent if outside diamond
            const halfW = w / 2;
            const halfH = h / 2;
            
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    
                    // Diamond formula: |x-center|/half + |y-center|/half > 1 = outside
                    const dx = Math.abs(x - halfW) / halfW;
                    const dy = Math.abs(y - halfH) / halfH;
                    const outsideDiamond = (dx + dy) > 1;
                    
                    // Only make transparent if OUTSIDE diamond AND black
                    if (outsideDiamond) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        
                        // Pure black or very near black = transparent
                        if (r < 20 && g < 20 && b < 20) {
                            data[i + 3] = 0; // Set alpha to 0
                        }
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        // Load and process a tile image
        async function loadTileImage(tileId) {
            // Handle null/undefined/invalid tile IDs
            if (tileId == null) {
                console.warn('loadTileImage called with null/undefined tileId');
                return null;
            }
            
            let hexId = tileId;
            if (typeof tileId === 'number') {
                hexId = `0x${tileId.toString(16).toUpperCase().padStart(4, '0')}`;
            } else if (typeof tileId === 'string' && !tileId.startsWith('0x')) {
                const num = parseInt(tileId, 16);
                if (!isNaN(num)) {
                    hexId = `0x${num.toString(16).toUpperCase().padStart(4, '0')}`;
                }
            } else if (typeof tileId !== 'string') {
                // Unknown type - try to convert
                console.warn(`loadTileImage: unexpected tileId type: ${typeof tileId}`, tileId);
                hexId = String(tileId);
            }
            
            if (typeof hexId === 'string' && hexId.startsWith('0x')) {
                hexId = '0x' + hexId.substring(2).toUpperCase().padStart(4, '0');
            }
            
            // Return cached processed image if available
            if (tileImages[hexId]) {
                return tileImages[hexId];
            }

            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                
                img.onload = () => {
                    // Process to make black pixels transparent
                    const processed = processBlackToTransparent(img);
                    tileImages[hexId] = processed;
                    resolve(processed);
                };
                
                img.onerror = () => {
                    console.warn(`Failed to load tile: ${hexId}.bmp`);
                    resolve(null);
                };
                
                img.src = `./assets/tiles/${hexId}.bmp`;
            });
        }

        // Load land tile data
        async function loadLandTiles() {
            try {
                // Check if modules are loaded
                if (typeof LandTileLoader === 'undefined' || typeof TerrainGenerator === 'undefined') {
                    throw new Error('Modules not loaded. Check browser console for import errors.');
                }

                document.getElementById('status').textContent = 'Loading land tile data...';
                console.log('Attempting to load CSV from: ./assets/tiles/LandData.csv');
                console.log('LandTileLoader available:', typeof LandTileLoader);
                
                const tiles = await LandTileLoader.loadFromURL('./assets/tiles/LandData.csv');
                
                if (!tiles || tiles.length === 0) {
                    throw new Error('CSV file loaded but contains no tiles');
                }
                
                console.log(`Successfully loaded ${tiles.length} tiles`);
                
                // Store land tile data globally for collision detection
                landTileData = new Map();
                tiles.forEach(tile => {
                    if (tile.id !== undefined) {
                        const tileId = typeof tile.id === 'string' ? parseInt(tile.id, 16) : tile.id;
                        landTileData.set(tileId, tile);
                    }
                });
                console.log(`[Collision] Loaded ${landTileData.size} tile properties for collision detection`);
                
                // Auto-discover tile sets for V2
                console.log('Auto-discovering tile sets from CSV...');
                const discoveredSets = LandTileLoader.generateTileSets(tiles);
                initializeDynamicSets(discoveredSets);
                
                terrainGenerator = new TerrainGenerator(tiles);
                
                const tileTypes = Object.keys(terrainGenerator.tilesByType);
                console.log('Tile types found:', tileTypes.length);
                console.log('Sample types:', tileTypes.slice(0, 10));
                
                // DEBUG: Check corner pixel values (raw tiles)
                debugTileCorners('0x0003');
                debugTileCorners('0x003E');
                debugTileCorners('0x0016');
                
                // DEBUG: Check if transparency is applied after processing
                setTimeout(async () => {
                    const processedGrass = await loadTileImage('0x0003');
                    if (processedGrass) {
                        const ctx = processedGrass.getContext('2d');
                        const data = ctx.getImageData(0, 0, 44, 44).data;
                        
                        console.log('%c=== PROCESSED TILE 0x0003 (after transparency) ===', 'color: cyan; font-weight: bold');
                        
                        // Check corner alpha values
                        const corners = [
                            { name: 'Top-Left (0,0)', x: 0, y: 0 },
                            { name: 'Top-Right (43,0)', x: 43, y: 0 },
                            { name: 'Bottom-Left (0,43)', x: 0, y: 43 },
                            { name: 'Bottom-Right (43,43)', x: 43, y: 43 }
                        ];
                        
                        for (const corner of corners) {
                            const i = (corner.y * 44 + corner.x) * 4;
                            const a = data[i + 3];
                            console.log(`${corner.name}: Alpha=${a} - ${a === 0 ? '‚úÖ TRANSPARENT' : '‚ùå NOT TRANSPARENT'}`);
                        }
                        
                        // CRITICAL: Check tile dimensions
                        console.log('%c=== TILE DIMENSIONS ===', 'color: orange; font-weight: bold');
                        console.log('Tile canvas size:', processedGrass.width, 'x', processedGrass.height);
                        console.log('Expected: 44 x 44');
                        console.log('Match:', processedGrass.width === 44 && processedGrass.height === 44 ? '‚úÖ YES' : '‚ùå NO - THIS IS THE PROBLEM!');
                    }
                }, 500);
                
                document.getElementById('status').textContent = `[OK] Loaded ${tiles.length} land tiles! Ready to generate.`;
                
                // Initialize neighbor tester now that tiles are loaded
                if (typeof initNeighborTester === 'function') {
                    initNeighborTester();
                }
                
                // Auto-generate procedural map on page load
                console.log('[AutoGen] Auto-generating procedural map...');
                setTimeout(() => {
                    if (typeof testProceduralStatics === 'function') {
                        testProceduralStatics();
                    }
                }, 100);
            } catch (error) {
                const errorMsg = `[ERROR] ${error.message}. Check browser console (F12) for details.`;
                document.getElementById('status').textContent = errorMsg;
                console.error('Failed to load land tiles:', error);
                console.error('Error stack:', error.stack);
                
                // Try alternative path
                console.log('Attempting alternative path: assets/tiles/LandData.csv');
                try {
                    const tiles = await LandTileLoader.loadFromURL('assets/tiles/LandData.csv');
                    
                    // Auto-discover tile sets for V2
                    console.log('Auto-discovering tile sets from CSV (fallback)...');
                    const discoveredSets = LandTileLoader.generateTileSets(tiles);
                    initializeDynamicSets(discoveredSets);
                    
                    terrainGenerator = new TerrainGenerator(tiles);
                    document.getElementById('status').textContent = `[OK] Loaded ${tiles.length} tiles from alternative path!`;
                    
                    // Initialize neighbor tester now that tiles are loaded
                    if (typeof initNeighborTester === 'function') {
                        initNeighborTester();
                    }
                    
                    // Auto-generate procedural map on page load (fallback path)
                    console.log('[AutoGen] Auto-generating procedural map (fallback path)...');
                    setTimeout(() => {
                        if (typeof testProceduralStatics === 'function') {
                            testProceduralStatics();
                        }
                    }, 100);
                } catch (e) {
                    console.error('Alternative path also failed:', e);
                }
            }
        }

        // Generate terrain
        window.generateTerrain = async function() {
            if (!terrainGenerator) {
                const status = document.getElementById('status').textContent;
                if (status.includes('Loading')) {
                    alert('Land tile data is still loading. Please wait a few seconds and try again.');
                } else if (status.includes('ERROR')) {
                    alert('Land tile data failed to load. Check browser console (F12) for details. Make sure you are accessing via http://localhost:8000, not file://');
                } else {
                    alert('Land tile data not loaded. Click OK to retry loading...');
                    await loadLandTiles();
                    if (!terrainGenerator) {
                        alert('Still failed to load. Check console for errors.');
                        return;
                    }
                }
                return;
            }

            const width = parseInt(document.getElementById('width').value);
            const height = parseInt(document.getElementById('height').value);
            const genType = document.getElementById('genType').value;
            const seedInput = document.getElementById('seed').value;
            const seed = seedInput ? parseInt(seedInput) : null;

            document.getElementById('status').textContent = 'Generating terrain...';

            try {
                let map;
                if (genType === 'water') {
                    map = terrainGenerator.generateMapWithWater(width, height, { seed });
                } else {
                    map = terrainGenerator.generateMap(width, height, seed);
                }
                updateCurrentMapReference(map);
                
                await renderMap(map);
                
                // Count biomes
                const biomeCounts = {};
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const biome = map[y][x].biome;
                        biomeCounts[biome] = (biomeCounts[biome] || 0) + 1;
                    }
                }

                const counts = Object.entries(biomeCounts)
                    .map(([biome, count]) => `${biome}: ${count}`)
                    .join(', ');
                document.getElementById('status').textContent = `‚úÖ Generated ${width}x${height} map! Biomes: ${counts}`;
            } catch (error) {
                document.getElementById('status').textContent = `‚ùå Error: ${error.message}`;
                console.error('Generation error:', error);
            }
        };

        // Generate test map (Mirror Reference) - OLD
        window.generateTestMap = async function() {
            if (!terrainGenerator) {
                alert('Please load tile data first!');
                return;
            }
            
            document.getElementById('status').textContent = 'Generating test scene...';
            
            try {
                // Fixed size for test scene
                const width = 30;
                const height = 30;
                
                const map = terrainGenerator.generateTestMap(width, height);
                updateCurrentMapReference(map);
                await renderMap(map);
                
                document.getElementById('status').textContent = `‚úÖ Generated Test Scene (Mirror Ref)`;
            } catch (error) {
                console.error(error);
                document.getElementById('status').textContent = `‚ùå Error: ${error.message}`;
            }
        };

        // ============================================================
        // V2 TERRAIN GENERATOR - Uses proper UO tile sets
        // Tiles come in groups of 4 that tessellate together
        // ============================================================
        
        // Collect ALL saved transition mappings to pass to the generator
        // Returns { grass_sand: {0: '0x0003', 1: '0x0036', ...}, grass_dirt: {...}, ... }
        function getAllSavedTransitionMappings() {
            const allMappings = {};
            for (const transKey of Object.keys(ALL_TRANSITIONS)) {
                if (transKey === 'browse_all') continue; // Skip the browse option
                // Copy the mapping directly (the 16-case object)
                allMappings[transKey] = { ...ALL_TRANSITIONS[transKey].mapping };
            }
            console.log('üì¶ Collected ALL transition mappings:', Object.keys(allMappings));
            // Debug: show grass_sand mapping
            console.log('üì¶ grass_sand mapping sample:', allMappings.grass_sand);
            console.log('üì¶ grass_sand[0]:', allMappings.grass_sand[0]);
            console.log('üì¶ grass_sand["0"]:', allMappings.grass_sand["0"]);
            console.log('üì¶ grass_sand keys:', Object.keys(allMappings.grass_sand));
            return allMappings;
        }
        
        window.generateTerrainV2 = async function() {
            const use3D = document.getElementById('enable3DHeight')?.checked ?? true; // Default to 3D enabled
            
            // If 3D checkbox is checked, use WebGL renderer
            if (use3D) {
                await generateTerrainV2_WebGL();
                return;
            }
            
            // Otherwise use 2D canvas
            showCanvas2D();
            document.getElementById('status').textContent = 'Generating terrain (V2 - Proper Tile Sets)...';
            
            try {
                const width = parseInt(document.getElementById('width').value) || 50;
                const height = parseInt(document.getElementById('height').value) || 50;
                const seedInput = document.getElementById('seed').value;
                
                // Create V2 generator with seed AND ALL custom tile mappings from Tile Teacher
                const seed = seedInput ? parseInt(seedInput) : Date.now();
                const allMappings = getAllSavedTransitionMappings();
                const genV2 = new TerrainGeneratorV2(seed, allMappings);
                
                const map = genV2.generateMap(width, height);
                updateCurrentMapReference(map);
                await renderMap(map);
                
                const mappingCount = Object.keys(allMappings).length;
                document.getElementById('status').textContent = `‚úÖ V2 Generated ${width}x${height} map (Seed: ${seed}) - Using ${mappingCount} transition mappings`;
            } catch (error) {
                document.getElementById('status').textContent = `‚ùå Error: ${error.message}`;
                console.error('V2 Generation error:', error);
            }
        };
        
        // WebGL 3D version of generateTerrainV2 - called when 3D checkbox is checked
        async function generateTerrainV2_WebGL() {
            document.getElementById('status').textContent = 'Generating 3D terrain with WebGL...';
            
            try {
                const width = parseInt(document.getElementById('width').value) || 50;
                const height = parseInt(document.getElementById('height').value) || 50;
                const seedInput = document.getElementById('seed').value;
                
                // Generate the map using V2 generator
                const seed = seedInput ? parseInt(seedInput) : Date.now();
                const allMappings = getAllSavedTransitionMappings();
                const genV2 = new TerrainGeneratorV2(seed, allMappings);
                const map = genV2.generateMap(width, height);
                updateCurrentMapReference(map);
                
                // Create a separate canvas for WebGL (can't mix 2D and WebGL contexts)
                const canvasContainer = document.getElementById('canvas').parentElement;
                const originalCanvas = document.getElementById('canvas');
                
                // Remove old WebGL canvas if exists
                if (webglCanvas && webglCanvas.parentElement) {
                    webglCanvas.parentElement.removeChild(webglCanvas);
                }
                
                // Create new WebGL canvas
                webglCanvas = document.createElement('canvas');
                webglCanvas.id = 'webgl-canvas';
                webglCanvas.style.display = 'block';
                webglCanvas.style.border = 'none';
                webglCanvas.style.background = '#1a1a2e';
                
                // Hide original canvas, show WebGL canvas
                originalCanvas.style.display = 'none';
                
                // Enable scrolling for WebGL canvas (it's larger than the container)
                canvasContainer.style.overflow = 'auto';
                canvasContainer.appendChild(webglCanvas);
                
                console.log('WebGL canvas created and appended, container:', canvasContainer);
                
                // Create WebGL renderer on the new canvas
                try {
                    webglRenderer = new WebGLTerrainRenderer(webglCanvas);
                } catch (e) {
                    document.getElementById('status').textContent = `‚ùå WebGL not supported: ${e.message}`;
                    console.error('WebGL init error:', e);
                    originalCanvas.style.display = 'block';
                    return;
                }
                
                // Generate corner heights from the map
                const cornerHeights = WebGLTerrainRenderer.generateCornerHeights(map, width, height);
                
                // Preload all tile textures
                document.getElementById('status').textContent = 'Loading textures for WebGL 3D...';
                const uniqueTileIds = new Set();
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        uniqueTileIds.add(map[y][x].id);
                    }
                }
                
                // Load each unique tile as a WebGL texture
                console.log('Unique tile IDs to load for WebGL:', Array.from(uniqueTileIds));
                let loadedCount = 0;
                for (const tileId of uniqueTileIds) {
                    const processedImage = await loadTileImage(tileId);
                    if (processedImage) {
                        webglRenderer.loadTexture(tileId, processedImage);
                        loadedCount++;
                    } else {
                        console.warn('Failed to load tile for WebGL:', tileId);
                    }
                }
                
                console.log(`Loaded ${loadedCount}/${uniqueTileIds.size} textures for WebGL`);
                
                // Render with WebGL
                webglRenderer.render(map, cornerHeights, null);
                
                // Log canvas dimensions after render
                console.log('WebGL canvas after render:', webglCanvas.width, 'x', webglCanvas.height);
                
                const mappingCount = Object.keys(allMappings).length;
                document.getElementById('status').textContent = `‚úÖ 3D V2 Generated ${width}x${height} map (Seed: ${seed}) - WebGL with ${mappingCount} transitions. Use scroll/drag to navigate.`;
                
                // Auto-center and auto-zoom the map
                setTimeout(() => {
                    fitToView();
                }, 100);
            } catch (error) {
                document.getElementById('status').textContent = `‚ùå WebGL Error: ${error.message}`;
                console.error('WebGL 3D Generation error:', error);
            }
        }
        
        // WebGL 3D Terrain Renderer - UO-style texture-mapped triangles with Z-height
        let webglCanvas = null;  // Separate canvas for WebGL
        
        // Switch back to 2D canvas when using other generators
        function showCanvas2D() {
            const originalCanvas = document.getElementById('canvas');
            const canvasContainer = document.getElementById('canvasContainer');
            if (webglCanvas && webglCanvas.parentElement) {
                webglCanvas.style.display = 'none';
            }
            originalCanvas.style.display = 'block';
            // Restore overflow hidden for 2D canvas (uses transform-based panning)
            canvasContainer.style.overflow = 'hidden';
        }
        
        window.generateTestMapV2 = async function() {
            document.getElementById('status').textContent = 'Generating V2 test scene...';
            
            try {
                const genV2 = new TerrainGeneratorV2(12345); // Fixed seed for testing
                const map = genV2.generateTestMap(40, 40);
                updateCurrentMapReference(map);
                await renderMap(map);
                
                document.getElementById('status').textContent = `‚úÖ V2 Test Scene - Proper Tile Tessellation`;
            } catch (error) {
                console.error(error);
                document.getElementById('status').textContent = `‚ùå Error: ${error.message}`;
            }
        };

        window.generateCliffTest = async function(mode = 'rough') {
            // Map boolean to string for legacy compatibility
            if (typeof mode === 'boolean') {
                mode = mode ? 'cave' : 'rough';
            }
            
            let typeName = 'Rock (Rough)';
            if (mode === 'cave') typeName = 'Cave (Smooth)';
            if (mode === 'match') typeName = 'Mountain Match (0x01D3)';
            
            document.getElementById('status').textContent = `Generating ${typeName} Face test...`;
            
            try {
                const genV2 = new TerrainGeneratorV2(12345); 
                const map = genV2.generateCliffTestMap(40, 40, mode);
                updateCurrentMapReference(map);
                await renderMap(map);
                
                document.getElementById('status').textContent = `‚úÖ ${typeName} Face Test - High elevation cliff wall`;
            } catch (error) {
                console.error(error);
                document.getElementById('status').textContent = `‚ùå Error: ${error.message}`;
            }
        };
        
        // Helper function to determine biome from tile ID
        function getBiomeFromTileId(tileId) {
            const id = typeof tileId === 'string' ? parseInt(tileId, 16) : tileId;
            
            // Void/Black tiles - these are impassable holes/caves
            if (id === 0x0001 || id === 0x0002) return 'void';  // Common void tiles
            if (id >= 0x3FF8 && id <= 0x3FFB) return 'void';    // Extended void tiles (16376-16379)
            if (id >= 0x054C && id <= 0x0553) return 'cave';    // Cave floor tiles (1356-1363)
            
            // Water tiles - IMPORTANT: 0x00A8-0x00AB (168-171) is the main water tileset!
            if (id >= 0x00A8 && id <= 0x00AB) return 'water';  // Main water (168-171)
            if (id >= 0x0160 && id <= 0x017F) return 'water';  // Additional water (352-383)
            
            // Swamp/Marsh tiles (0x00AC-0x00C3) - gray rocky swamp, no vegetation
            if (id >= 0x00AC && id <= 0x00C3) return 'swamp';
            
            // Sand tiles (0x001C-0x0033) - includes sand embankments
            if (id >= 0x001C && id <= 0x0033) return 'sand';
            
            // Sand transition tiles (0x0048-0x006F)
            if (id >= 0x0048 && id <= 0x006F) return 'sand';
            
            // Dirt tiles (0x0136-0x014B)
            if (id >= 0x0136 && id <= 0x014B) return 'dirt';
            
            // Rock/Mountain tiles (0x00DC-0x00FF) - rough rock
            if (id >= 0x00DC && id <= 0x00FF) return 'rock';
            
            // Rock transitions (0x0071-0x008F)
            if (id >= 0x0071 && id <= 0x008F) return 'rock';
            
            // Rock/Cliff transitions (0x00C4-0x00DB)
            if (id >= 0x00C4 && id <= 0x00DB) return 'rock';
            
            // Mountain rock (0x01D3-0x01DA)
            if (id >= 0x01D3 && id <= 0x01DA) return 'rock';
            
            // Grass tiles (0x0003-0x001A)
            if (id >= 0x0003 && id <= 0x001A) return 'grass';
            
            // Forest/grass tiles (0x0034-0x0047)
            if (id >= 0x0034 && id <= 0x0047) return 'forest';
            
            // Grass-rock transitions (0x021F-0x0243)
            if (id >= 0x021F && id <= 0x0243) return 'grass';
            
            // Grass-sand transitions (0x0244-0x0267)
            if (id >= 0x0244 && id <= 0x0267) return 'grass';
            
            // Default to grass
            return 'grass';
        }
        
        // Helper function to detect water edges and apply embankments
        function applyEmbankmentsToRealMap(map, width, height) {
            // First pass: mark water edges
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const tile = map[y][x];
                    if (tile.biome === 'water') continue;
                    
                    // Check neighbors for water
                    let hasWaterNeighbor = false;
                    const waterDirs = {
                        north: false, south: false, east: false, west: false,
                        northEast: false, northWest: false, southEast: false, southWest: false
                    };
                    
                    // Check cardinal directions
                    if (y > 0 && map[y-1][x].biome === 'water') {
                        hasWaterNeighbor = true;
                        waterDirs.north = true;
                    }
                    if (y < height-1 && map[y+1][x].biome === 'water') {
                        hasWaterNeighbor = true;
                        waterDirs.south = true;
                    }
                    if (x < width-1 && map[y][x+1].biome === 'water') {
                        hasWaterNeighbor = true;
                        waterDirs.east = true;
                    }
                    if (x > 0 && map[y][x-1].biome === 'water') {
                        hasWaterNeighbor = true;
                        waterDirs.west = true;
                    }
                    
                    // Check diagonal directions
                    if (y > 0 && x < width-1 && map[y-1][x+1].biome === 'water') {
                        hasWaterNeighbor = true;
                        waterDirs.northEast = true;
                    }
                    if (y > 0 && x > 0 && map[y-1][x-1].biome === 'water') {
                        hasWaterNeighbor = true;
                        waterDirs.northWest = true;
                    }
                    if (y < height-1 && x < width-1 && map[y+1][x+1].biome === 'water') {
                        hasWaterNeighbor = true;
                        waterDirs.southEast = true;
                    }
                    if (y < height-1 && x > 0 && map[y+1][x-1].biome === 'water') {
                        hasWaterNeighbor = true;
                        waterDirs.southWest = true;
                    }
                    
                    if (hasWaterNeighbor) {
                        tile.isWaterEdge = true;
                        tile.waterDirs = waterDirs;
                    }
                }
            }
            
            // Second pass: apply embankment tiles
            const GRASS_EMBANKMENT = {
                waterNorth: ['0x098C', '0x098D', '0x098E', '0x098F'],
                waterSouth: ['0x0990', '0x0991', '0x0992', '0x0993'],
                waterEast:  ['0x0994', '0x0995', '0x0996', '0x0997'],
                waterWest:  ['0x0998', '0x0999', '0x099A', '0x099B'],
                waterNE: ['0x099C', '0x099D'],
                waterNW: ['0x099E', '0x099F'],
                waterSE: ['0x09A0', '0x09A1'],
                waterSW: ['0x09A2', '0x09A3'],
                landNE: ['0x09A4', '0x09A5'],
                landNW: ['0x09A6', '0x09A7'],
                landSE: ['0x09A8', '0x09A9'],
                landSW: ['0x09AA', '0x09AB'],
                surrounded: ['0x09AC', '0x09AD', '0x09AE', '0x09AF']
            };
            
            const SAND_EMBANKMENT = {
                waterNorth: ['0x001C', '0x001D', '0x001E', '0x001F'],
                waterSouth: ['0x0020', '0x0021', '0x0022', '0x0023'],
                waterEast:  ['0x0024', '0x0025', '0x0026', '0x0027'],
                waterWest:  ['0x0028', '0x0029', '0x002A', '0x002B'],
                waterNE: ['0x002C', '0x002D'],
                waterNW: ['0x002E', '0x002F'],
                waterSE: ['0x0030', '0x0031'],
                waterSW: ['0x0032', '0x0033']
            };
            
            let embankmentCount = 0;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const tile = map[y][x];
                    if (!tile.isWaterEdge || tile.biome === 'water') continue;
                    
                    const waterDirs = tile.waterDirs;
                    const cardinalWater = [waterDirs.north, waterDirs.south, waterDirs.east, waterDirs.west]
                        .filter(Boolean).length;
                    
                    const EMBANKMENT = tile.biome === 'sand' ? SAND_EMBANKMENT : GRASS_EMBANKMENT;
                    let embankTiles = null;
                    
                    // Apply embankment based on water direction
                    if (cardinalWater >= 3) {
                        // Peninsula
                        if (!waterDirs.south && !waterDirs.east) embankTiles = EMBANKMENT.landSE;
                        else if (!waterDirs.south && !waterDirs.west) embankTiles = EMBANKMENT.landSW;
                        else if (!waterDirs.north && !waterDirs.east) embankTiles = EMBANKMENT.landNE;
                        else if (!waterDirs.north && !waterDirs.west) embankTiles = EMBANKMENT.landNW;
                        else embankTiles = EMBANKMENT.surrounded || EMBANKMENT.waterNorth;
                    } else if (cardinalWater === 2) {
                        // Outer corner
                        if (waterDirs.north && waterDirs.east) embankTiles = EMBANKMENT.waterNE;
                        else if (waterDirs.north && waterDirs.west) embankTiles = EMBANKMENT.waterNW;
                        else if (waterDirs.south && waterDirs.east) embankTiles = EMBANKMENT.waterSE;
                        else if (waterDirs.south && waterDirs.west) embankTiles = EMBANKMENT.waterSW;
                        else if (waterDirs.north) embankTiles = EMBANKMENT.waterNorth;
                        else if (waterDirs.east) embankTiles = EMBANKMENT.waterEast;
                    } else if (cardinalWater === 1) {
                        // Edge
                        if (waterDirs.north) embankTiles = EMBANKMENT.waterNorth;
                        else if (waterDirs.south) embankTiles = EMBANKMENT.waterSouth;
                        else if (waterDirs.east) embankTiles = EMBANKMENT.waterEast;
                        else if (waterDirs.west) embankTiles = EMBANKMENT.waterWest;
                    } else {
                        // Diagonal only
                        if (waterDirs.northEast) embankTiles = EMBANKMENT.waterNE;
                        else if (waterDirs.northWest) embankTiles = EMBANKMENT.waterNW;
                        else if (waterDirs.southEast) embankTiles = EMBANKMENT.waterSE;
                        else if (waterDirs.southWest) embankTiles = EMBANKMENT.waterSW;
                    }
                    
                    if (embankTiles && embankTiles.length > 0) {
                        const index = ((x * 7 + y * 13) % embankTiles.length);
                        tile.id = embankTiles[index];
                        tile.isEmbankment = true;
                        embankmentCount++;
                    }
                }
            }
            
            console.log(`[loadRealUOMap] Applied ${embankmentCount} embankment tiles`);
        }
        
        // Helper function to update progress bar (make it globally accessible)
        window.updateProgress = function(percent, message = null) {
            const progressBar = document.getElementById('progressBar');
            if (progressBar) {
                progressBar.style.width = `${Math.min(100, Math.max(0, percent))}%`;
            }
            if (message) {
                const statusEl = document.getElementById('status');
                if (statusEl) {
                    statusEl.textContent = message;
                }
            }
        };
        
        window.loadRealUOMap = async function(fixedX = null, fixedY = null, regionName = 'Region', options = {}) {
            let blendProcedural = options.blendProcedural === true;
            const blendSeed = options.blendSeed ?? Math.floor(Math.random() * 100000);
            const scenarioKey = options.scenario || null;
            const scenarioPreset = getScenarioPreset(scenarioKey);
            currentScenario = scenarioPreset || null;
            if (scenarioPreset) {
                blendProcedural = true;
                if (scenarioPreset.region && fixedX === null && fixedY === null) {
                    fixedX = scenarioPreset.region.x;
                    fixedY = scenarioPreset.region.y;
                }
                if (!regionName || regionName === 'Region') {
                    regionName = scenarioPreset.name;
                }
            }
            
            const statusEl = document.getElementById('status');
            statusEl.textContent = 'üîÑ Loading real UO map data...';
            statusEl.style.color = '#4CAF50';
            updateProgress(0, 'üîÑ Loading real UO map data...');
            
            try {
                console.log('[loadRealUOMap] Starting...');
                
                if (mapLoadInProgress) {
                    console.warn('[loadRealUOMap] Load already in progress, ignoring new request.');
                    statusEl.textContent = '‚è≥ Already loading a region...';
                    return;
                }
                mapLoadInProgress = true;
                
                // Initialize static loader
                const staticLoader = new UOStaticLoader();
                
                // Load map
                updateProgress(5, 'üîÑ Loading map0.mul...');
                const loaded = await uoMapLoader.loadMap('./assets/mul/map0.mul', 7168, 4096);
                
                if (!loaded) {
                    throw new Error('Failed to load map0.mul. Check console for details.');
                }
                
                updateProgress(20, '‚úÖ Map loaded! Checking for static objects...');
                
                // Try to load statics (optional - may not exist yet)
                let staticsLoaded = false;
                let staticsCount = 0;
                try {
                    // First check if files exist by trying to fetch them
                    updateProgress(25, 'üîç Checking for statics files...');
                    const indexCheck = await fetch('./assets/mul/staidx0.mul', { method: 'HEAD' });
                    const staticCheck = await fetch('./assets/mul/statics0.mul', { method: 'HEAD' });
                    
                    if (!indexCheck.ok || !staticCheck.ok) {
                        statusEl.textContent = '‚ö†Ô∏è  Statics files not found (statics0.mul, staidx0.mul)';
                        statusEl.style.color = '#ff9800';
                        console.warn('[loadRealUOMap] ‚ö†Ô∏è  Statics files not found in assets/mul/');
                        console.warn('[loadRealUOMap] Files needed: statics0.mul and staidx0.mul');
                        console.warn('[loadRealUOMap] Copy them from "Ultima Online Classic" folder to assets/mul/');
                        console.warn('[loadRealUOMap] Or run: copy_statics.bat');
                    } else {
                        updateProgress(30, 'üîÑ Loading static objects...');
                        staticsLoaded = await staticLoader.loadStatics(
                            './assets/mul/statics0.mul',
                            './assets/mul/staidx0.mul',
                            7168, 4096
                        );
                        if (staticsLoaded) {
                            const info = staticLoader.getInfo();
                            updateProgress(40, `‚úÖ Statics loaded! (Index: ${(info.indexSize / 1024 / 1024).toFixed(1)}MB, Data: ${(info.staticSize / 1024 / 1024).toFixed(1)}MB)`);
                            statusEl.style.color = '#4CAF50';
                            console.log('[loadRealUOMap] ‚úÖ Statics loaded successfully');
                            console.log('[loadRealUOMap] Static files:', {
                                indexSize: `${(info.indexSize / 1024 / 1024).toFixed(2)} MB`,
                                staticSize: `${(info.staticSize / 1024 / 1024).toFixed(2)} MB`
                            });
                        }
                    }
                } catch (e) {
                    statusEl.textContent = `‚ö†Ô∏è  Statics not available: ${e.message}`;
                    statusEl.style.color = '#ff9800';
                    console.warn('[loadRealUOMap] ‚ö†Ô∏è  Statics not available:', e.message);
                    console.warn('[loadRealUOMap] Copy statics0.mul and staidx0.mul to assets/mul/ to enable static objects');
                    console.warn('[loadRealUOMap] Or run: copy_statics.bat');
                }
                
                const info = uoMapLoader.getMapInfo();
                console.log('[loadRealUOMap] Map info:', info);
                
                // Region size
                const regionWidth = 60;
                const regionHeight = 60;
                
                // Check if we should use fixed coordinates or random
                let regionX, regionY;
                if (fixedX !== null && fixedY !== null) {
                    // Use directly passed coordinates (preferred method)
                    regionX = fixedX;
                    regionY = fixedY;
                    console.log(`[loadRealUOMap] üè∞ ${regionName}: (${regionX}, ${regionY})`);
                    updateProgress(10, `üè∞ ${regionName}: X=${regionX}, Y=${regionY} (${regionWidth}√ó${regionHeight})`);
                } else if (window.useFixedRegion && window.fixedRegionX !== undefined) {
                    // Legacy global variable method (for backwards compatibility)
                    regionX = window.fixedRegionX;
                    regionY = window.fixedRegionY;
                    window.useFixedRegion = false; // Reset for next time
                    console.log(`[loadRealUOMap] üè∞ Fixed region: (${regionX}, ${regionY})`);
                } else {
                    // Random region from the map (map0 is 7168 x 4096)
                    const maxX = 7168 - regionWidth - 100;
                    const maxY = 4096 - regionHeight - 100;
                    regionX = Math.floor(Math.random() * maxX);
                    regionY = Math.floor(Math.random() * maxY);
                    console.log(`[loadRealUOMap] üé≤ Random region: (${regionX}, ${regionY})`);
                    
                    // Show coordinates prominently
                    updateProgress(10, `üé≤ RANDOM REGION: X=${regionX}, Y=${regionY} (${regionWidth}√ó${regionHeight})`);
                }
                
                console.log(`[loadRealUOMap] Region size: ${regionWidth}√ó${regionHeight}`);
                
                // Brief pause to show coordinates
                await new Promise(r => setTimeout(r, 500));
                
                updateProgress(45, `üîÑ Loading region (${regionX}, ${regionY})...`);
                console.log(`[loadRealUOMap] Extracting region (${regionX}, ${regionY}) size ${regionWidth}√ó${regionHeight}`);
                
                const region = uoMapLoader.extractRegion(regionX, regionY, regionWidth, regionHeight);
                
                updateProgress(50, 'üîÑ Processing terrain data...');
                
                // Load statics for this region (limit removed for real map load)
                let statics = [];
                let hybridProceduralStatics = [];
                let hybridOverlayMap = null;
                if (staticsLoaded) {
                    try {
                        updateProgress(55, 'üîÑ Loading static objects for region...');
                        statics = staticLoader.getStaticsForRegion(regionX, regionY, regionWidth, regionHeight);
                        staticsCount = statics.length;
                        console.log(`[loadRealUOMap] Found ${statics.length} static objects in region`);
                        if (statics.length > 0) {
                            const uniqueGraphics = new Set(statics.map(s => s.hexId));
                            updateProgress(60, `‚úÖ Found ${statics.length} static objects (${uniqueGraphics.size} types)`);
                            statusEl.style.color = '#4CAF50';
                            console.log(`[loadRealUOMap] Unique static graphics: ${uniqueGraphics.size}`, Array.from(uniqueGraphics).slice(0, 10));
                            console.log(`[loadRealUOMap] Sample static:`, statics[0]);
                        } else {
                            statusEl.textContent = `‚ö†Ô∏è  No statics in this region (${regionX}, ${regionY})`;
                            statusEl.style.color = '#ff9800';
                            console.warn(`[loadRealUOMap] ‚ö†Ô∏è  No statics found in region (${regionX}, ${regionY}) size ${regionWidth}√ó${regionHeight}`);
                            console.warn(`[loadRealUOMap] This area might not have static objects, or files might be empty`);
                        }
                    } catch (e) {
                        statusEl.textContent = `‚ùå Error loading statics: ${e.message}`;
                        statusEl.style.color = '#f44336';
                        console.error(`[loadRealUOMap] Error loading statics:`, e);
                    }
                } else {
                    statusEl.textContent = '‚ö†Ô∏è  Statics files missing - copy statics0.mul and staidx0.mul to assets/mul/';
                    statusEl.style.color = '#ff9800';
                    console.warn(`[loadRealUOMap] ‚ö†Ô∏è  Statics not loaded - files missing or failed to load`);
                    console.warn(`[loadRealUOMap] Check: assets/mul/statics0.mul and assets/mul/staidx0.mul exist`);
                }
                
                // Convert to our map format with biome detection
                // IMPORTANT: Keep original tile IDs - don't replace with embankment IDs
                // The 3D renderer will handle height differences automatically
                const map = [];
                let minZ = Infinity;
                let maxZ = -Infinity;
                
                for (let y = 0; y < regionHeight; y++) {
                    map[y] = [];
                    for (let x = 0; x < regionWidth; x++) {
                        const tile = region[y][x];
                        const biome = getBiomeFromTileId(tile.tileId);
                        
                        // Track Z range for normalization
                        if (tile.z < minZ) minZ = tile.z;
                        if (tile.z > maxZ) maxZ = tile.z;
                        
                        const isWaterTile = biome === 'water';
                        map[y][x] = {
                            id: tile.hexId, // Keep original tile ID!
                            biome: biome,
                            elevation: tile.z, // Store raw Z for 3D rendering
                            moisture: isWaterTile ? 1.0 : 0.5,
                            z: tile.z, // Signed Z-height (-128 to 127)
                            isWater: isWaterTile, // Explicitly mark water tiles
                            isWaterEdge: false,
                            originalTileId: tile.tileId // Keep original for reference
                        };
                    }
                }
                
                console.log(`[loadRealUOMap] Z-height range: ${minZ} to ${maxZ}`);
            
            // Attach surface metadata so statics know whether tiles are water/road/etc.
            annotateMapWithSurfaces(map, { landTileData });
                
                // First, check what tile IDs are actually in the map file
                // UO map files MAY already contain embankment tiles - we should check before replacing
                const tileIdCounts = {};
                const embankmentTileIds = new Set([
                    // Grass embankments
                    '0x098C', '0x098D', '0x098E', '0x098F', '0x0990', '0x0991', '0x0992', '0x0993',
                    '0x0994', '0x0995', '0x0996', '0x0997', '0x0998', '0x0999', '0x099A', '0x099B',
                    '0x099C', '0x099D', '0x099E', '0x099F', '0x09A0', '0x09A1', '0x09A2', '0x09A3',
                    '0x09A4', '0x09A5', '0x09A6', '0x09A7', '0x09A8', '0x09A9', '0x09AA', '0x09AB',
                    '0x09AC', '0x09AD', '0x09AE', '0x09AF', '0x09B0', '0x09B1', '0x09B2', '0x09B3',
                    '0x09B4', '0x09B5', '0x09B6', '0x09B7', '0x09B8', '0x09B9', '0x09BA', '0x09BB',
                    '0x09BC', '0x09BD', '0x09BE', '0x09BF',
                    // Sand embankments
                    '0x001C', '0x001D', '0x001E', '0x001F', '0x0020', '0x0021', '0x0022', '0x0023',
                    '0x0024', '0x0025', '0x0026', '0x0027', '0x0028', '0x0029', '0x002A', '0x002B',
                    '0x002C', '0x002D', '0x002E', '0x002F', '0x0030', '0x0031', '0x0032', '0x0033'
                ]);
                
                for (let y = 0; y < regionHeight; y++) {
                    for (let x = 0; x < regionWidth; x++) {
                        const tileId = map[y][x].id;
                        tileIdCounts[tileId] = (tileIdCounts[tileId] || 0) + 1;
                    }
                }
                
                // Debug: Log all unique tile IDs to see what's in the map file
                console.log(`[loadRealUOMap] üìä ALL TILE IDS IN REGION:`, Object.keys(tileIdCounts).sort());
                console.log(`[loadRealUOMap] üìä Tile counts:`, Object.entries(tileIdCounts).sort((a,b) => b[1] - a[1]).slice(0, 20));
                
                // Check for sand embankment tiles specifically
                const sandEmbankIds = ['0x001C', '0x001D', '0x001E', '0x001F', '0x0020', '0x0021', '0x0022', '0x0023',
                                       '0x0024', '0x0025', '0x0026', '0x0027', '0x0028', '0x0029', '0x002A', '0x002B'];
                const foundSandEmbanks = sandEmbankIds.filter(id => tileIdCounts[id]);
                console.log(`[loadRealUOMap] üèñÔ∏è SAND EMBANKMENT TILES FOUND:`, foundSandEmbanks.length > 0 ? foundSandEmbanks : 'NONE!');
                
                const foundEmbankments = Object.keys(tileIdCounts).filter(id => embankmentTileIds.has(id));
                console.log(`[loadRealUOMap] Found ${foundEmbankments.length} embankment tile types already in map:`, foundEmbankments);
                console.log(`[loadRealUOMap] Top 10 tile IDs in map:`, Object.entries(tileIdCounts)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 10)
                    .map(([id, count]) => `${id} (${count})`));
                
                // Check if we should trust original tiles (skip embankment replacement)
                const trustOriginal = document.getElementById('trustOriginalTiles')?.checked ?? true;
                
                if (trustOriginal) {
                    console.log('[loadRealUOMap] üìú Trusting original map tiles - no embankment replacement');
                }
                
                // Apply embankment tiles at water edges (UO Classic style)
                // BUT: Only if "Trust Original Map" is unchecked
                // If embankments are already in the map file, trust them!
                // UO uses specific embankment tile graphics (0x098C-0x09BF) at water edges
                // These tiles show the cliff face, and 3D rendering adds the height effect
                const GRASS_EMBANKMENT = {
                    waterNorth: ['0x098C', '0x098D', '0x098E', '0x098F'],
                    waterSouth: ['0x0990', '0x0991', '0x0992', '0x0993'],
                    waterEast:  ['0x0994', '0x0995', '0x0996', '0x0997'],
                    waterWest:  ['0x0998', '0x0999', '0x099A', '0x099B'],
                    waterNE: ['0x099C', '0x099D'],
                    waterNW: ['0x099E', '0x099F'],
                    waterSE: ['0x09A0', '0x09A1'],
                    waterSW: ['0x09A2', '0x09A3'],
                    landNE: ['0x09A4', '0x09A5'],
                    landNW: ['0x09A6', '0x09A7'],
                    landSE: ['0x09A8', '0x09A9'],
                    landSW: ['0x09AA', '0x09AB'],
                    surrounded: ['0x09AC', '0x09AD', '0x09AE', '0x09AF']
                };
                
                const SAND_EMBANKMENT = {
                    waterNorth: ['0x001C', '0x001D', '0x001E', '0x001F'],
                    waterSouth: ['0x0020', '0x0021', '0x0022', '0x0023'],
                    waterEast:  ['0x0024', '0x0025', '0x0026', '0x0027'],
                    waterWest:  ['0x0028', '0x0029', '0x002A', '0x002B'],
                    waterNE: ['0x002C', '0x002D'],
                    waterNW: ['0x002E', '0x002F'],
                    waterSE: ['0x0030', '0x0031'],
                    waterSW: ['0x0032', '0x0033'],
                    // For peninsulas (land surrounded by water on 3 sides)
                    landNE: ['0x002C', '0x002D'],
                    landNW: ['0x002E', '0x002F'],
                    landSE: ['0x0030', '0x0031'],
                    landSW: ['0x0032', '0x0033'],
                    surrounded: ['0x001C', '0x0020', '0x0024', '0x0028']
                };
                
                let embankmentCount = 0;
                
                // Only apply embankment replacement if "Trust Original Map" is unchecked
                if (!trustOriginal) {
                for (let y = 0; y < regionHeight; y++) {
                    for (let x = 0; x < regionWidth; x++) {
                        const tile = map[y][x];
                        if (tile.biome === 'water') continue;
                        
                        // Check neighbors for water
                        const waterDirs = {
                            north: y > 0 && map[y-1][x].biome === 'water',
                            south: y < regionHeight-1 && map[y+1][x].biome === 'water',
                            east: x < regionWidth-1 && map[y][x+1].biome === 'water',
                            west: x > 0 && map[y][x-1].biome === 'water',
                            northEast: y > 0 && x < regionWidth-1 && map[y-1][x+1].biome === 'water',
                            northWest: y > 0 && x > 0 && map[y-1][x-1].biome === 'water',
                            southEast: y < regionHeight-1 && x < regionWidth-1 && map[y+1][x+1].biome === 'water',
                            southWest: y < regionHeight-1 && x > 0 && map[y+1][x-1].biome === 'water'
                        };
                        
                        const cardinalWater = [waterDirs.north, waterDirs.south, waterDirs.east, waterDirs.west]
                            .filter(Boolean).length;
                        
                        if (cardinalWater === 0 && !waterDirs.northEast && !waterDirs.northWest && 
                            !waterDirs.southEast && !waterDirs.southWest) {
                            continue; // No water neighbors
                        }
                        
                        tile.isWaterEdge = true;
                        
                        // Select embankment tiles based on biome
                        // UO uses SAND embankments at most coastlines (creates beach effect)
                        // Only use rocky cliff embankments for actual rock/mountain tiles
                        const isRockTile = tile.biome === 'rock' || tile.biome === 'mountain' || 
                            (parseInt(tile.id, 16) >= 0x00DC && parseInt(tile.id, 16) <= 0x00E7) || // Dark stone
                            (parseInt(tile.id, 16) >= 0x00E8 && parseInt(tile.id, 16) <= 0x00EB) || // Light rock
                            (parseInt(tile.id, 16) >= 0x021F && parseInt(tile.id, 16) <= 0x0243);   // Mountain rock
                        
                        // Use sand embankments for grass/forest/jungle (beach effect)
                        // Use cliff embankments only for actual rock/mountain tiles  
                        const EMBANKMENT = isRockTile ? GRASS_EMBANKMENT : SAND_EMBANKMENT;
                        let embankTiles = null;
                        
                        // Apply embankment based on water direction
                        if (cardinalWater >= 3) {
                            // Peninsula
                            if (!waterDirs.south && !waterDirs.east) embankTiles = EMBANKMENT.landSE;
                            else if (!waterDirs.south && !waterDirs.west) embankTiles = EMBANKMENT.landSW;
                            else if (!waterDirs.north && !waterDirs.east) embankTiles = EMBANKMENT.landNE;
                            else if (!waterDirs.north && !waterDirs.west) embankTiles = EMBANKMENT.landNW;
                            else embankTiles = EMBANKMENT.surrounded || EMBANKMENT.waterNorth;
                        } else if (cardinalWater === 2) {
                            // Outer corner
                            if (waterDirs.north && waterDirs.east) embankTiles = EMBANKMENT.waterNE;
                            else if (waterDirs.north && waterDirs.west) embankTiles = EMBANKMENT.waterNW;
                            else if (waterDirs.south && waterDirs.east) embankTiles = EMBANKMENT.waterSE;
                            else if (waterDirs.south && waterDirs.west) embankTiles = EMBANKMENT.waterSW;
                            else if (waterDirs.north) embankTiles = EMBANKMENT.waterNorth;
                            else if (waterDirs.east) embankTiles = EMBANKMENT.waterEast;
                        } else if (cardinalWater === 1) {
                            // Edge
                            if (waterDirs.north) embankTiles = EMBANKMENT.waterNorth;
                            else if (waterDirs.south) embankTiles = EMBANKMENT.waterSouth;
                            else if (waterDirs.east) embankTiles = EMBANKMENT.waterEast;
                            else if (waterDirs.west) embankTiles = EMBANKMENT.waterWest;
                        } else {
                            // Diagonal only
                            if (waterDirs.northEast) embankTiles = EMBANKMENT.waterNE;
                            else if (waterDirs.northWest) embankTiles = EMBANKMENT.waterNW;
                            else if (waterDirs.southEast) embankTiles = EMBANKMENT.waterSE;
                            else if (waterDirs.southWest) embankTiles = EMBANKMENT.waterSW;
                        }
                        
                        if (embankTiles && embankTiles.length > 0) {
                            // Only replace if the original tile is NOT already an embankment
                            // The map file may already have correct embankment tiles!
                            const originalId = tile.originalTileId.toString(16).toUpperCase().padStart(4, '0');
                            const originalHexId = `0x${originalId}`;
                            
                            if (!embankmentTileIds.has(originalHexId)) {
                                // Original tile is NOT an embankment - replace it
                                const index = ((x * 7 + y * 13) % embankTiles.length);
                                tile.id = embankTiles[index]; // Replace with embankment tile
                                tile.isEmbankment = true;
                                tile.wasReplaced = true; // Mark that we replaced it
                                embankmentCount++;
                            } else {
                                // Original tile IS already an embankment - keep it!
                                tile.isEmbankment = true;
                                tile.wasReplaced = false; // Mark that we kept the original
                            }
                        }
                    }
                }
                } // End of if (!trustOriginal)
                
                const replacedCount = map.flat().filter(t => t.wasReplaced === true).length;
                const keptCount = map.flat().filter(t => t.isEmbankment && t.wasReplaced === false).length;
                
                if (!trustOriginal) {
                    console.log(`[loadRealUOMap] Embankment summary:`);
                    console.log(`  - Applied ${embankmentCount} embankment tiles at water edges`);
                    console.log(`  - Replaced ${replacedCount} tiles (were not embankments)`);
                    console.log(`  - Kept ${keptCount} original embankment tiles (already in map file)`);
                }
                
                // Summary: Are we accurately mirroring the file?
                const totalTiles = regionWidth * regionHeight;
                const waterTiles = map.flat().filter(t => t.biome === 'water').length;
                const landTiles = totalTiles - waterTiles;
                console.log(`[loadRealUOMap] Map summary:`);
                console.log(`  - Total tiles: ${totalTiles}`);
                console.log(`  - Water tiles: ${waterTiles}`);
                console.log(`  - Land tiles: ${landTiles}`);
                console.log(`  - Water edges: ${map.flat().filter(t => t.isWaterEdge).length}`);
                console.log(`  - Unique tile IDs: ${Object.keys(tileIdCounts).length}`);
                
                if (blendProcedural) {
                    console.log(`[HybridBlend] Mixing in procedural overlay (seed ${blendSeed}) for ${regionWidth}√ó${regionHeight}`);
                    const overlayGenerator = new TerrainGeneratorV2(blendSeed, null, {
                        enableProceduralRegioning: true,
                        embankmentChance: 0.6
                    });
                    hybridOverlayMap = overlayGenerator.generateMap(regionWidth, regionHeight);
                    
                    // Blend overlay metadata into the real map for richer data visualizations
                    for (let y = 0; y < regionHeight; y++) {
                        for (let x = 0; x < regionWidth; x++) {
                            const overlayTile = hybridOverlayMap[y][x];
                            const baseTile = map[y][x];
                            if (!overlayTile || !baseTile) continue;
                            
                            baseTile.hybridOverlay = {
                                biome: overlayTile.biome,
                                tileId: overlayTile.id,
                                moisture: overlayTile.moisture,
                                z: overlayTile.z
                            };
                            
                            // Soften moisture differences to reduce harsh edges
                            baseTile.moisture = (baseTile.moisture * 0.6) + (overlayTile.moisture * 0.4);
                        }
                    }
                    
                    // Convert overlay map to format expected by BiomeStaticPlacer
                    const overlayForPlacer = hybridOverlayMap.map(row => row.map(tile => ({
                        tileId: typeof tile.id === 'string'
                            ? tile.id
                            : `0x${(tile.id ?? 0).toString(16).toUpperCase().padStart(4, '0')}`,
                        name: `${tile.biome} (hybrid)`,
                        z: tile.z || 0,
                        biome: tile.biome,
                        isWater: tile.biome === 'water',
                        surfaceClass: tile.surfaceClass || tile.biome
                    })));
                    
                    const biomePlacer = new BiomeStaticPlacer();
                    hybridProceduralStatics = biomePlacer.placeStatics(overlayForPlacer, {
                        seed: blendSeed,
                        densityMultiplier: 0.85,
                        enableClustering: true,
                        waterEdgeBonus: true,
                        landTileData
                    });
                    
                    console.log(`[HybridBlend] Overlay produced ${hybridProceduralStatics.length} additional statics`);
                }
                
                // Check if we're missing statics
                console.log(`[loadRealUOMap] ‚ö†Ô∏è  MISSING: Static objects (trees, rocks, buildings) are NOT loaded yet.`);
                console.log(`[loadRealUOMap] To load statics, we need statics0.mul and staidx0.mul files.`);
                console.log(`[loadRealUOMap] See MAP_ACCURACY_CHECKLIST.md for full list of missing features.`);
                
                updateProgress(75, 'üîÑ Preparing WebGL 3D renderer...');
                console.log('[loadRealUOMap] Map converted, using WebGL 3D renderer...');
                
                // Use WebGL renderer for proper 3D stretched tiles (like ClassicUO)
                const originalCanvas = document.getElementById('canvas');
                const canvasContainer = document.getElementById('canvasContainer');
                
                // Enable scrolling for WebGL canvas (it's larger than the container)
                canvasContainer.style.overflow = 'auto';
                canvasContainer.style.cursor = 'grab';
                
                // Create or get WebGL canvas
                if (!webglCanvas) {
                    webglCanvas = document.createElement('canvas');
                    webglCanvas.id = 'webgl-canvas'; // Match the ID the drag handler checks for
                    webglCanvas.style.display = 'block';
                    webglCanvas.style.border = '1px solid #444';
                    webglCanvas.style.imageRendering = 'pixelated';
                    webglCanvas.style.imageRendering = '-moz-crisp-edges';
                    webglCanvas.style.imageRendering = 'crisp-edges';
                    canvasContainer.appendChild(webglCanvas);
                }
                
                // Hide 2D canvas, show WebGL canvas
                originalCanvas.style.display = 'none';
                webglCanvas.style.display = 'block';
                
                // Ensure canvas can be scrolled (don't constrain its size)
                webglCanvas.style.maxWidth = 'none';
                webglCanvas.style.maxHeight = 'none';
                
                // Initialize WebGL renderer
                if (!webglRenderer) {
                    try {
                        webglRenderer = new WebGLTerrainRenderer(webglCanvas);
                    } catch (e) {
                        document.getElementById('status').textContent = `‚ùå WebGL not supported: ${e.message}`;
                        console.error('WebGL init error:', e);
                        originalCanvas.style.display = 'block';
                        return;
                    }
                }
                
                // Generate corner heights from UO map Z-values
                updateProgress(80, 'üîÑ Calculating 3D corner heights...');
                // In UO, each tile has a Z-value, and corners are shared between tiles
                // Corner height = average of the 4 tiles that share that corner
                const cornerHeights = [];
                for (let cy = 0; cy <= regionHeight; cy++) {
                    cornerHeights[cy] = [];
                    for (let cx = 0; cx <= regionWidth; cx++) {
                        // Get the 4 tiles that share this corner
                        // Corner [cy][cx] is shared by tiles:
                        // - [cy-1][cx-1] (top-left)
                        // - [cy-1][cx]   (top-right)
                        // - [cy][cx-1]   (bottom-left)
                        // - [cy][cx]     (bottom-right)
                        const tiles = [];
                        if (cy > 0 && cx > 0) tiles.push(map[cy-1][cx-1].z);
                        if (cy > 0 && cx < regionWidth) tiles.push(map[cy-1][cx].z);
                        if (cy < regionHeight && cx > 0) tiles.push(map[cy][cx-1].z);
                        if (cy < regionHeight && cx < regionWidth) tiles.push(map[cy][cx].z);
                        
                        // Average the Z-values, normalize to 0-50 range for rendering
                        // UO Z-values are typically 0-127, but we'll normalize to 0-50
                        const avgZ = tiles.length > 0 
                            ? tiles.reduce((sum, z) => sum + z, 0) / tiles.length 
                            : 0;
                        
                        // Normalize: UO Z is typically 0-127, map to 0-50 for rendering
                        // Also handle negative Z (caves) by clamping to 0
                        const normalizedZ = Math.max(0, Math.min(50, Math.round((avgZ - minZ) / (maxZ - minZ || 1) * 50)));
                        cornerHeights[cy][cx] = normalizedZ;
                    }
                }
                
                console.log(`[loadRealUOMap] Generated corner heights: min=${minZ}, max=${maxZ}`);
                
                // Preload all tile textures
                updateProgress(85, 'üîÑ Collecting unique tile IDs...');
                const uniqueTileIds = new Set();
                for (let y = 0; y < regionHeight; y++) {
                    for (let x = 0; x < regionWidth; x++) {
                        uniqueTileIds.add(map[y][x].id);
                    }
                }
                
                // Load each unique tile as a WebGL texture
                const totalTextures = uniqueTileIds.size;
                console.log(`[loadRealUOMap] Loading ${totalTextures} unique tile textures...`);
                let loadedCount = 0;
                let textureIndex = 0;
                for (const tileId of uniqueTileIds) {
                    textureIndex++;
                    if (textureIndex % 10 === 0 || textureIndex === totalTextures) {
                        const percent = 85 + Math.round((textureIndex / totalTextures) * 10);
                        updateProgress(percent, `üîÑ Loading textures... ${textureIndex}/${totalTextures} (${Math.round(textureIndex/totalTextures*100)}%)`);
                    }
                    const processedImage = await loadTileImage(tileId);
                    if (processedImage) {
                        webglRenderer.loadTexture(tileId, processedImage);
                        loadedCount++;
                    } else {
                        console.warn(`[loadRealUOMap] Failed to load tile: ${tileId}`);
                    }
                }
                
                updateProgress(95, `‚úÖ Loaded ${loadedCount}/${totalTextures} textures`);
                console.log(`[loadRealUOMap] Loaded ${loadedCount}/${totalTextures} textures`);
                
                // Try to load art for static objects (real + optional hybrid overlay)
                let artTextures = {};
                const staticsForArt = blendProcedural
                    ? statics.concat(hybridProceduralStatics)
                    : statics;

                if (staticsForArt.length > 0) {
                    updateProgress(96, 'üîÑ Loading static object graphics...');
                    try {
                        if (!itemLoader) {
                            itemLoader = new UOItemLoader();
                        }

                        let artFromUOPAvailable = false;
                        if (ENABLE_UOP_STATIC_ART) {
                            if (!artLoader || !artLoader.isUOP) {
                                artLoader = new UOArtLoader();
                                const artLoaded = await artLoader.loadFromUOP('./assets/mul/artLegacyMUL.uop');
                                if (artLoaded) {
                                    artFromUOPAvailable = true;
                                    console.log('[loadRealUOMap] ‚úÖ Art UOP loaded');
                                } else {
                                    console.warn('[loadRealUOMap] ‚ö†Ô∏è Could not load artLegacyMUL.uop');
                                    console.warn('[loadRealUOMap] Run copy_art.bat to copy the file');
                                }
                            } else if (artLoader.isUOP) {
                                artFromUOPAvailable = true;
                            }
                        } else {
                            if (artLoader) {
                                console.log('[loadRealUOMap] UOP art loader initialized earlier but disabled for statics (using BMP exports)');
                            } else {
                                console.log('[loadRealUOMap] UOP static art disabled (ENABLE_UOP_STATIC_ART=false) - using exported BMP sprites');
                            }
                        }
                        
                        const uniqueGraphics = [...new Set(staticsForArt.map(s => s.graphic))];
                        console.log(`[loadRealUOMap] Loading ${uniqueGraphics.length} unique static graphics...`);
                        console.log(`[loadRealUOMap] First 5 graphic IDs:`, uniqueGraphics.slice(0, 5));
                        
                        let loadedArt = 0;
                        let bmpHits = 0;
                        let uopHits = 0;
                        for (let i = 0; i < uniqueGraphics.length; i++) {
                            const graphic = uniqueGraphics[i];
                            if (i % 25 === 0 || i === uniqueGraphics.length - 1) {
                                const artProgress = 96 + Math.min(2, Math.round(((i + 1) / uniqueGraphics.length) * 2));
                                updateProgress(artProgress, `üîÑ Static art ${i + 1}/${uniqueGraphics.length}`);
                            }

                            let texture = null;

                            if (itemLoader) {
                                try {
                                    texture = await itemLoader.getTexture(graphic);
                                    if (texture) bmpHits++;
                                } catch (err) {
                                    // BMP fallback may not have every asset; ignore per-id failures
                                }
                            }
                            
                            if (!texture && artFromUOPAvailable) {
                                try {
                                    texture = await artLoader.getStaticTexture(graphic);
                                    if (texture) uopHits++;
                                } catch (err) {
                                    console.warn(`[loadRealUOMap] UOP art load failed for 0x${graphic.toString(16).toUpperCase()}: ${err.message}`);
                                }
                            }

                            if (texture) {
                                artTextures[graphic] = texture;
                                loadedArt++;
                            }
                        }
                        console.log(`[loadRealUOMap] Loaded ${loadedArt}/${uniqueGraphics.length} static art textures (BMP hits: ${bmpHits}${artFromUOPAvailable ? `, UOP hits: ${uopHits}` : ''})`);
                    } catch (e) {
                        console.warn('[loadRealUOMap] Art loading failed:', e.message);
                    }
                }
                
                // Convert statics to region-relative coordinates
                const regionStatics = statics.map(s => ({
                    ...s,
                    relX: s.worldX - regionX,
                    relY: s.worldY - regionY,
                    artTexture: artTextures[s.graphic] || null
                }));

                let hybridRegionStatics = [];
                let scenarioSpawnPoint = null;
                if (blendProcedural && hybridProceduralStatics.length > 0) {
                    hybridRegionStatics = hybridProceduralStatics
                        .map(s => {
                            const relX = s.x;
                            const relY = s.y;
                            const baseTile = map[relY]?.[relX];
                            if (!baseTile) return null;
                            
                            const baseBiome = (baseTile.biome || '').toLowerCase();
                            const isWater = baseBiome.includes('water') || baseTile.isWater;
                            const isCaveOrVoid = baseBiome.includes('cave') || baseBiome.includes('void');
                            const isRock = baseBiome === 'rock';
                            const isSwamp = baseBiome === 'swamp';  // Gray marshy areas
                            
                            // Also check the original tile ID directly for terrain that shouldn't have vegetation
                            const origId = baseTile.originalTileId || 0;
                            
                            // Void tiles
                            const isVoidTileId = origId === 0x0001 || origId === 0x0002 || 
                                                 (origId >= 0x3FF8 && origId <= 0x3FFB);
                            
                            // Cave floor tiles
                            const isCaveTileId = (origId >= 0x054C && origId <= 0x0553);
                            
                            // ALL rock/cliff/mountain tile ranges
                            const isRockTileId = (origId >= 0x00C4 && origId <= 0x00DB) || // Cliff transitions
                                                 (origId >= 0x00DC && origId <= 0x00FF) || // Rough rock
                                                 (origId >= 0x0071 && origId <= 0x008F) || // Rock transitions
                                                 (origId >= 0x00F0 && origId <= 0x00F3) || // Mountain rock
                                                 (origId >= 0x01D3 && origId <= 0x01DA);   // More mountain rock
                            
                            // Water tile IDs (direct check in case biome wasn't set)
                            const isWaterTileId = (origId >= 0x00A8 && origId <= 0x00AB) || // Main water
                                                  (origId >= 0x0160 && origId <= 0x017F);   // Additional water
                            
                            // Swamp tile IDs (gray marshy areas - no trees)
                            const isSwampTileId = (origId >= 0x00AC && origId <= 0x00C3);
                            
                            const isInvalidTerrain = isWater || isCaveOrVoid || isRock || isSwamp ||
                                                     isVoidTileId || isCaveTileId || isRockTileId || isWaterTileId || isSwampTileId;
                            if (isInvalidTerrain) {
                                return null; // Skip hybrid statics on water, caves, void, rocks, or cliffs
                            }
                            
                            const zFromMap = baseTile.z ?? s.z ?? 0;
                            return {
                                ...s,
                                relX,
                                relY,
                                worldX: regionX + relX,
                                worldY: regionY + relY,
                                z: zFromMap,
                                artTexture: artTextures[s.graphic] || null,
                                isProceduralHybrid: true
                            };
                        })
                        .filter(Boolean);
                }

                const combinedRegionStatics = regionStatics.concat(hybridRegionStatics);
                if (scenarioPreset && scenarioPreset.key === 'mountain_mining') {
                    scenarioSpawnPoint = applyMountainMiningScenario(
                        map,
                        combinedRegionStatics,
                        regionX,
                        regionY,
                        artTextures
                    );
                }
                
                // Store statics globally for collision detection
                currentStatics = combinedRegionStatics;
                currentCornerHeights = cornerHeights;
                map.__isUORegion = true;
                currentRegionOrigin = { x: regionX, y: regionY };
                currentRegionSize = { width: regionWidth, height: regionHeight };
                currentRegionBlendProcedural = blendProcedural;
                
                // Render with WebGL (proper 3D stretched tiles + statics)
                updateProgress(98, 'üîÑ Rendering 3D terrain with WebGL...');
                webglRenderer.render(map, cornerHeights, null, combinedRegionStatics);
                
                // Log statics info
                if (combinedRegionStatics.length > 0) {
                    const uniqueGraphics = new Set(combinedRegionStatics.map(s => s.hexId));
                    const artCount = Object.keys(artTextures).length;
                    const renderMode = artCount > 0 ? `${artCount} with graphics` : 'placeholder squares';
                    const hybridNote = hybridRegionStatics.length > 0 ? ` | Hybrid +${hybridRegionStatics.length}` : '';
                    updateProgress(100, `‚úÖ Map rendered! ${combinedRegionStatics.length} statics (${renderMode}${hybridNote})`);
                    statusEl.style.color = '#4CAF50';
                    console.log(`[loadRealUOMap] ‚úÖ ${combinedRegionStatics.length} static objects loaded (${uniqueGraphics.size} unique types)`);
                    console.log(`[loadRealUOMap] Static rendering: ${artCount > 0 ? `${artCount} art textures loaded` : 'Placeholder mode (colored squares)'}`);
                    if (hybridRegionStatics.length > 0) {
                        console.log(`[HybridBlend] Added ${hybridRegionStatics.length} procedural statics to real region`);
                    }
                } else {
                    updateProgress(100, `‚úÖ Map rendered! (No static objects in this region)`);
                    statusEl.style.color = '#4CAF50';
                }
                
                if (!pendingWorldPosition && scenarioSpawnPoint) {
                    pendingWorldPosition = {
                        worldX: regionX + clampValue(scenarioSpawnPoint.x, 1, regionWidth - 2),
                        worldY: regionY + clampValue(scenarioSpawnPoint.y, 1, regionHeight - 2),
                        direction: 'n'
                    };
                }
                updateCurrentMapReference(map);
                
                if (pendingWorldPosition) {
                    const { worldX, worldY, direction } = pendingWorldPosition;
                    const snappedWorldX = Math.round(worldX);
                    const snappedWorldY = Math.round(worldY);
                    const localX = clampValue(snappedWorldX - regionX, 1, regionWidth - 2);
                    const localY = clampValue(snappedWorldY - regionY, 1, regionHeight - 2);
                    if (playerCharacter) {
                        playerCharacter.x = localX;
                        playerCharacter.y = localY;
                        playerCharacter.z = map[localY]?.[localX]?.z || 0;
                        movementStartX = localX;
                        movementStartY = localY;
                        movementStartZ = playerCharacter.z;
                        nextTileX = null;
                        nextTileY = null;
                        movementProgress = 0;
                        isMoving = false;
                        rightMouseHeld = false;
                        stopAfterStep = false;
                        const dirSprites = characterSprites[playerCharacter.direction];
                        if (dirSprites?.idle) {
                            playerCharacter.sprite = dirSprites.idle;
                        }
                        console.log(`[AutoRegion] Player moved to new region (${direction}) at local (${localX}, ${localY})`);
                    }
                    pendingWorldPosition = null;
                } else {
                    pendingWorldPosition = null;
                }
                
                // Auto-center and auto-zoom the map
                setTimeout(() => {
                    fitToView();
                }, 100);
                
                // Final status - show coordinates prominently
                const totalStaticsForStatus = currentStatics ? currentStatics.length : staticsCount;
                const hybridSuffix = blendProcedural && hybridRegionStatics.length > 0
                    ? ` (Hybrid +${hybridRegionStatics.length})`
                    : '';
                const scenarioObjectiveNote = scenarioPreset?.objective ? ` | üõ°Ô∏è ${scenarioPreset.objective}` : '';
                const finalStatus = `‚úÖ LOADED: X=${regionX}, Y=${regionY} | Size: ${regionWidth}√ó${regionHeight} | Z: ${minZ} to ${maxZ} | Statics: ${totalStaticsForStatus}${hybridSuffix}${scenarioObjectiveNote}`;
                updateProgress(100, finalStatus);
                statusEl.style.color = '#4CAF50';
                statusEl.style.fontSize = '14px';
                statusEl.style.fontWeight = 'bold';
                
            } catch (error) {
                console.error('[loadRealUOMap] Error:', error);
                document.getElementById('status').textContent = `‚ùå Error: ${error.message}`;
                alert(`Error loading map: ${error.message}\n\nCheck browser console (F12) for details.`);
                pendingWorldPosition = null;
                currentMapIsUORegion = false;
            } finally {
                mapLoadInProgress = false;
            }
        };

        window.loadHybridRegion = function() {
            const statusEl = document.getElementById('status');
            if (statusEl) {
                statusEl.textContent = 'üîÑ Hybrid: mixing real Britannia data with p