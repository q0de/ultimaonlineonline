"""
Analyze tiles to determine isometric edge properties.
In UO Isometric view (44x44 diamond):
- Top-Left Edge: From (0, 22) to (22, 0)
- Top-Right Edge: From (22, 0) to (43, 22)
- Bottom-Right Edge: From (43, 22) to (22, 43)
- Bottom-Left Edge: From (22, 43) to (0, 22)

This script checks these specific diagonal lines to see if they contain:
1. The main tile material (e.g. grass)
2. Empty space / Black (indicating a water edge or cliff drop-off)
3. A different material (indicating a transition, e.g., grass-to-dirt)
"""

from PIL import Image
import os
import glob

def get_pixel_safe(img, x, y):
    width, height = img.size
    if 0 <= x < width and 0 <= y < height:
        return img.getpixel((x, y))
    return (0, 0, 0)

def is_black(r, g, b):
    return r < 15 and g < 15 and b < 15

def is_green(r, g, b):
    return g > r * 1.1 and g > b * 1.1 and g > 30

def is_sand(r, g, b):
    return r > 60 and g > 50 and r > b * 1.2 and not is_green(r, g, b)

def is_grey_rock(r, g, b):
    # Greyish: R, G, B are close to each other
    avg = (r + g + b) / 3
    return abs(r - avg) < 15 and abs(g - avg) < 15 and abs(b - avg) < 15 and avg > 40

def analyze_isometric_edges(image_path):
    try:
        img = Image.open(image_path)
        img = img.convert('RGB')
        width, height = img.size
        cx, cy = width // 2, height // 2
        
        # Define sample points along the 4 edges (inset slightly to avoid anti-aliasing artifacts)
        # We scan a few pixels perpendicular to the edge to check content
        
        edges = {
            'TL': [], # Top-Left (North-West visual)
            'TR': [], # Top-Right (North-East visual)
            'BR': [], # Bottom-Right (South-East visual)
            'BL': []  # Bottom-Left (South-West visual)
        }
        
        # Scan edges
        # Top-Left: x from 2 to 20, y decreases as x increases (slope -1? No, slope -1 in cartesian is Up-Left?)
        # Line from (0, 22) to (22, 0) -> y = 22 - x
        for i in range(5, 18):
            # Top-Left Edge area
            x = i
            y = 22 - i
            edges['TL'].append(get_pixel_safe(img, x + 2, y + 2)) # Sample slightly inside
            
            # Top-Right Edge area
            # Line from (22, 0) to (44, 22) -> y = x - 22
            x = 22 + i
            y = i
            edges['TR'].append(get_pixel_safe(img, x - 2, y + 2))
            
            # Bottom-Right Edge area
            # Line from (44, 22) to (22, 44) -> y = 22 + (44 - x) ?? 
            # Center (22,22). BR goes to (44,44) in index? No 44,22 to 22,44.
            # x goes 44->22. y goes 22->44.
            x = 44 - i
            y = 22 + i
            edges['BR'].append(get_pixel_safe(img, x - 2, y - 2))
            
            # Bottom-Left Edge area
            # Line from (22, 44) to (0, 22).
            # x goes 22->0. y goes 44->22.
            x = 22 - i
            y = 44 - i 
            edges['BL'].append(get_pixel_safe(img, x + 2, y - 2))

        results = {}
        for edge_name, pixels in edges.items():
            content_count = 0
            black_count = 0
            green_count = 0
            sand_count = 0
            rock_count = 0
            
            for r, g, b in pixels:
                if is_black(r, g, b):
                    black_count += 1
                else:
                    content_count += 1
                    if is_green(r, g, b): green_count += 1
                    elif is_sand(r, g, b): sand_count += 1
                    elif is_grey_rock(r, g, b): rock_count += 1
            
            total = len(pixels)
            if total == 0: total = 1
            
            # Classify the edge
            if black_count > total * 0.6:
                status = 'EMPTY' # Water/Cliff dropoff
            elif green_count > content_count * 0.6:
                status = 'GRASS'
            elif sand_count > content_count * 0.6:
                status = 'SAND'
            elif rock_count > content_count * 0.6:
                status = 'ROCK'
            else:
                status = 'MIXED'
                
            results[edge_name] = status
            
        return results

    except Exception as e:
        return {'error': str(e)}

def generate_js_mapping(filename, variable_name, grouped_data, description, helper_prefix):
    with open(filename, 'w') as f:
        f.write(f"// {description}\n")
        f.write("// Generated by analyze_isometric_edges.py\n")
        f.write("// Bitmask: 1=TR (N), 2=BR (E), 4=BL (S), 8=TL (W)\n\n")
        f.write(f"export const {variable_name} = {{\n")
        
        # Sort by bitmask key
        keys = sorted(grouped_data.keys())
        for bitmask in keys:
            # Group by transition type
            type_groups = grouped_data[bitmask]
            
            f.write(f"    {bitmask}: {{\n")
            for trans_type, tiles in type_groups.items():
                tile_strs = [f"'{t}'" for t in tiles]
                f.write(f"        '{trans_type}': [{', '.join(tile_strs)}],\n")
            f.write(f"    }},\n")
            
        f.write("};\n\n")
        
        # Add Helper Function
        f.write(f"export function get{helper_prefix}TileForBitmask(bitmask, transitionType = 'generic', rng = Math.random) {{\n")
        
        # Add Fallback Logic
        f.write(f"    // Try exact match first\n")
        f.write(f"    let effectiveBitmask = bitmask;\n")
        f.write(f"    if (!{variable_name}[effectiveBitmask]) {{\n")
        f.write(f"        // Fallback: Find best subset match (key that is subset of bitmask with most bits)\n")
        f.write(f"        let bestMatch = 0;\n")
        f.write(f"        let maxBits = -1;\n")
        f.write(f"        for (const keyStr of Object.keys({variable_name})) {{\n")
        f.write(f"            const key = parseInt(keyStr);\n")
        f.write(f"            if (key > 0 && (key & bitmask) === key) {{\n")
        f.write(f"                let bits = 0; let n = key; while(n) {{ bits++; n &= n-1; }}\n")
        f.write(f"                if (bits > maxBits) {{ maxBits = bits; bestMatch = key; }}\n")
        f.write(f"            }}\n")
        f.write(f"        }}\n")
        f.write(f"        if (bestMatch > 0) effectiveBitmask = bestMatch;\n")
        f.write(f"    }}\n\n")

        f.write(f"    const bitmaskGroup = {variable_name}[effectiveBitmask];\n")
        f.write("    if (!bitmaskGroup) return null;\n\n")
        f.write("    // Try specific transition type first, then fallback to generic/mixed\n")
        f.write("    let tiles = bitmaskGroup[transitionType];\n")
        f.write("    if (!tiles || tiles.length === 0) tiles = bitmaskGroup['MIXED'];\n")
        f.write("    if (!tiles || tiles.length === 0) tiles = bitmaskGroup['GRASS']; // Final fallback\n")
        f.write("    if (!tiles || tiles.length === 0) tiles = bitmaskGroup['SAND'];\n\n")
        
        f.write("    if (tiles && tiles.length > 0) {\n")
        f.write("        return tiles[Math.floor(rng() * tiles.length)];\n")
        f.write("    }\n")
        f.write("    return null;\n")
        f.write("}\n\n")
        
        # Add Bitmask Calculation Function (Unchanged logic)
        f.write(f"export function calculate{helper_prefix}Bitmask(map, x, y, width, height, targetBiome, invert = false) {{\n")
        f.write("    let bitmask = 0;\n")
        f.write("    // Isometric Neighbor Mapping:\n")
        f.write("    // y-1 (North in array) -> Top-Right Edge (Bit 1)\n")
        f.write("    // x+1 (East in array)  -> Bottom-Right Edge (Bit 2)\n")
        f.write("    // y+1 (South in array) -> Bottom-Left Edge (Bit 4)\n")
        f.write("    // x-1 (West in array)  -> Top-Left Edge (Bit 8)\n\n")
        
        f.write("    // Top-Right Edge (North Neighbor y-1)\n")
        f.write("    if (y > 0) {\n")
        f.write("        const match = map[y - 1][x].biome === targetBiome;\n")
        f.write("        if (invert ? !match : match) bitmask |= 1;\n")
        f.write("    } else if (invert) {\n")
        f.write("        // If invert (looking for NOT target), and we are at map edge...\n")
        f.write("        // Assume map edge is same as target (don't draw border)? Or different?\n")
        f.write("        // Usually assume infinite terrain of same type -> no border.\n")
        f.write("    }\n\n")
        
        f.write("    // Bottom-Right Edge (East Neighbor x+1)\n")
        f.write("    if (x < width - 1) {\n")
        f.write("        const match = map[y][x + 1].biome === targetBiome;\n")
        f.write("        if (invert ? !match : match) bitmask |= 2;\n")
        f.write("    }\n\n")
        
        f.write("    // Bottom-Left Edge (South Neighbor y+1)\n")
        f.write("    if (y < height - 1) {\n")
        f.write("        const match = map[y + 1][x].biome === targetBiome;\n")
        f.write("        if (invert ? !match : match) bitmask |= 4;\n")
        f.write("    }\n\n")
        
        f.write("    // Top-Left Edge (West Neighbor x-1)\n")
        f.write("    if (x > 0) {\n")
        f.write("        const match = map[y][x - 1].biome === targetBiome;\n")
        f.write("        if (invert ? !match : match) bitmask |= 8;\n")
        f.write("    }\n\n")
        
        f.write("    return bitmask;\n")
        f.write("}\n")

    print(f"Generated {filename}")

def main():
    print("Scanning and Generating Mappings...")
    
    # 1. Embankment Analysis
    print("Analyzing Embankments (Water/Cliff edges)...")
    embank_ids = []
    for i in range(0x098C, 0x09BF + 1):
        embank_ids.append(f"0x{i:04X}")
        
    embank_groups = {}
    
    for tile_id in embank_ids:
        path = f"assets/tiles/{tile_id}.bmp"
        if os.path.exists(path):
            res = analyze_isometric_edges(path)
            if 'error' not in res:
                bitmask = 0
                primary_transition = 'MIXED' 
                
                # Determine edges and their material
                edges = [
                    ('TR', 1, res['TR']),
                    ('BR', 2, res['BR']),
                    ('BL', 4, res['BL']),
                    ('TL', 8, res['TL'])
                ]
                
                current_transition_materials = []
                
                for edge_name, bit, material in edges:
                    if material != 'GRASS':
                        bitmask |= bit
                        if material not in ['GRASS', 'MIXED', 'EMPTY']:
                            current_transition_materials.append(material)
                
                if len(current_transition_materials) > 0:
                    # Use the most common material, or just the first one
                    primary_transition = current_transition_materials[0]
                
                if bitmask not in embank_groups:
                    embank_groups[bitmask] = {}
                
                if primary_transition not in embank_groups[bitmask]:
                    embank_groups[bitmask][primary_transition] = []
                    
                embank_groups[bitmask][primary_transition].append(tile_id)

    generate_js_mapping('js/data/embankTileMapping.js', 'EMBANK_TILE_MAPPING', embank_groups, "Embankment (Coast/Cliff) Tiles", "Embank")

    # 2. Rock Analysis
    print("Analyzing Rocks...")
    rock_ids = []
    with open('assets/tiles/LandData.csv', 'r') as f:
        for line in f:
            parts = line.strip().split(';')
            if len(parts) > 2:
                name = parts[1].lower()
                if 'rock' in name:
                    rock_ids.append(parts[0])
    
    rock_groups = {}
    for tile_id in rock_ids:
        path = f"assets/tiles/{tile_id}.bmp"
        if os.path.exists(path):
            res = analyze_isometric_edges(path)
            if 'error' not in res:
                bitmask = 0
                primary_transition = 'MIXED'
                
                edges = [
                    ('TR', 1, res['TR']),
                    ('BR', 2, res['BR']),
                    ('BL', 4, res['BL']),
                    ('TL', 8, res['TL'])
                ]
                
                current_transition_materials = []
                
                for edge_name, bit, material in edges:
                    if material != 'ROCK':
                        bitmask |= bit
                        if material not in ['ROCK', 'MIXED', 'EMPTY']:
                            current_transition_materials.append(material)
                
                if len(current_transition_materials) > 0:
                    primary_transition = current_transition_materials[0]
                
                if bitmask not in rock_groups:
                    rock_groups[bitmask] = {}
                
                if primary_transition not in rock_groups[bitmask]:
                    rock_groups[bitmask][primary_transition] = []
                    
                rock_groups[bitmask][primary_transition].append(tile_id)
                
    generate_js_mapping('js/data/rockTileMapping.js', 'ROCK_TILE_MAPPING', rock_groups, "Rock Transition Tiles", "Rock")

    # 3. Slope/Cliff Analysis (Sand/Dirt Slopes from User Screenshots)
    print("Analyzing Slopes (0x0027, 0x0044, 0x01B9 ranges)...")
    slope_ids = []
    # Range 1: 0x001A - 0x0026 (Sand/Grass Slopes)
    for i in range(0x001A, 0x0027):
        slope_ids.append(f"0x{i:04X}")
    # Range 2: 0x0027 - 0x0032 (Sand/Grass Slopes)
    for i in range(0x0027, 0x0033):
        slope_ids.append(f"0x{i:04X}")
    # Range 3: 0x0044 - 0x004B (Sand/Grass Slopes)
    for i in range(0x0044, 0x004C):
        slope_ids.append(f"0x{i:04X}")
    # Range 4: 0x01B9 - 0x01D0 (Sand Ripples/Dunes)
    for i in range(0x01B9, 0x01D1):
        slope_ids.append(f"0x{i:04X}")
    # Range 5: 0x01C0 - 0x01C9 (More Sand Ripples) - Covered by range 4
        
    slope_groups = {}
    for tile_id in slope_ids:
        path = f"assets/tiles/{tile_id}.bmp"
        if os.path.exists(path):
            res = analyze_isometric_edges(path)
            if 'error' not in res:
                bitmask = 0
                primary_transition = 'MIXED'
                
                # Determine edges
                edges = [
                    ('TR', 1, res['TR']),
                    ('BR', 2, res['BR']),
                    ('BL', 4, res['BL']),
                    ('TL', 8, res['TL'])
                ]
                
                current_transition_materials = []
                for edge_name, bit, material in edges:
                    # For slopes, we care about "Not Sand" (Grass edge) or "Not Grass" (Sand edge)?
                    # Looking at screenshot: 0x0027 has Grass on TL/TR? Sand in middle.
                    # It seems to be a "Sand Trough" or "Grass Ridge".
                    # Let's assume Grass is the "High" ground and Sand is "Low" or vice versa.
                    # Let's map based on "Grass" presence.
                    # INCLUDE 'MIXED' to capture the slope gradient
                    if material == 'GRASS' or material == 'MIXED':
                        bitmask |= bit
                        
                # Group
                if bitmask not in slope_groups:
                    slope_groups[bitmask] = {}
                
                if 'GRASS' not in slope_groups[bitmask]:
                    slope_groups[bitmask]['GRASS'] = []
                    
                slope_groups[bitmask]['GRASS'].append(tile_id)
                
    generate_js_mapping('js/data/slopeTileMapping.js', 'SLOPE_TILE_MAPPING', slope_groups, "Slope/Cliff Tiles (Grass/Sand)", "Slope")

    # 4. Dirt Transition Analysis (Dirt with Grass Edges)
    print("Analyzing Dirt Transitions (0x007D range)...")
    dirt_ids = []
    # Range: 0x007D - 0x008C (Dirt Transition Tiles?)
    for i in range(0x007D, 0x008D):
        dirt_ids.append(f"0x{i:04X}")
        
    dirt_groups = {}
    for tile_id in dirt_ids:
        path = f"assets/tiles/{tile_id}.bmp"
        if os.path.exists(path):
            res = analyze_isometric_edges(path)
            if 'error' not in res:
                bitmask = 0
                
                # Determine edges
                edges = [
                    ('TR', 1, res['TR']),
                    ('BR', 2, res['BR']),
                    ('BL', 4, res['BL']),
                    ('TL', 8, res['TL'])
                ]
                
                # For Dirt Transitions: We are looking for GRASS edges on a Dirt tile
                for edge_name, bit, material in edges:
                    if material == 'GRASS' or material == 'MIXED':
                        bitmask |= bit
                        
                if bitmask not in dirt_groups:
                    dirt_groups[bitmask] = {}
                
                if 'GRASS' not in dirt_groups[bitmask]:
                    dirt_groups[bitmask]['GRASS'] = []
                    
                dirt_groups[bitmask]['GRASS'].append(tile_id)
                
    generate_js_mapping('js/data/dirtTileMapping.js', 'DIRT_TILE_MAPPING', dirt_groups, "Dirt Transition Tiles", "Dirt")

if __name__ == '__main__':
    main()
