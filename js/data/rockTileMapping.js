// Rock Transition Tiles
// Generated by analyze_isometric_edges.py
// Bitmask: 1=TR (N), 2=BR (E), 4=BL (S), 8=TL (W)

export const ROCK_TILE_MAPPING = {
    0: {
        'MIXED': ['0x00E5', '0x00E7', '0x0110', '0x0111', '0x0112', '0x0113', '0x01D3', '0x01D7', '0x0227', '0x0228', '0x0229', '0x022A', '0x022C', '0x022D', '0x022E', '0x022F', '0x0230', '0x06DA', '0x06DB', '0x06DC', '0x06DD', '0x06ED', '0x06F0', '0x06FB', '0x06FC', '0x06FD', '0x06FE', '0x071D', '0x071F', '0x0720', '0x073B', '0x073D', '0x073E', '0x0749', '0x074A', '0x074B', '0x074C', '0x074D', '0x074E', '0x074F', '0x0750', '0x0759', '0x075A', '0x075B', '0x075C', '0x09F6', '0x09F7', '0x34C8', '0x34C9', '0x34CA', '0x34CB', '0x358E', '0x358F', '0x3590', '0x3591', '0x3592', '0x3593', '0x3594', '0x3595'],
    },
    1: {
        'MIXED': ['0x0222', '0x09F4'],
    },
    2: {
        'SAND': ['0x01D5'],
        'MIXED': ['0x01D9', '0x0220', '0x06F1'],
    },
    3: {
        'MIXED': ['0x00F7', '0x0106', '0x0223', '0x0238', '0x06EB', '0x072B', '0x09EF', '0x34C6', '0x34CF', '0x34F8'],
        'SAND': ['0x0125', '0x34BF'],
    },
    4: {
        'MIXED': ['0x00E4', '0x021F', '0x06EE', '0x06F2', '0x071E', '0x073C'],
    },
    6: {
        'SAND': ['0x00F4', '0x0122', '0x0714', '0x34C7', '0x34CC', '0x34DE', '0x34DF', '0x34EB'],
        'MIXED': ['0x0107', '0x01D4', '0x0224', '0x0731', '0x34BC', '0x34EA', '0x34FE', '0x34FF'],
        'GRASS': ['0x0235', '0x06D0', '0x06D1', '0x0732'],
    },
    7: {
        'MIXED': ['0x01DA', '0x072D', '0x09ED', '0x34E6', '0x34FA'],
        'SAND': ['0x070F', '0x0713'],
    },
    8: {
        'MIXED': ['0x0221', '0x06EC'],
    },
    9: {
        'MIXED': ['0x00E6', '0x0105', '0x01D8', '0x0226', '0x0237', '0x06EF', '0x072F', '0x0730', '0x34DD', '0x34FC', '0x34FD'],
        'SAND': ['0x00F6', '0x0124', '0x0711', '0x0712', '0x34BE', '0x34C5', '0x34CE', '0x34DC', '0x34E8', '0x34E9'],
        'GRASS': ['0x06CE', '0x06CF'],
    },
    11: {
        'SAND': ['0x070D', '0x34E4'],
    },
    12: {
        'MIXED': ['0x00F5', '0x0104', '0x01D6', '0x0225', '0x0236', '0x0710', '0x072C', '0x09F5', '0x34BD', '0x34C4', '0x34E5', '0x34F9', '0x34FB'],
        'SAND': ['0x0123', '0x070E', '0x34CD', '0x34DB', '0x34E7'],
        'GRASS': ['0x06CD', '0x072E'],
    },
    13: {
        'MIXED': ['0x09EC'],
    },
    14: {
        'MIXED': ['0x09EE', '0x09FA'],
    },
    15: {
        'MIXED': ['0x022B', '0x09F0', '0x09F1', '0x09F2', '0x09F3', '0x09F8', '0x09F9', '0x09FB', '0x09FC', '0x09FD', '0x09FE', '0x09FF', '0x0A00', '0x0A01', '0x0A02', '0x0A03'],
    },
};

export function getRockTileForBitmask(bitmask, transitionType = 'generic', rng = Math.random) {
    // Try exact match first
    let effectiveBitmask = bitmask;
    if (!ROCK_TILE_MAPPING[effectiveBitmask]) {
        // Fallback: Find best subset match (key that is subset of bitmask with most bits)
        let bestMatch = 0;
        let maxBits = -1;
        for (const keyStr of Object.keys(ROCK_TILE_MAPPING)) {
            const key = parseInt(keyStr);
            if (key > 0 && (key & bitmask) === key) {
                let bits = 0; let n = key; while(n) { bits++; n &= n-1; }
                if (bits > maxBits) { maxBits = bits; bestMatch = key; }
            }
        }
        if (bestMatch > 0) effectiveBitmask = bestMatch;
    }

    const bitmaskGroup = ROCK_TILE_MAPPING[effectiveBitmask];
    if (!bitmaskGroup) return null;

    // Try specific transition type first, then fallback to generic/mixed
    let tiles = bitmaskGroup[transitionType];
    if (!tiles || tiles.length === 0) tiles = bitmaskGroup['MIXED'];
    if (!tiles || tiles.length === 0) tiles = bitmaskGroup['GRASS']; // Final fallback
    if (!tiles || tiles.length === 0) tiles = bitmaskGroup['SAND'];

    if (tiles && tiles.length > 0) {
        return tiles[Math.floor(rng() * tiles.length)];
    }
    return null;
}

export function calculateRockBitmask(map, x, y, width, height, targetBiome, invert = false) {
    let bitmask = 0;
    // Isometric Neighbor Mapping:
    // y-1 (North in array) -> Top-Right Edge (Bit 1)
    // x+1 (East in array)  -> Bottom-Right Edge (Bit 2)
    // y+1 (South in array) -> Bottom-Left Edge (Bit 4)
    // x-1 (West in array)  -> Top-Left Edge (Bit 8)

    // Top-Right Edge (North Neighbor y-1)
    if (y > 0) {
        const match = map[y - 1][x].biome === targetBiome;
        if (invert ? !match : match) bitmask |= 1;
    } else if (invert) {
        // If invert (looking for NOT target), and we are at map edge...
        // Assume map edge is same as target (don't draw border)? Or different?
        // Usually assume infinite terrain of same type -> no border.
    }

    // Bottom-Right Edge (East Neighbor x+1)
    if (x < width - 1) {
        const match = map[y][x + 1].biome === targetBiome;
        if (invert ? !match : match) bitmask |= 2;
    }

    // Bottom-Left Edge (South Neighbor y+1)
    if (y < height - 1) {
        const match = map[y + 1][x].biome === targetBiome;
        if (invert ? !match : match) bitmask |= 4;
    }

    // Top-Left Edge (West Neighbor x-1)
    if (x > 0) {
        const match = map[y][x - 1].biome === targetBiome;
        if (invert ? !match : match) bitmask |= 8;
    }

    return bitmask;
}
