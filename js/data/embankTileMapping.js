// Embankment (Coast/Cliff) Tiles
// Generated by analyze_isometric_edges.py
// Bitmask: 1=TR (N), 2=BR (E), 4=BL (S), 8=TL (W)

export const EMBANK_TILE_MAPPING = {
    1: {
        'MIXED': ['0x0998', '0x09B8'],
    },
    2: {
        'MIXED': ['0x099A', '0x099B', '0x09BA'],
    },
    3: {
        'MIXED': ['0x0999'],
    },
    4: {
        'MIXED': ['0x099E', '0x099F', '0x09A0', '0x09A1', '0x09A2', '0x09A3', '0x09A4', '0x09A5', '0x09A6', '0x09A7', '0x09A8', '0x09A9', '0x09AA', '0x09AB'],
    },
    5: {
        'MIXED': ['0x098C', '0x0994', '0x0995', '0x09AD', '0x09B4', '0x09B6'],
    },
    6: {
        'MIXED': ['0x09BE'],
    },
    7: {
        'MIXED': ['0x098D', '0x0997'],
    },
    8: {
        'MIXED': ['0x099C', '0x099D', '0x09BD'],
    },
    9: {
        'MIXED': ['0x09B9'],
    },
    10: {
        'MIXED': ['0x098E', '0x098F', '0x0990', '0x0991', '0x0992', '0x0993', '0x09AF', '0x09B1', '0x09B3'],
    },
    12: {
        'MIXED': ['0x09BC', '0x09BF'],
    },
    13: {
        'MIXED': ['0x0996', '0x09AC', '0x09B5', '0x09B7'],
    },
    14: {
        'MIXED': ['0x09AE', '0x09B0', '0x09B2', '0x09BB'],
    },
};

export function getEmbankTileForBitmask(bitmask, transitionType = 'generic', rng = Math.random) {
    // Try exact match first
    let effectiveBitmask = bitmask;
    if (!EMBANK_TILE_MAPPING[effectiveBitmask]) {
        // Fallback: Find best subset match (key that is subset of bitmask with most bits)
        let bestMatch = 0;
        let maxBits = -1;
        for (const keyStr of Object.keys(EMBANK_TILE_MAPPING)) {
            const key = parseInt(keyStr);
            if (key > 0 && (key & bitmask) === key) {
                let bits = 0; let n = key; while(n) { bits++; n &= n-1; }
                if (bits > maxBits) { maxBits = bits; bestMatch = key; }
            }
        }
        if (bestMatch > 0) effectiveBitmask = bestMatch;
    }

    const bitmaskGroup = EMBANK_TILE_MAPPING[effectiveBitmask];
    if (!bitmaskGroup) return null;

    // Try specific transition type first, then fallback to generic/mixed
    let tiles = bitmaskGroup[transitionType];
    if (!tiles || tiles.length === 0) tiles = bitmaskGroup['MIXED'];
    if (!tiles || tiles.length === 0) tiles = bitmaskGroup['GRASS']; // Final fallback
    if (!tiles || tiles.length === 0) tiles = bitmaskGroup['SAND'];

    if (tiles && tiles.length > 0) {
        return tiles[Math.floor(rng() * tiles.length)];
    }
    return null;
}

export function calculateEmbankBitmask(map, x, y, width, height, targetBiome, invert = false) {
    let bitmask = 0;
    // Isometric Neighbor Mapping:
    // y-1 (North in array) -> Top-Right Edge (Bit 1)
    // x+1 (East in array)  -> Bottom-Right Edge (Bit 2)
    // y+1 (South in array) -> Bottom-Left Edge (Bit 4)
    // x-1 (West in array)  -> Top-Left Edge (Bit 8)

    // Top-Right Edge (North Neighbor y-1)
    if (y > 0) {
        const match = map[y - 1][x].biome === targetBiome;
        if (invert ? !match : match) bitmask |= 1;
    } else if (invert) {
        // If invert (looking for NOT target), and we are at map edge...
        // Assume map edge is same as target (don't draw border)? Or different?
        // Usually assume infinite terrain of same type -> no border.
    }

    // Bottom-Right Edge (East Neighbor x+1)
    if (x < width - 1) {
        const match = map[y][x + 1].biome === targetBiome;
        if (invert ? !match : match) bitmask |= 2;
    }

    // Bottom-Left Edge (South Neighbor y+1)
    if (y < height - 1) {
        const match = map[y + 1][x].biome === targetBiome;
        if (invert ? !match : match) bitmask |= 4;
    }

    // Top-Left Edge (West Neighbor x-1)
    if (x > 0) {
        const match = map[y][x - 1].biome === targetBiome;
        if (invert ? !match : match) bitmask |= 8;
    }

    return bitmask;
}
