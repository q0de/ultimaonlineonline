// Dirt Transition Tiles
// Generated by analyze_isometric_edges.py
// Bitmask: 1=TR (N), 2=BR (E), 4=BL (S), 8=TL (W)

export const DIRT_TILE_MAPPING = {
    15: {
        'GRASS': ['0x007D', '0x007E', '0x007F', '0x0080', '0x0081', '0x0082', '0x0083', '0x0084', '0x0085', '0x0086', '0x0087', '0x0088', '0x0089', '0x008A', '0x008B', '0x008C'],
    },
};

export function getDirtTileForBitmask(bitmask, transitionType = 'generic', rng = Math.random) {
    // Try exact match first
    let effectiveBitmask = bitmask;
    if (!DIRT_TILE_MAPPING[effectiveBitmask]) {
        // Fallback: Find best subset match (key that is subset of bitmask with most bits)
        let bestMatch = 0;
        let maxBits = -1;
        for (const keyStr of Object.keys(DIRT_TILE_MAPPING)) {
            const key = parseInt(keyStr);
            if (key > 0 && (key & bitmask) === key) {
                let bits = 0; let n = key; while(n) { bits++; n &= n-1; }
                if (bits > maxBits) { maxBits = bits; bestMatch = key; }
            }
        }
        if (bestMatch > 0) effectiveBitmask = bestMatch;
    }

    const bitmaskGroup = DIRT_TILE_MAPPING[effectiveBitmask];
    if (!bitmaskGroup) return null;

    // Try specific transition type first, then fallback to generic/mixed
    let tiles = bitmaskGroup[transitionType];
    if (!tiles || tiles.length === 0) tiles = bitmaskGroup['MIXED'];
    if (!tiles || tiles.length === 0) tiles = bitmaskGroup['GRASS']; // Final fallback
    if (!tiles || tiles.length === 0) tiles = bitmaskGroup['SAND'];

    if (tiles && tiles.length > 0) {
        return tiles[Math.floor(rng() * tiles.length)];
    }
    return null;
}

export function calculateDirtBitmask(map, x, y, width, height, targetBiome, invert = false) {
    let bitmask = 0;
    // Isometric Neighbor Mapping:
    // y-1 (North in array) -> Top-Right Edge (Bit 1)
    // x+1 (East in array)  -> Bottom-Right Edge (Bit 2)
    // y+1 (South in array) -> Bottom-Left Edge (Bit 4)
    // x-1 (West in array)  -> Top-Left Edge (Bit 8)

    // Top-Right Edge (North Neighbor y-1)
    if (y > 0) {
        const match = map[y - 1][x].biome === targetBiome;
        if (invert ? !match : match) bitmask |= 1;
    } else if (invert) {
        // If invert (looking for NOT target), and we are at map edge...
        // Assume map edge is same as target (don't draw border)? Or different?
        // Usually assume infinite terrain of same type -> no border.
    }

    // Bottom-Right Edge (East Neighbor x+1)
    if (x < width - 1) {
        const match = map[y][x + 1].biome === targetBiome;
        if (invert ? !match : match) bitmask |= 2;
    }

    // Bottom-Left Edge (South Neighbor y+1)
    if (y < height - 1) {
        const match = map[y + 1][x].biome === targetBiome;
        if (invert ? !match : match) bitmask |= 4;
    }

    // Top-Left Edge (West Neighbor x-1)
    if (x > 0) {
        const match = map[y][x - 1].biome === targetBiome;
        if (invert ? !match : match) bitmask |= 8;
    }

    return bitmask;
}
