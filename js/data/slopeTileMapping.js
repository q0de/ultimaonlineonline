// Slope/Cliff Tiles (Grass/Sand)
// Generated by analyze_isometric_edges.py
// Bitmask: 1=TR (N), 2=BR (E), 4=BL (S), 8=TL (W)

export const SLOPE_TILE_MAPPING = {
    0: {
        'GRASS': ['0x001A', '0x001B', '0x001C', '0x0024', '0x01B9', '0x01BA', '0x01BB', '0x01BC', '0x01BD', '0x01BE', '0x01BF', '0x01C0', '0x01C1', '0x01C2', '0x01C3', '0x01C4', '0x01C5', '0x01C6', '0x01C7', '0x01C8', '0x01C9', '0x01CA', '0x01CB', '0x01CC', '0x01CD', '0x01CE', '0x01CF', '0x01D0'],
    },
    1: {
        'GRASS': ['0x0021', '0x0025', '0x0029', '0x0044'],
    },
    2: {
        'GRASS': ['0x0022', '0x0026', '0x0045'],
    },
    3: {
        'GRASS': ['0x001E', '0x0049'],
    },
    4: {
        'GRASS': ['0x0028', '0x0047'],
    },
    5: {
        'GRASS': ['0x002C', '0x0031'],
    },
    6: {
        'GRASS': ['0x0020', '0x004B'],
    },
    7: {
        'GRASS': ['0x002E'],
    },
    8: {
        'GRASS': ['0x0023', '0x0027', '0x0046'],
    },
    9: {
        'GRASS': ['0x001D', '0x0048'],
    },
    10: {
        'GRASS': ['0x002A', '0x002B', '0x0032'],
    },
    11: {
        'GRASS': ['0x002D'],
    },
    12: {
        'GRASS': ['0x001F', '0x004A'],
    },
    13: {
        'GRASS': ['0x002F'],
    },
    14: {
        'GRASS': ['0x0030'],
    },
};

export function getSlopeTileForBitmask(bitmask, transitionType = 'generic', rng = Math.random) {
    // Try exact match first
    let effectiveBitmask = bitmask;
    if (!SLOPE_TILE_MAPPING[effectiveBitmask]) {
        // Fallback: Find best subset match (key that is subset of bitmask with most bits)
        let bestMatch = 0;
        let maxBits = -1;
        for (const keyStr of Object.keys(SLOPE_TILE_MAPPING)) {
            const key = parseInt(keyStr);
            if (key > 0 && (key & bitmask) === key) {
                let bits = 0; let n = key; while(n) { bits++; n &= n-1; }
                if (bits > maxBits) { maxBits = bits; bestMatch = key; }
            }
        }
        if (bestMatch > 0) effectiveBitmask = bestMatch;
    }

    const bitmaskGroup = SLOPE_TILE_MAPPING[effectiveBitmask];
    if (!bitmaskGroup) return null;

    // Try specific transition type first, then fallback to generic/mixed
    let tiles = bitmaskGroup[transitionType];
    if (!tiles || tiles.length === 0) tiles = bitmaskGroup['MIXED'];
    if (!tiles || tiles.length === 0) tiles = bitmaskGroup['GRASS']; // Final fallback
    if (!tiles || tiles.length === 0) tiles = bitmaskGroup['SAND'];

    if (tiles && tiles.length > 0) {
        return tiles[Math.floor(rng() * tiles.length)];
    }
    return null;
}

export function calculateSlopeBitmask(map, x, y, width, height, targetBiome, invert = false) {
    let bitmask = 0;
    // Isometric Neighbor Mapping:
    // y-1 (North in array) -> Top-Right Edge (Bit 1)
    // x+1 (East in array)  -> Bottom-Right Edge (Bit 2)
    // y+1 (South in array) -> Bottom-Left Edge (Bit 4)
    // x-1 (West in array)  -> Top-Left Edge (Bit 8)

    // Top-Right Edge (North Neighbor y-1)
    if (y > 0) {
        const match = map[y - 1][x].biome === targetBiome;
        if (invert ? !match : match) bitmask |= 1;
    } else if (invert) {
        // If invert (looking for NOT target), and we are at map edge...
        // Assume map edge is same as target (don't draw border)? Or different?
        // Usually assume infinite terrain of same type -> no border.
    }

    // Bottom-Right Edge (East Neighbor x+1)
    if (x < width - 1) {
        const match = map[y][x + 1].biome === targetBiome;
        if (invert ? !match : match) bitmask |= 2;
    }

    // Bottom-Left Edge (South Neighbor y+1)
    if (y < height - 1) {
        const match = map[y + 1][x].biome === targetBiome;
        if (invert ? !match : match) bitmask |= 4;
    }

    // Top-Left Edge (West Neighbor x-1)
    if (x > 0) {
        const match = map[y][x - 1].biome === targetBiome;
        if (invert ? !match : match) bitmask |= 8;
    }

    return bitmask;
}
